{"key":"Java","url":"https://blog.aquariuslt.com/tags/java","path":"/tags/java","title":"Tag: Java | Aquariuslt Blog","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.aquariuslt.com","name":"Aquariuslt Blog","position":1},{"@type":"ListItem","item":"https://blog.aquariuslt.com/tags","name":"Tags","position":2},{"@type":"ListItem","item":"https://blog.aquariuslt.com/tags/java","name":"Java","position":3}]},"metas":[{"name":"og:site_name","content":"Aquariuslt Blog"},{"name":"og:type","content":"website"},{"name":"og:description","content":"Tag: Java"}],"type":"LIST","data":[{"title":"基于Karma的非分离式前端单元测试基础方案","id":"karma-based-traditional-java-web-frontend-unittest-solution","created":"2018-03-04T00:00:00.000Z","updated":"2018-03-04T00:00:00.000Z","categories":["Blog"],"tags":["Java","JAWR","Karma","JavaScript","Webpack","ExtJS","Spring","JSF","SpringMVC"],"cover":"/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution/cover.png","summary":"TL;DR之前在为公司一个稍微有些年头的核心系统的代码寻找一个合理的单元测试方案，在摆弄了一段时间后，目前奠定了一个基于 Karma 的前端单元测试方案。如果你的项目符合以下条件，那么这个解决方案和其中的思路也许能对你的项目有点帮助。原本的项目与前端相关的部分属于 Java Web 项目，抛开与本次主题无关的部分，具体影响单元测试方案选型和落地的几个因素，我把他归结成几类：\n","link":"/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution"},{"title":"Google CodeJam 2016 Qualification","id":"google-codejam-2016-qualification-round","created":"2016-04-10T00:00:00.000Z","updated":"2016-04-10T00:00:00.000Z","categories":["Note"],"tags":["Java","Google"],"cover":"/posts/2016/04/10/google-codejam-2016-qualification-round/cover.png","summary":"今早结束的 Google CodeJam 2016 资格赛. 由于智商问题和加班了一天,所以只能水出前面两道水题. 但是还是稍微涨了点姿势. 记录下解题的过程和一些小彩蛋.将我的 A 和 B 的 Solution 放在Github上了.\n","link":"/posts/2016/04/10/google-codejam-2016-qualification-round"},{"title":"记一次神奇的优化过程:Java反射 VS Apache BeanUtils VS Spring BeanUtils","id":"beanutils-vs-reflection","created":"2015-11-10T00:00:00.000Z","updated":"2015-11-10T00:00:00.000Z","categories":["Blog"],"tags":["Java","Apache"],"cover":"/posts/2015/11/10/beanutils-vs-reflection/cover.png","summary":"最近老大分配了个性能优化的任务,因为主要页面在 Production 上打开的时间太长,(大概 7s?卧槽 第一次听到的时候还以为我听错了). 居然这么慢.. 其实是有主程序大大带着我做,所以在扫了一遍前端 ExtJS 的结构之后,发现错综复杂四年以来不同技术层次的人都在同一个页面上添油加醋, 了解以前的需求之后完全重构基本是不可能的,所以前端的性能优化就交给主程序大大,我跑去扫一下服务器端有什么性能瓶颈.\n","link":"/posts/2015/11/10/beanutils-vs-reflection"},{"title":"Spring 整合 Apache Shiro 实现各等级的权限管理","id":"apache-shiro-spring-integration","created":"2015-10-25T00:00:00.000Z","updated":"2015-10-25T00:00:00.000Z","categories":["Blog"],"tags":["Spring","Security","Shiro","Java"],"cover":"/posts/2015/10/25/apache-shiro-spring-integration/cover.png","summary":"前几个月在做一个常规的权限隔离功能的时候,恰好使用过 Apache Shiro. Apache Shiro 是一款 Java 的安全框架,通常用作 Web 应用的权限校验,身份验证.Apache Shiro is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.\n","link":"/posts/2015/10/25/apache-shiro-spring-integration"}]}