{"key":"keep-your-repo-dependencies-up-to-date-with-renovate","url":"https://zexo.dev/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate","path":"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate","title":"使用 renovate 监控第三方依赖更新 | zexo.dev","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zexo.dev","name":"Home","position":1},{"@type":"ListItem","item":"https://zexo.dev/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://zexo.dev/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate","name":"使用 renovate 监控第三方依赖更新","position":3}]},"type":"DETAIL","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"id":"google-analytics","name":"google-analytics","content":"UA-68904127-2"},{"name":"og:site_name","content":"zexo.dev"},{"name":"og:type","content":"website"},{"name":"og:title","itemprop":"name","content":"使用 renovate 监控第三方依赖更新"},{"name":"og:description","itemprop":"description","content":"依赖更新管理曾一直是我容易纠结的一个问题。我希望一直保持我的仓库使用的第三方 package 一直能保持 安全情况下 的最新版本，随着最新版本的更新，一般伴随着以下几种用户关心的内容：fixing: 修复了一些 bugperformance tuning: 一些性能优化\n"},{"name":"og:image","itemprop":"image","content":"https:/zexo.dev/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate.png"},{"name":"og:type","content":"article"},{"name":"description","itemprop":"description","content":"依赖更新管理曾一直是我容易纠结的一个问题。我希望一直保持我的仓库使用的第三方 package 一直能保持 安全情况下 的最新版本，随着最新版本的更新，一般伴随着以下几种用户关心的内容：fixing: 修复了一些 bugperformance tuning: 一些性能优化\n"}],"data":{"title":"使用 renovate 监控第三方依赖更新","id":"keep-your-repo-dependencies-up-to-date-with-renovate","created":"2020-03-01T00:00:00.000Z","updated":"2020-03-01T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"node","label":"Node","total":0,"link":"/tags/node"},{"id":"ci","label":"CI","total":1,"link":"/tags/ci"},{"id":"npm","label":"NPM","total":2,"link":"/tags/npm"},{"id":"renovate","label":"Renovate","total":3,"link":"/tags/renovate"},{"id":"github","label":"Github","total":4,"link":"/tags/github"}],"cover":"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate.png","images":["./revonate-setup-pull-request.png","./revonate-circleci-docker-image-support.png"],"toc":[{"label":"使用 renovate 监控第三方依赖更新","level":1,"id":"使用-renovate-监控第三方依赖更新","position":0,"children":[],"pid":-1},{"label":"背景","level":2,"id":"背景","position":1,"children":[],"pid":0},{"label":"现状","level":2,"id":"现状","position":2,"children":[],"pid":0},{"label":"遇见 Renovate","level":2,"id":"遇见-renovate","position":3,"children":[],"pid":0},{"label":"Renovate 是什么","level":3,"id":"renovate-是什么","position":4,"children":[],"pid":3},{"label":"Renovate 使用体验","level":2,"id":"renovate-使用体验","position":5,"children":[],"pid":0},{"label":"1. 安装 renovate","level":3,"id":"1-安装-renovate","position":6,"children":[],"pid":5},{"label":"2. 配置 renovate","level":3,"id":"2-配置-renovate","position":7,"children":[],"pid":5},{"label":"3. Pin Dependencies","level":3,"id":"3-pin-dependencies","position":8,"children":[],"pid":5},{"label":"4. Update Dependencies","level":3,"id":"4-update-dependencies","position":9,"children":[],"pid":5},{"label":"意外惊喜","level":3,"id":"意外惊喜","position":10,"children":[],"pid":5},{"label":"结论与思考","level":2,"id":"结论与思考","position":11,"children":[],"pid":0},{"label":"结论","level":3,"id":"结论","position":12,"children":[],"pid":11},{"label":"思考","level":3,"id":"思考","position":13,"children":[],"pid":11}],"summary":"依赖更新管理曾一直是我容易纠结的一个问题。我希望一直保持我的仓库使用的第三方 package 一直能保持 安全情况下 的最新版本，随着最新版本的更新，一般伴随着以下几种用户关心的内容：fixing: 修复了一些 bugperformance tuning: 一些性能优化\n","src":"\n# 使用 renovate 监控第三方依赖更新\n\n## 背景\n\n依赖更新管理曾一直是我容易纠结的一个问题。\n\n我希望一直保持我的仓库使用的第三方 package 一直能保持 **安全情况下** 的最新版本，\n\n随着最新版本的更新，一般伴随着以下几种用户关心的内容：\n\n- fixing: 修复了一些 bug\n- performance tuning: 一些性能优化\n- feat: 一些新的功能\n- BREAKING CHANGES: 这个版本相对老版本是否有破坏性的更变，可以帮助开发者决策是否直接升级(亦或是不升级，或先兼容后升级)\n\n不管是使用什么语言的项目，对应生态中，成为事实标准的包管理器，一般都会提供如下的依赖更新相关功能：\n\n- 查找项目中已安装的依赖版本，对比包管理器 registry 上的最新可升级版本，并提示最新版本可用\n- 在按照原依赖描述文件安装依赖时，可提示开发者有版本更新\n\n对于接触的比较多的 node 项目，他的事实标准(在我心中的)可能是 `yarn` 。\n\n因为 npm 及其 package 的版本号设计，遵循了 [semver versioning](https://semver.org/) 的一些基本原则，使得更新依赖稍微能程序化一点。\n\n在简单的情况下，对于常见的 node + singlerepo 类型项目，我一般怎么做?\n\n我使用的是 yarn 的 `upgrade-interactive --latest`\n\n官方文档: [https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive/](https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive/)\n\n通过这种手动在本地执行命令的形式，可以手动的获取项目所依赖的 npm package 的最新版本与本地依赖描述文件之间的差异，以及提供一个交互式的命令供你选择你想要更新的部分 packages。\n\n之后在下载安装最新版本的依赖时，同时把那些依赖的最新版本的版本号持久化到以来描述文件 `package.json` 中去。\n\n毫不犹豫的说，对于开源(托管在 github 上的 public repo)，亦或是依赖了一些私有 registry 的 package 的代码仓库，这种人工更新的方式还是比较有效的。\n\n## 现状\n\n这种情况会有什么缺陷呢?\n\n把目前的人工更新方案，拆分成两种类型的缺陷:\n\n1. 人工执行命令以主动检查更新 (主动拉取)\n2. 对于 lerna + monorepo 而言，yarn 的 `upgrade-interactive` 对 monorepo 没有很好的支持\n\n人工执行命令以主动检查更新，对于依赖个数上百、数百的项目来讲，着实有点麻烦。相当于一个人工轮询去检查是否有更新，而且放到开发者这方的话，开发体验不会很好。\n\n稍微好的一点方案，是自动化的执行这些更新脚本，并开发一个类似 `-y` 一样的参数来实现静默允许直接更新依赖，以跳过交互式命令的步骤。\n\n对于 lerna + monorepo 呢?\n\nyarn 的 `upgrade-interactive` 没能很好的支持，技术原因上是因为 lerna 在执行命令 `bootstrap` 的过程中，对 monorepo 内具有互相依赖关系的私有子项目，并不是直接在每个子仓库下直接进行 `npm install` or `yarn install` 。而是会拆分成几个步骤，这里为了简述，描述成几步:\n\n1. 对 monorepo 下的多个 package.json 进行 backup，复制一份备份版本\n2. 对 monorepo 下的多个 package.json 进行修改，移除 monorepo 的私有依赖声明\n3. 在每个仓库下分别执行 install 命令，此时能确保都能从远程的 registry 上下载其他非私有依赖\n4. 进行 symlink，将私有依赖创建 symlink，根据计算好的依赖关系，连接到每个子项目的 `node_modules` 对应的目录中去\n5. 将备份版本的多个 package.json 归回原位\n\n由于 `yarn upgrade-interactive` 并不能识别 package.json 中的私有依赖，在 monorepo 中执行此命令，会使得由于无法在远程 registry 中查找到私有依赖，导致错误退出。\n\nyarn 在最近发布了 v2 大版本，不知道对他原生的 monorepo (workspace) 支持，是否会考虑到这里的增强。\n\n这是我认为人工执行 `yarn upgrade-interactive` 所存在的问题。\n\n那么常规的开源项目，或者我曾了解的开源项目怎么做?\n\n对，那就是代码仓库平台集成的一些依赖监控服务，在没有讲到今天的主题之前，我所了解到的是:\n\n- [https://dependabot.com/](https://dependabot.com/) depent bot\n- [https://david-dm.org/](https://david-dm.org/) david-dm 专门为 node.js 类 repo 提供依赖版本监控\n\n有一说一 david-dm 确实比较菜了，作为第三方服务基本处于不可用的状态。\n\ndepentbot 可以提供监控多语言的依赖更新、协助更新依赖切提 Pull Request 等自动化服务。\n\n然而在轻度体验后的结果，发现有几点不太理想:\n\n1. 不能自动识别仓库的主要编程语言，需要在其官方平台网站上进行手动确认\n2. 对于 monorepo 的问题，直至 2020 年 2 月底也没有好的解决方案\n\n## 遇见 Renovate\n\n最近一段时间比较关注 NestJS 社区及其成长，在学习源码时了解到一些相关的 CI 方面的实践。\n\n在此过程中，了解到他们为了解决监控依赖更新问题，使用的服务是 Renovate。\n\n### Renovate 是什么\n\nRenovate 是一家名为 WhiteSource 的公司开发的一项适用于多种语言的依赖更新监控服务。目前在 Github 上以 Github Apps 的形式，可以为接入此 Apps 的项目提供依赖更新监控相关的服务。\n\n## Renovate 使用体验\n\n简单来讲，目前我在 Github 上使用 Renovate 的时间相对少，但是满足了我目前对依赖更新管控的基本需求，还有一些意外惊喜。\n\n简要分享下，在安装、使用 renovate 中的一些过程。\n\n### 1. 安装 renovate\n\n与常见的 Github Apps 一样，首先在 Github Market place 搜索 renovate 并进行安装，按需授予权限。\n\n[https://github.com/marketplace/renovate](https://github.com/marketplace/renovate)\n\n### 2. 配置 renovate\n\n安装 renovate 之后无须手动操作，等待即可。\n\n此时 renovate 将会扫描你授予权限的仓库，做一些简要分析，分析你的各个项目主力语言、依赖管理方式，之后将会对哪些可以被通过 renovate 管控更新依赖的仓库，分别提交一份 Pull Request.\n\n这个 Pull Request 的标题叫做 **Configure Renovate，**中间附带了一个文件更变，便是他会在项目的更目录下添加 `renovate` 的配置文件，名为 `renovate.json` 。\n\n这个配置文件描述了一些 renovate 管理此仓库依赖的相关选项，默认生成的 `config:base` 已经能够满足日常需要。\n\n如果开发者很不爽在项目根目录增添这样一个 json 配置文件，可以按照他们官方配置发现的目录查找顺序，移入到 `.github` 目录下。(具体查找规则，官方有较为详细的说明文档)\n\n![revonate-setup-pull-request](./revonate-setup-pull-request.png)\n\n### 3. Pin Dependencies\n\n合入第二点的 PR 后，不久变会收到第二个初始化类型的 PR: Pin Dependencies。\n\n顾名思义，这里的意思是锁定目前的依赖版本，且为以后持续接受依赖更新做准备。\n\n以 Node 类型仓库来讲，这个 PR 的具体内容，便是先在每个 package.json 内容中，将依赖的版本无损更新到最新版本号 (指符合 semver versioning 的更新规则) 之后，去除 package.json 中每项依赖版本号之前的 `^` 和 `~` ，以将模糊的 semver versioning 版本监控行为变成确定的版本号。\n\n### 4. Update Dependencies\n\n在第三点之后，接下来的就是日常的监控依赖更新了。\n\n每当依赖的新版本发布时，他会针对单条依赖的更新提交 PR，如果依赖中有符合标准的 CHANGELOG 也会直接加入到 PR 的 description 中。\n\n其中，他们也会对发布到 registry 的依赖文件内容，进行 diff，以生成 renovate 自己分析的的\"依赖构建产物\" diff，以供查看。\n\n在对项目的依赖描述文件扫描、分析更新这部分，能够对 monorepo 提供很好的支持。\n\n比方说在我的 blog 项目中，有一个属于主题的子项目，该子项目依赖了一些 blog 项目的私有依赖，大概如下:\n\n```json\n{\n  \"dependencies\": {\n    \"@blog/common\": \"^6.21.4\",\n    \"@blog/config\": \"^6.21.4\",\n    \"@loadable/component\": \"5.12.0\",\n    \"@material-ui/core\": \"4.9.4\",\n    \"@material-ui/icons\": \"4.9.1\",\n    \"axios\": \"0.19.2\",\n    \"classnames\": \"2.2.6\",\n    \"clsx\": \"1.1.0\",\n    \"date-fns\": \"2.10.0\",\n    \"github-markdown-css\": \"4.0.0\",\n    \"highlight.js\": \"9.18.1\",\n    \"react\": \"16.13.0\",\n    \"react-disqus-components\": \"1.2.2\",\n    \"react-dom\": \"16.13.0\",\n    \"react-helmet\": \"5.2.1\",\n    \"react-router-dom\": \"5.1.2\",\n    \"scroll-into-view-if-needed\": \"2.2.24\",\n    \"typeface-roboto\": \"0.0.75\",\n    \"vanilla-lazyload\": \"12.5.1\"\n  }\n}\n```\n\n其中 package.json 中 `@blog` 开头的两个依赖，属于私有依赖，在 npm registry 中无法找到。对于非私有依赖， renovate 都能逐个帮你进行监控，并在版本更新的时候及时提出 PR。\n\n### 意外惊喜\n\n惊喜的是，在 merge PR 时，renovate 还会增加一个 `conventional commit` 的检测: 如果你在项目中显式地配置了主流的 commit lint 以及 commit message 风格检测，他会按照这些常见的风格来修改 PR 的标题:\n\n如: [https://github.com/aquariuslt/blog/pull/38](https://github.com/aquariuslt/blog/pull/38)\n\n标题为: chore(deps): update dependency @types/node to v13.7.7 #38\n\n对于 circleci，也提供了的 CI 环境下的 docker-image 版本监控\n\n![circle-ci-docker-image-support](./revonate-circleci-docker-image-support.png)\n\n## 结论与思考\n\n### 结论\n\nrenovate 是我目前遇到的最能满足监控依赖更新的一项服务，满足了我在 Github 上的 node 项目监控依赖更新的迫切需求。\n\n目前我所有放在 github 上的 node, java 项目都接入了该项服务。\n\n### 思考\n\n如果要为私有项目解决这个问题，我可能会怎么做\n\n在公司内部，特别是一些大厂，通常有自己的内部源码仓库，如 Self-hosted Gitlab，自研的 Git 平台，还会有内部的各种 包管理对应的私有 registry。\n\n如果需要为内部私有项目解决第三方依赖版本管控问题，renovate 的使用体验则为我们带来了一个很好的标杆。\n\n如果有一天有空去写轮眼这个服务，我一定会从他的官方文档、配置文档、使用体验中反推基本实现，并将中间 github 操作相关 api 转成内部平台支持的 api，编写插件，设计分析服务。\n\n也许需要下面的特性:\n\n- 依赖描述文件扫描与发现\n- 尽可能分析出可被分析的依赖版本\n- 结合各种语言生态事实标准，更新依赖，生成合理的 commit message\n- 对应仓库平台 Pull Request API 适配实现\n","html":"<h1 id=\"使用-renovate-监控第三方依赖更新\">使用 renovate 监控第三方依赖更新</h1>\n<h2 id=\"背景\">背景</h2>\n<p>依赖更新管理曾一直是我容易纠结的一个问题。</p>\n<p>我希望一直保持我的仓库使用的第三方 package 一直能保持 <strong>安全情况下</strong> 的最新版本，</p>\n<p>随着最新版本的更新，一般伴随着以下几种用户关心的内容：</p>\n<ul>\n<li>fixing: 修复了一些 bug</li>\n<li>performance tuning: 一些性能优化</li>\n<li>feat: 一些新的功能</li>\n<li>BREAKING CHANGES: 这个版本相对老版本是否有破坏性的更变，可以帮助开发者决策是否直接升级(亦或是不升级，或先兼容后升级)</li>\n</ul>\n<p>不管是使用什么语言的项目，对应生态中，成为事实标准的包管理器，一般都会提供如下的依赖更新相关功能：</p>\n<ul>\n<li>查找项目中已安装的依赖版本，对比包管理器 registry 上的最新可升级版本，并提示最新版本可用</li>\n<li>在按照原依赖描述文件安装依赖时，可提示开发者有版本更新</li>\n</ul>\n<p>对于接触的比较多的 node 项目，他的事实标准(在我心中的)可能是 <code>yarn</code> 。</p>\n<p>因为 npm 及其 package 的版本号设计，遵循了 <a href=\"https://semver.org/\">semver versioning</a> 的一些基本原则，使得更新依赖稍微能程序化一点。</p>\n<p>在简单的情况下，对于常见的 node + singlerepo 类型项目，我一般怎么做?</p>\n<p>我使用的是 yarn 的 <code>upgrade-interactive --latest</code></p>\n<p>官方文档: <a href=\"https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive/\">https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive/</a></p>\n<p>通过这种手动在本地执行命令的形式，可以手动的获取项目所依赖的 npm package 的最新版本与本地依赖描述文件之间的差异，以及提供一个交互式的命令供你选择你想要更新的部分 packages。</p>\n<p>之后在下载安装最新版本的依赖时，同时把那些依赖的最新版本的版本号持久化到以来描述文件 <code>package.json</code> 中去。</p>\n<p>毫不犹豫的说，对于开源(托管在 github 上的 public repo)，亦或是依赖了一些私有 registry 的 package 的代码仓库，这种人工更新的方式还是比较有效的。</p>\n<h2 id=\"现状\">现状</h2>\n<p>这种情况会有什么缺陷呢?</p>\n<p>把目前的人工更新方案，拆分成两种类型的缺陷:</p>\n<ol>\n<li>人工执行命令以主动检查更新 (主动拉取)</li>\n<li>对于 lerna + monorepo 而言，yarn 的 <code>upgrade-interactive</code> 对 monorepo 没有很好的支持</li>\n</ol>\n<p>人工执行命令以主动检查更新，对于依赖个数上百、数百的项目来讲，着实有点麻烦。相当于一个人工轮询去检查是否有更新，而且放到开发者这方的话，开发体验不会很好。</p>\n<p>稍微好的一点方案，是自动化的执行这些更新脚本，并开发一个类似 <code>-y</code> 一样的参数来实现静默允许直接更新依赖，以跳过交互式命令的步骤。</p>\n<p>对于 lerna + monorepo 呢?</p>\n<p>yarn 的 <code>upgrade-interactive</code> 没能很好的支持，技术原因上是因为 lerna 在执行命令 <code>bootstrap</code> 的过程中，对 monorepo 内具有互相依赖关系的私有子项目，并不是直接在每个子仓库下直接进行 <code>npm install</code> or <code>yarn install</code> 。而是会拆分成几个步骤，这里为了简述，描述成几步:</p>\n<ol>\n<li>对 monorepo 下的多个 package.json 进行 backup，复制一份备份版本</li>\n<li>对 monorepo 下的多个 package.json 进行修改，移除 monorepo 的私有依赖声明</li>\n<li>在每个仓库下分别执行 install 命令，此时能确保都能从远程的 registry 上下载其他非私有依赖</li>\n<li>进行 symlink，将私有依赖创建 symlink，根据计算好的依赖关系，连接到每个子项目的 <code>node_modules</code> 对应的目录中去</li>\n<li>将备份版本的多个 package.json 归回原位</li>\n</ol>\n<p>由于 <code>yarn upgrade-interactive</code> 并不能识别 package.json 中的私有依赖，在 monorepo 中执行此命令，会使得由于无法在远程 registry 中查找到私有依赖，导致错误退出。</p>\n<p>yarn 在最近发布了 v2 大版本，不知道对他原生的 monorepo (workspace) 支持，是否会考虑到这里的增强。</p>\n<p>这是我认为人工执行 <code>yarn upgrade-interactive</code> 所存在的问题。</p>\n<p>那么常规的开源项目，或者我曾了解的开源项目怎么做?</p>\n<p>对，那就是代码仓库平台集成的一些依赖监控服务，在没有讲到今天的主题之前，我所了解到的是:</p>\n<ul>\n<li><a href=\"https://dependabot.com/\">https://dependabot.com/</a> depent bot</li>\n<li><a href=\"https://david-dm.org/\">https://david-dm.org/</a> david-dm 专门为 node.js 类 repo 提供依赖版本监控</li>\n</ul>\n<p>有一说一 david-dm 确实比较菜了，作为第三方服务基本处于不可用的状态。</p>\n<p>depentbot 可以提供监控多语言的依赖更新、协助更新依赖切提 Pull Request 等自动化服务。</p>\n<p>然而在轻度体验后的结果，发现有几点不太理想:</p>\n<ol>\n<li>不能自动识别仓库的主要编程语言，需要在其官方平台网站上进行手动确认</li>\n<li>对于 monorepo 的问题，直至 2020 年 2 月底也没有好的解决方案</li>\n</ol>\n<h2 id=\"遇见-renovate\">遇见 Renovate</h2>\n<p>最近一段时间比较关注 NestJS 社区及其成长，在学习源码时了解到一些相关的 CI 方面的实践。</p>\n<p>在此过程中，了解到他们为了解决监控依赖更新问题，使用的服务是 Renovate。</p>\n<h3 id=\"renovate-是什么\">Renovate 是什么</h3>\n<p>Renovate 是一家名为 WhiteSource 的公司开发的一项适用于多种语言的依赖更新监控服务。目前在 Github 上以 Github Apps 的形式，可以为接入此 Apps 的项目提供依赖更新监控相关的服务。</p>\n<h2 id=\"renovate-使用体验\">Renovate 使用体验</h2>\n<p>简单来讲，目前我在 Github 上使用 Renovate 的时间相对少，但是满足了我目前对依赖更新管控的基本需求，还有一些意外惊喜。</p>\n<p>简要分享下，在安装、使用 renovate 中的一些过程。</p>\n<h3 id=\"1-安装-renovate\">1. 安装 renovate</h3>\n<p>与常见的 Github Apps 一样，首先在 Github Market place 搜索 renovate 并进行安装，按需授予权限。</p>\n<p><a href=\"https://github.com/marketplace/renovate\">https://github.com/marketplace/renovate</a></p>\n<h3 id=\"2-配置-renovate\">2. 配置 renovate</h3>\n<p>安装 renovate 之后无须手动操作，等待即可。</p>\n<p>此时 renovate 将会扫描你授予权限的仓库，做一些简要分析，分析你的各个项目主力语言、依赖管理方式，之后将会对哪些可以被通过 renovate 管控更新依赖的仓库，分别提交一份 Pull Request.</p>\n<p>这个 Pull Request 的标题叫做 **Configure Renovate，**中间附带了一个文件更变，便是他会在项目的更目录下添加 <code>renovate</code> 的配置文件，名为 <code>renovate.json</code> 。</p>\n<p>这个配置文件描述了一些 renovate 管理此仓库依赖的相关选项，默认生成的 <code>config:base</code> 已经能够满足日常需要。</p>\n<p>如果开发者很不爽在项目根目录增添这样一个 json 配置文件，可以按照他们官方配置发现的目录查找顺序，移入到 <code>.github</code> 目录下。(具体查找规则，官方有较为详细的说明文档)</p>\n<p>\n        <picture>\n          <source srcset=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABkAAAAJWAQMAAAA6AtlxAAAAA1BMVEX///+nxBvIAAAAi0lEQVR42u3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wbVlQABttAC+QAAAABJRU5ErkJggg==\"  data-srcset=\"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate-setup-pull-request.webp\" type=\"image/webp\" data-was-processed=\"false\" />\n          <img alt=\"\" class=\"lazy\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABkAAAAJWAQMAAAA6AtlxAAAAA1BMVEX///+nxBvIAAAAi0lEQVR42u3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wbVlQABttAC+QAAAABJRU5ErkJggg==\" data-src=\"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate-setup-pull-request.png\" loading=\"lazy\"/>\n        </picture>\n    </p>\n<h3 id=\"3-pin-dependencies\">3. Pin Dependencies</h3>\n<p>合入第二点的 PR 后，不久变会收到第二个初始化类型的 PR: Pin Dependencies。</p>\n<p>顾名思义，这里的意思是锁定目前的依赖版本，且为以后持续接受依赖更新做准备。</p>\n<p>以 Node 类型仓库来讲，这个 PR 的具体内容，便是先在每个 package.json 内容中，将依赖的版本无损更新到最新版本号 (指符合 semver versioning 的更新规则) 之后，去除 package.json 中每项依赖版本号之前的 <code>^</code> 和 <code>~</code> ，以将模糊的 semver versioning 版本监控行为变成确定的版本号。</p>\n<h3 id=\"4-update-dependencies\">4. Update Dependencies</h3>\n<p>在第三点之后，接下来的就是日常的监控依赖更新了。</p>\n<p>每当依赖的新版本发布时，他会针对单条依赖的更新提交 PR，如果依赖中有符合标准的 CHANGELOG 也会直接加入到 PR 的 description 中。</p>\n<p>其中，他们也会对发布到 registry 的依赖文件内容，进行 diff，以生成 renovate 自己分析的的&quot;依赖构建产物&quot; diff，以供查看。</p>\n<p>在对项目的依赖描述文件扫描、分析更新这部分，能够对 monorepo 提供很好的支持。</p>\n<p>比方说在我的 blog 项目中，有一个属于主题的子项目，该子项目依赖了一些 blog 项目的私有依赖，大概如下:</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"dependencies\"</span>: {\n    <span class=\"hljs-attr\">\"@blog/common\"</span>: <span class=\"hljs-string\">\"^6.21.4\"</span>,\n    <span class=\"hljs-attr\">\"@blog/config\"</span>: <span class=\"hljs-string\">\"^6.21.4\"</span>,\n    <span class=\"hljs-attr\">\"@loadable/component\"</span>: <span class=\"hljs-string\">\"5.12.0\"</span>,\n    <span class=\"hljs-attr\">\"@material-ui/core\"</span>: <span class=\"hljs-string\">\"4.9.4\"</span>,\n    <span class=\"hljs-attr\">\"@material-ui/icons\"</span>: <span class=\"hljs-string\">\"4.9.1\"</span>,\n    <span class=\"hljs-attr\">\"axios\"</span>: <span class=\"hljs-string\">\"0.19.2\"</span>,\n    <span class=\"hljs-attr\">\"classnames\"</span>: <span class=\"hljs-string\">\"2.2.6\"</span>,\n    <span class=\"hljs-attr\">\"clsx\"</span>: <span class=\"hljs-string\">\"1.1.0\"</span>,\n    <span class=\"hljs-attr\">\"date-fns\"</span>: <span class=\"hljs-string\">\"2.10.0\"</span>,\n    <span class=\"hljs-attr\">\"github-markdown-css\"</span>: <span class=\"hljs-string\">\"4.0.0\"</span>,\n    <span class=\"hljs-attr\">\"highlight.js\"</span>: <span class=\"hljs-string\">\"9.18.1\"</span>,\n    <span class=\"hljs-attr\">\"react\"</span>: <span class=\"hljs-string\">\"16.13.0\"</span>,\n    <span class=\"hljs-attr\">\"react-disqus-components\"</span>: <span class=\"hljs-string\">\"1.2.2\"</span>,\n    <span class=\"hljs-attr\">\"react-dom\"</span>: <span class=\"hljs-string\">\"16.13.0\"</span>,\n    <span class=\"hljs-attr\">\"react-helmet\"</span>: <span class=\"hljs-string\">\"5.2.1\"</span>,\n    <span class=\"hljs-attr\">\"react-router-dom\"</span>: <span class=\"hljs-string\">\"5.1.2\"</span>,\n    <span class=\"hljs-attr\">\"scroll-into-view-if-needed\"</span>: <span class=\"hljs-string\">\"2.2.24\"</span>,\n    <span class=\"hljs-attr\">\"typeface-roboto\"</span>: <span class=\"hljs-string\">\"0.0.75\"</span>,\n    <span class=\"hljs-attr\">\"vanilla-lazyload\"</span>: <span class=\"hljs-string\">\"12.5.1\"</span>\n  }\n}\n</code></pre>\n<p>其中 package.json 中 <code>@blog</code> 开头的两个依赖，属于私有依赖，在 npm registry 中无法找到。对于非私有依赖， renovate 都能逐个帮你进行监控，并在版本更新的时候及时提出 PR。</p>\n<h3 id=\"意外惊喜\">意外惊喜</h3>\n<p>惊喜的是，在 merge PR 时，renovate 还会增加一个 <code>conventional commit</code> 的检测: 如果你在项目中显式地配置了主流的 commit lint 以及 commit message 风格检测，他会按照这些常见的风格来修改 PR 的标题:</p>\n<p>如: <a href=\"https://github.com/aquariuslt/blog/pull/38\">https://github.com/aquariuslt/blog/pull/38</a></p>\n<p>标题为: chore(deps): update dependency @types/node to v13.7.7 #38</p>\n<p>对于 circleci，也提供了的 CI 环境下的 docker-image 版本监控</p>\n<p>\n        <picture>\n          <source srcset=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABkAAAAJWAQMAAAA6AtlxAAAAA1BMVEX///+nxBvIAAAAi0lEQVR42u3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wbVlQABttAC+QAAAABJRU5ErkJggg==\"  data-srcset=\"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate-circleci-docker-image-support.webp\" type=\"image/webp\" data-was-processed=\"false\" />\n          <img alt=\"\" class=\"lazy\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABkAAAAJWAQMAAAA6AtlxAAAAA1BMVEX///+nxBvIAAAAi0lEQVR42u3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wbVlQABttAC+QAAAABJRU5ErkJggg==\" data-src=\"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate-circleci-docker-image-support.png\" loading=\"lazy\"/>\n        </picture>\n    </p>\n<h2 id=\"结论与思考\">结论与思考</h2>\n<h3 id=\"结论\">结论</h3>\n<p>renovate 是我目前遇到的最能满足监控依赖更新的一项服务，满足了我在 Github 上的 node 项目监控依赖更新的迫切需求。</p>\n<p>目前我所有放在 github 上的 node, java 项目都接入了该项服务。</p>\n<h3 id=\"思考\">思考</h3>\n<p>如果要为私有项目解决这个问题，我可能会怎么做</p>\n<p>在公司内部，特别是一些大厂，通常有自己的内部源码仓库，如 Self-hosted Gitlab，自研的 Git 平台，还会有内部的各种 包管理对应的私有 registry。</p>\n<p>如果需要为内部私有项目解决第三方依赖版本管控问题，renovate 的使用体验则为我们带来了一个很好的标杆。</p>\n<p>如果有一天有空去写轮眼这个服务，我一定会从他的官方文档、配置文档、使用体验中反推基本实现，并将中间 github 操作相关 api 转成内部平台支持的 api，编写插件，设计分析服务。</p>\n<p>也许需要下面的特性:</p>\n<ul>\n<li>依赖描述文件扫描与发现</li>\n<li>尽可能分析出可被分析的依赖版本</li>\n<li>结合各种语言生态事实标准，更新依赖，生成合理的 commit message</li>\n<li>对应仓库平台 Pull Request API 适配实现</li>\n</ul>\n","disqus":{"shortname":"aquariuslt","url":"https://zexo.dev/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate","identifier":"-posts-2020-03-01-keep-your-repo-dependencies-up-to-date-with-renovate"}}}