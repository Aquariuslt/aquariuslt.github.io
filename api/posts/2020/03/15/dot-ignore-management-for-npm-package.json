{"key":"dot-ignore-management-for-npm-package","url":"https://zexo.dev/posts/2020/03/15/dot-ignore-management-for-npm-package","path":"/posts/2020/03/15/dot-ignore-management-for-npm-package","title":"管理你的 .ignore 类文件 - zexo.dev","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zexo.dev","name":"Home","position":1},{"@type":"ListItem","item":"https://zexo.dev/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://zexo.dev/posts/2020/03/15/dot-ignore-management-for-npm-package","name":"管理你的 .ignore 类文件","position":3}]},"type":"DETAIL","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"id":"google-analytics","name":"google-analytics","content":"UA-68904127-2"},{"name":"og:site_name","content":"zexo.dev"},{"name":"og:type","content":"website"},{"name":"og:title","itemprop":"name","content":"管理你的 .ignore 类文件"},{"name":"og:description","itemprop":"description","content":"每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 .gitignore 文件，比较麻烦。我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?比方说，我常用的 IDE 是 IntelliJ IDEA，偶尔使用 VSCode 看看日志、进行简单的编辑文本工作;\n"},{"name":"og:image","itemprop":"image","content":"https:/zexo.dev/posts/2020/03/15/dot-ignore-management-for-npm-package/gitignore.png"},{"name":"og:type","content":"article"},{"name":"description","itemprop":"description","content":"每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 .gitignore 文件，比较麻烦。我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?比方说，我常用的 IDE 是 IntelliJ IDEA，偶尔使用 VSCode 看看日志、进行简单的编辑文本工作;\n"}],"data":{"title":"管理你的 .ignore 类文件","id":"dot-ignore-management-for-npm-package","created":"2020-03-15T00:00:00.000Z","updated":"2020-03-15T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"node","label":"Node","total":0,"link":"/tags/node"},{"id":"npm","label":"NPM","total":1,"link":"/tags/npm"},{"id":"git","label":"Git","total":2,"link":"/tags/git"}],"cover":"/posts/2020/03/15/dot-ignore-management-for-npm-package/gitignore.png","images":[],"toc":[{"label":"管理你的 `.ignore` 类文件","level":1,"id":"管理你的-ignore-类文件","position":0,"children":[],"pid":-1},{"label":"背景","level":2,"id":"背景","position":1,"children":[],"pid":0},{"label":"创建与维护 `.gitignore` 文件合理的做法","level":2,"id":"创建与维护-gitignore-文件合理的做法","position":2,"children":[],"pid":0},{"label":"`.gitignore` 文件的组合","level":3,"id":"gitignore-文件的组合","position":3,"children":[],"pid":2},{"label":"衍生的新问题: 如何管理 `.npmignore` 文件?","level":2,"id":"衍生的新问题-如何管理-npmignore-文件","position":4,"children":[],"pid":0},{"label":"搏击俱乐部的第一条规则","level":3,"id":"搏击俱乐部的第一条规则","position":5,"children":[],"pid":4},{"label":"package.json 的 `files` 字段","level":3,"id":"packagejson-的-files-字段","position":6,"children":[],"pid":4},{"label":"小结","level":2,"id":"小结","position":7,"children":[],"pid":0},{"label":"References","level":2,"id":"references","position":8,"children":[],"pid":0}],"summary":"每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 .gitignore 文件，比较麻烦。我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?比方说，我常用的 IDE 是 IntelliJ IDEA，偶尔使用 VSCode 看看日志、进行简单的编辑文本工作;\n","src":"\n# 管理你的 `.ignore` 类文件\n\n## 背景\n\n每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 `.gitignore` 文件，比较麻烦。\n\n我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?\n\n比方说，我常用的 IDE 是 `IntelliJ IDEA`，偶尔使用 `VSCode` 看看日志、进行简单的编辑文本工作;\n\n从项目开发语言上看，接触的主要语言可能是 `Node`/`Java`;\n\n再从包管理器、构建工具上看，相关语言生态中经常遇到的关键词则是 `NPM`/`Yarn`/`Maven`/`Gradle`/`SBT`(?)。\n\n如何寻找一个合理的 `.gitignore` 组合方式?\n\n> 这是一份奇怪的知识归纳，主要是为了舒缓个人在项目工程化方面纠结的一些细节。通过学习一个维护 `.ignore` 文件内容的方法论，并及时对自己的已有项目、按照新的、有意义的实践方法进行重构、改造，后面在面临一些方案选型时，可以增加自己对既有方案、观点的说服力。\n\n## 创建与维护 `.gitignore` 文件合理的做法\n\n对于 Git 的 `.gitignore`，其实 Github 的官方文档、和一些 Star 数比较多的 Github Repo 中，都已经提及部分的较佳实践。\n\n详情可以看后面 **References** 部分的链接。\n\n在学习了上面的文档之后，决定使用 `gitignore.io` 来协创建与维护 `.gitignore` 文件内容。\n\n### `.gitignore` 文件的组合\n\n> 其实观看 [gitignore.io 的教学视频](https://docs.gitignore.io/) 已经能清晰了解应该做什么，但这里还是重复的描述下流程。\n\n在了解了一部分 `.gitignore` 模板之后，对于 IDE/语言/语言生态 来讲，最终只需要拆分成两部分。\n\n语言相关的 `.gitignore` template 已经涵盖了 语言生态相关的部分。\n\n所以我们只需要从两方面关心我们改组合哪两种方向的 `.gitignore` template。\n\n如开发 NPM Package 类项目，我会使用 `Jetbrains` 家 IDE + `VSCode` + `NPM/Yarn` 相关的 `.gitignore` template。\n\n在 gitignore.io 上，则可以将其简化成下面三个组合:\n\n[https://www.gitignore.io/api/node,code,jetbrains+all](https://www.gitignore.io/api/node,code,jetbrains+all)\n\n`gitignore.io` 的 API 会根据你的查询条件进行排序、输出一个合并后的 `.gitignore` 内容，复制粘贴即可使用。\n\n## 衍生的新问题: 如何管理 `.npmignore` 文件?\n\n事实上，在 `.ignore` 的世界里，有很多其他类似的文件，有时候都需要考虑如何合理地编写与维护。\n\n如:\n\n- .dockerignore\n- .npmignore\n- .eslintignore\n- .prettierignore .....\n\n开始纠结这件事情后，我又开始寻找 `.npmignore` 的最佳实践。\n\n直到被 [For the love of god, dont't use .npmignore - Medium](https://medium.com/@jdxcode/for-the-love-of-god-dont-use-npmignore-f93c08909d8d) 这篇文章启发，重读了 NPM Package 的一些 Specification，又涨了新的姿势。\n\n### 搏击俱乐部的第一条规则\n\n> `.npmignore` 文件的最佳实践，便是没有 `.npmignore` 文件。\n\nNPM 相关的 `.npmignore` 文件，其实是控制在包发布时的文件忽略规则，相当于:\n\n```\n源代码 + 构建产物 - 忽略文件 = 最终发布时被打包的文件。\n```\n\n上面的形式其实是要对项目文件目录做一个减法。对于需要发布的产物，其实用加法的思想，心智负担会更少。\n\n有一行命令，可以帮助你预览，当执行 `npm publish` 时，发布的文件树:\n\n```shell script\nnpm pack && tar -xvzf *.tgz && rm -rf package *.tgz\n```\n\n他会输出类似以下内容:\n\n```shell script\n$ npm pack && tar -xvzf *.tgz && rm -rf package *.tgz\nnpm notice\nnpm notice 📦  nestx-amqp@1.0.6\nnpm notice === Tarball Contents ===\nnpm notice 1.1kB LICENSE\nnpm notice 199B  dist/amqp.constants.js\nnpm notice 1.9kB dist/amqp.module.js\nnpm notice 77B   dist/amqp.options.js\nnpm notice 1.3kB dist/amqp.providers.js\nnpm notice 288B  dist/index.js\nnpm notice 3.3kB package.json\nnpm notice 1.8kB CHANGELOG.md\nnpm notice 2.3kB README.md\nnpm notice 114B  dist/amqp.constants.d.ts\nnpm notice 313B  dist/amqp.module.d.ts\nnpm notice 487B  dist/amqp.options.d.ts\nnpm notice 549B  dist/amqp.providers.d.ts\nnpm notice 131B  dist/index.d.ts\nnpm notice === Tarball Details ===\nnpm notice name:          nestx-amqp\nnpm notice version:       1.0.6\nnpm notice filename:      nestx-amqp-1.0.6.tgz\nnpm notice package size:  5.0 kB\nnpm notice unpacked size: 13.9 kB\nnpm notice shasum:        198fb0b7768525133d21488b901367ea4d26bfc9\nnpm notice integrity:     sha512-szLqvt0ZUNW2z[...]MagAIZuZRrUWQ==\nnpm notice total files:   14\nnpm notice\nnestx-amqp-1.0.6.tgz\nx package/LICENSE\nx package/dist/amqp.constants.js\nx package/dist/amqp.module.js\nx package/dist/amqp.options.js\nx package/dist/amqp.providers.js\nx package/dist/index.js\nx package/package.json\nx package/CHANGELOG.md\nx package/README.md\nx package/dist/amqp.constants.d.ts\nx package/dist/amqp.module.d.ts\nx package/dist/amqp.options.d.ts\nx package/dist/amqp.providers.d.ts\nx package/dist/index.d.ts\n```\n\n有了这个命令之后，我们在更改/删除 `.npmignore` 时，就能方便地对比出变化\n\n### package.json 的 `files` 字段\n\n现在，我们删掉 `.npmignore` 文件，使用 [package.json 的 `files` 字段](https://docs.npmjs.com/files/package.json#files) 声明打包内容，做加法。\n\n`files` 字段的类型，是一个字符串数组，数组的每一行使用 unix path glob pattern，以 `package.json` 所在目录进行路径匹配。\n\n如上一部分的 `npm pack` 输出的内容，具体的 `files` 字段是:\n\n```json\n{\n  \"files\": [\"dist\"]\n}\n```\n\n表示了 `dist` 目录下所有的文件，都会被打包。\n\n奇奇怪怪的问题来了，那为什么在输出中有可能看到其他的文件呢? `package.json` 是否需要显式地声明在 `files` 字段中?\n\n这里还是要阅读下 `files` 及其背后的约定。\n\n`npm publish`，永远优先读取 `files` 匹配的文件，永不忽略，其次再从 `.npmignore` 中进行减法。\n\n下面这些文件，如果存在，将会默认地加入到 `npm publish` 所发布的内容里，不需要在 `files` 中再声明。 (NPM 默认约定)\n\n同时也包括 `package.json#main` 中声明的文件。\n\n```\npackage.json\nREADME\nCHANGES / CHANGELOG / HISTORY\nLICENSE / LICENCE\nNOTICE\nREADME, CHANGES, LICENSE & NOTICE can have any case and extension.\n```\n\n下面这些路径，将会默认地被忽略，永远不会被 `npm publish` 所发布。(NPM 默认约定)\n\n```\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json (use shrinkwrap instead)\n```\n\n了解到这部分奇奇怪怪的知识与约定后，我马上删除了所有 NPM Package 项目代码中的 `.npmignore`，使用 `files` 做简单的加法。\n\n## 小结\n\n- 创建/维护 `.gitignore` 可以使用 gitignore.io 的 API 组合生成内容\n- 开始停止使用 `.npmignore`，而是用 `package.json#files` 进行 NPM 库发布文件树管理\n\n## References\n\n- [A collection of `.gitignore` templates - Github](https://github.com/github/gitignore)\n- [For the love of god, dont't use .npmignore - Medium](https://medium.com/@jdxcode/for-the-love-of-god-dont-use-npmignore-f93c08909d8d)\n","html":"<h1 id=\"管理你的-ignore-类文件\">管理你的 <code>.ignore</code> 类文件</h1>\n<h2 id=\"背景\">背景</h2>\n<p>每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 <code>.gitignore</code> 文件，比较麻烦。</p>\n<p>我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?</p>\n<p>比方说，我常用的 IDE 是 <code>IntelliJ IDEA</code>，偶尔使用 <code>VSCode</code> 看看日志、进行简单的编辑文本工作;</p>\n<p>从项目开发语言上看，接触的主要语言可能是 <code>Node</code>/<code>Java</code>;</p>\n<p>再从包管理器、构建工具上看，相关语言生态中经常遇到的关键词则是 <code>NPM</code>/<code>Yarn</code>/<code>Maven</code>/<code>Gradle</code>/<code>SBT</code>(?)。</p>\n<p>如何寻找一个合理的 <code>.gitignore</code> 组合方式?</p>\n<blockquote>\n<p>这是一份奇怪的知识归纳，主要是为了舒缓个人在项目工程化方面纠结的一些细节。通过学习一个维护 <code>.ignore</code> 文件内容的方法论，并及时对自己的已有项目、按照新的、有意义的实践方法进行重构、改造，后面在面临一些方案选型时，可以增加自己对既有方案、观点的说服力。</p>\n</blockquote>\n<h2 id=\"创建与维护-gitignore-文件合理的做法\">创建与维护 <code>.gitignore</code> 文件合理的做法</h2>\n<p>对于 Git 的 <code>.gitignore</code>，其实 Github 的官方文档、和一些 Star 数比较多的 Github Repo 中，都已经提及部分的较佳实践。</p>\n<p>详情可以看后面 <strong>References</strong> 部分的链接。</p>\n<p>在学习了上面的文档之后，决定使用 <code>gitignore.io</code> 来协创建与维护 <code>.gitignore</code> 文件内容。</p>\n<h3 id=\"gitignore-文件的组合\"><code>.gitignore</code> 文件的组合</h3>\n<blockquote>\n<p>其实观看 <a href=\"https://docs.gitignore.io/\">gitignore.io 的教学视频</a> 已经能清晰了解应该做什么，但这里还是重复的描述下流程。</p>\n</blockquote>\n<p>在了解了一部分 <code>.gitignore</code> 模板之后，对于 IDE/语言/语言生态 来讲，最终只需要拆分成两部分。</p>\n<p>语言相关的 <code>.gitignore</code> template 已经涵盖了 语言生态相关的部分。</p>\n<p>所以我们只需要从两方面关心我们改组合哪两种方向的 <code>.gitignore</code> template。</p>\n<p>如开发 NPM Package 类项目，我会使用 <code>Jetbrains</code> 家 IDE + <code>VSCode</code> + <code>NPM/Yarn</code> 相关的 <code>.gitignore</code> template。</p>\n<p>在 gitignore.io 上，则可以将其简化成下面三个组合:</p>\n<p><a href=\"https://www.gitignore.io/api/node,code,jetbrains+all\">https://www.gitignore.io/api/node,code,jetbrains+all</a></p>\n<p><code>gitignore.io</code> 的 API 会根据你的查询条件进行排序、输出一个合并后的 <code>.gitignore</code> 内容，复制粘贴即可使用。</p>\n<h2 id=\"衍生的新问题-如何管理-npmignore-文件\">衍生的新问题: 如何管理 <code>.npmignore</code> 文件?</h2>\n<p>事实上，在 <code>.ignore</code> 的世界里，有很多其他类似的文件，有时候都需要考虑如何合理地编写与维护。</p>\n<p>如:</p>\n<ul>\n<li>.dockerignore</li>\n<li>.npmignore</li>\n<li>.eslintignore</li>\n<li>.prettierignore .....</li>\n</ul>\n<p>开始纠结这件事情后，我又开始寻找 <code>.npmignore</code> 的最佳实践。</p>\n<p>直到被 <a href=\"https://medium.com/@jdxcode/for-the-love-of-god-dont-use-npmignore-f93c08909d8d\">For the love of god, dont't use .npmignore - Medium</a> 这篇文章启发，重读了 NPM Package 的一些 Specification，又涨了新的姿势。</p>\n<h3 id=\"搏击俱乐部的第一条规则\">搏击俱乐部的第一条规则</h3>\n<blockquote>\n<p><code>.npmignore</code> 文件的最佳实践，便是没有 <code>.npmignore</code> 文件。</p>\n</blockquote>\n<p>NPM 相关的 <code>.npmignore</code> 文件，其实是控制在包发布时的文件忽略规则，相当于:</p>\n<pre class=\"hljs\"><code>源代码 + 构建产物 - 忽略文件 = 最终发布时被打包的文件。\n</code></pre>\n<p>上面的形式其实是要对项目文件目录做一个减法。对于需要发布的产物，其实用加法的思想，心智负担会更少。</p>\n<p>有一行命令，可以帮助你预览，当执行 <code>npm publish</code> 时，发布的文件树:</p>\n<pre class=\"hljs\"><code>npm pack &amp;&amp; tar -xvzf *.tgz &amp;&amp; rm -rf package *.tgz\n</code></pre>\n<p>他会输出类似以下内容:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> npm pack &amp;&amp; tar -xvzf *.tgz &amp;&amp; rm -rf package *.tgz</span>\nnpm notice\nnpm notice 📦  nestx-amqp@1.0.6\nnpm notice === Tarball Contents ===\nnpm notice 1.1kB LICENSE\nnpm notice 199B  dist/amqp.constants.js\nnpm notice 1.9kB dist/amqp.module.js\nnpm notice 77B   dist/amqp.options.js\nnpm notice 1.3kB dist/amqp.providers.js\nnpm notice 288B  dist/index.js\nnpm notice 3.3kB package.json\nnpm notice 1.8kB CHANGELOG.md\nnpm notice 2.3kB README.md\nnpm notice 114B  dist/amqp.constants.d.ts\nnpm notice 313B  dist/amqp.module.d.ts\nnpm notice 487B  dist/amqp.options.d.ts\nnpm notice 549B  dist/amqp.providers.d.ts\nnpm notice 131B  dist/index.d.ts\nnpm notice === Tarball Details ===\nnpm notice name:          nestx-amqp\nnpm notice version:       1.0.6\nnpm notice filename:      nestx-amqp-1.0.6.tgz\nnpm notice package size:  5.0 kB\nnpm notice unpacked size: 13.9 kB\nnpm notice shasum:        198fb0b7768525133d21488b901367ea4d26bfc9\nnpm notice integrity:     sha512-szLqvt0ZUNW2z[...]MagAIZuZRrUWQ==\nnpm notice total files:   14\nnpm notice\nnestx-amqp-1.0.6.tgz\nx package/LICENSE\nx package/dist/amqp.constants.js\nx package/dist/amqp.module.js\nx package/dist/amqp.options.js\nx package/dist/amqp.providers.js\nx package/dist/index.js\nx package/package.json\nx package/CHANGELOG.md\nx package/README.md\nx package/dist/amqp.constants.d.ts\nx package/dist/amqp.module.d.ts\nx package/dist/amqp.options.d.ts\nx package/dist/amqp.providers.d.ts\nx package/dist/index.d.ts\n</code></pre>\n<p>有了这个命令之后，我们在更改/删除 <code>.npmignore</code> 时，就能方便地对比出变化</p>\n<h3 id=\"packagejson-的-files-字段\">package.json 的 <code>files</code> 字段</h3>\n<p>现在，我们删掉 <code>.npmignore</code> 文件，使用 <a href=\"https://docs.npmjs.com/files/package.json#files\">package.json 的 <code>files</code> 字段</a> 声明打包内容，做加法。</p>\n<p><code>files</code> 字段的类型，是一个字符串数组，数组的每一行使用 unix path glob pattern，以 <code>package.json</code> 所在目录进行路径匹配。</p>\n<p>如上一部分的 <code>npm pack</code> 输出的内容，具体的 <code>files</code> 字段是:</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">&quot;files&quot;</span>: [<span class=\"hljs-string\">&quot;dist&quot;</span>]\n}\n</code></pre>\n<p>表示了 <code>dist</code> 目录下所有的文件，都会被打包。</p>\n<p>奇奇怪怪的问题来了，那为什么在输出中有可能看到其他的文件呢? <code>package.json</code> 是否需要显式地声明在 <code>files</code> 字段中?</p>\n<p>这里还是要阅读下 <code>files</code> 及其背后的约定。</p>\n<p><code>npm publish</code>，永远优先读取 <code>files</code> 匹配的文件，永不忽略，其次再从 <code>.npmignore</code> 中进行减法。</p>\n<p>下面这些文件，如果存在，将会默认地加入到 <code>npm publish</code> 所发布的内容里，不需要在 <code>files</code> 中再声明。 (NPM 默认约定)</p>\n<p>同时也包括 <code>package.json#main</code> 中声明的文件。</p>\n<pre class=\"hljs\"><code>package.json\nREADME\nCHANGES / CHANGELOG / HISTORY\nLICENSE / LICENCE\nNOTICE\nREADME, CHANGES, LICENSE &amp; NOTICE can have any case and extension.\n</code></pre>\n<p>下面这些路径，将会默认地被忽略，永远不会被 <code>npm publish</code> 所发布。(NPM 默认约定)</p>\n<pre class=\"hljs\"><code>.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json (use shrinkwrap instead)\n</code></pre>\n<p>了解到这部分奇奇怪怪的知识与约定后，我马上删除了所有 NPM Package 项目代码中的 <code>.npmignore</code>，使用 <code>files</code> 做简单的加法。</p>\n<h2 id=\"小结\">小结</h2>\n<ul>\n<li>创建/维护 <code>.gitignore</code> 可以使用 gitignore.io 的 API 组合生成内容</li>\n<li>开始停止使用 <code>.npmignore</code>，而是用 <code>package.json#files</code> 进行 NPM 库发布文件树管理</li>\n</ul>\n<h2 id=\"references\">References</h2>\n<ul>\n<li><a href=\"https://github.com/github/gitignore\">A collection of <code>.gitignore</code> templates - Github</a></li>\n<li><a href=\"https://medium.com/@jdxcode/for-the-love-of-god-dont-use-npmignore-f93c08909d8d\">For the love of god, dont't use .npmignore - Medium</a></li>\n</ul>\n","disqus":{"shortname":"aquariuslt","url":"https://zexo.dev/posts/2020/03/15/dot-ignore-management-for-npm-package","identifier":"-posts-2020-03-15-dot-ignore-management-for-npm-package"}}}