{"key":"angular-ui-performance-tuning-experience","url":"https://blog.aquariuslt.com/posts/2016/04/30/angular-ui-performance-tuning-experience","path":"/posts/2016/04/30/angular-ui-performance-tuning-experience","title":"Angular.js常规性能优化阶段总结 | TL; DR","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.aquariuslt.com","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts/2016/04/30/angular-ui-performance-tuning-experience","name":"Angular.js常规性能优化阶段总结","position":3}]},"type":"DETAIL","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"name":"google-analytics","content":"UA-68904127-1"},{"name":"og:site_name","content":"TL; DR"},{"name":"og:type","content":"website"},{"name":"og:title","content":"Angular.js常规性能优化阶段总结"},{"name":"og:description","content":"最近在为项目进行性能优化的时候,有总结到一些经验.\n现在梳理一遍,方便以后排查问题.在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.\n其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.\n"},{"name":"og:image","content":"./cover.png"},{"name":"og:type","content":"article"}],"data":{"title":"Angular.js常规性能优化阶段总结","id":"angular-ui-performance-tuning-experience","created":"2016-04-30T00:00:00.000Z","updated":"2016-04-30T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"angular","label":"Angular","total":0,"link":"/tags/angular"},{"id":"javascript","label":"JavaScript","total":1,"link":"/tags/javascript"}],"cover":"/posts/2016/04/30/angular-ui-performance-tuning-experience/cover.png","images":["./performance.png","./notification.png"],"toc":[{"label":"Angular.js 常规性能优化阶段总结","level":1,"id":"angularjs-常规性能优化阶段总结","position":0,"children":[{"label":"Background","level":2,"id":"background","position":1,"children":[],"pid":0},{"label":"References","level":2,"id":"references","position":2,"children":[],"pid":0},{"label":"Solutions","level":2,"id":"solutions","position":3,"children":[{"label":"Plugins:AngularJS Batarang","level":3,"id":"pluginsangularjs-batarang","position":4,"children":[],"pid":3},{"label":"Once Binding","level":3,"id":"once-binding","position":5,"children":[],"pid":3},{"label":"Use variable instead function expression","level":3,"id":"use-variable-instead-function-expression","position":6,"children":[],"pid":3},{"label":"Chain Filter","level":3,"id":"chain-filter","position":7,"children":[],"pid":3},{"label":"Using ng-model-option delay update","level":3,"id":"using-ng-model-option-delay-update","position":8,"children":[],"pid":3}],"pid":0},{"label":"Summary","level":2,"id":"summary","position":9,"children":[],"pid":0}],"pid":-1}],"summary":"最近在为项目进行性能优化的时候,有总结到一些经验.\n现在梳理一遍,方便以后排查问题.在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.\n其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.\n","src":"\n# Angular.js 常规性能优化阶段总结\n\n## Background\n\n最近在为项目进行性能优化的时候,有总结到一些经验.  \n现在梳理一遍,方便以后排查问题.\n\n## References\n\n在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.  \n其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.\n\n下面是一些推荐阅读的博客,给我提供了很多帮助,加深了对 Angular 的认识.\n\n- [xufei blog](https://github.com/xufei/blog/) ...准备贴下一个地址的时候,居然发现这个知乎的地址居然也是 xufei 大大的回答. 恩.应该提供最有价值帮助的就是他了.\n\n## Solutions\n\n### Plugins:AngularJS Batarang\n\n利用 Angular 官方开发的 Chrome 插件`AngularJS Batarang`来监控页面性能.  \n[Angular Batarang](https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk)  \n![运行截图](./performance.png)\n\n通过`Angular Batarang`,我们可以轻易的统计在页面的`watcher`数量,`$scope`中变量的数量. 还有平均一段时间内`angular`执行`$digest`的数量.\n\n对于代码不熟悉的项目前端,查找分析性能瓶颈的时候,可以通过通过该插件进行二分对于,快速定位出瓶颈处. 当然,如果在对 angular 比较熟悉,在开发的过程中也遵循了常见的性能优化约定,该插件的监控作用就不大. 最后还是只能通过其他手段细化性能瓶颈定位粒度.\n\n经过本人测试,对于大部分使用 Angular 的页面都支持良好.(可惜不支持 CommonJS 打包成的我的主站的分析)\n\n### Once Binding\n\n在常见的 CRUD 系统中,我们经常会遇到很多数据展示的区域,但是这些数据一旦渲染好,一般不需要强刷新. 比如页面标题,菜单选项等不需要实时更新的情况.所以这时候可以通过`Once Binding`,即一次绑定,渲染一次即可,不必监控该表达式.\n\n之前遇到的情况是,我们的页面 header 会有一个通知栏,展开会通知那些已经显示的列表.  \n单条通知样子类似于微博的这种:  \n![通知栏](./notification.png) 在没优化之前,通知部分的伪代码如下:\n\n```html\n<div class=\"notification\">\n  <ul>\n    <li ng-repeat=\"notification in vm.displayNotifications\">\n      <div href=\"{{notification.targetUrl}}\">\n        <p>{{notifications.title}}</p>\n        <p>{{notifications.summary}}</p>\n        <p>{{notifications.time}}</p>\n      </div>\n    </li>\n  </ul>\n</div>\n```\n\n经过一轮生产环境数据统计,某部分用户的未读通知范围会在 200 - 7W 条.  \n哈哈看到就尿了,如果这么算的话,7W 条的那个用户页面将会有至少 7W\\*4 = 28W 的 watcher 在监听他们的变化.  \n且不论数据为什么需要全部渲染出来,如果将代码修改成 Once Binding,则页面的长期 watcher 数量将会减少 28W 个.\n\n特别是对于使用了`ng-repeat`的元素,一定要考虑将\n\n使用一次绑定表达式之后如下\n\n```html\n<div class=\"notification\">\n  <ul>\n    <li ng-repeat=\"notification in vm.displayNotifications\">\n      <div href=\"{{::notification.targetUrl}}\">\n        <p>{{::notifications.title}}</p>\n        <p>{{::notifications.summary}}</p>\n        <p>{{::notifications.time}}</p>\n      </div>\n    </li>\n  </ul>\n</div>\n```\n\n### Use variable instead function expression\n\n之前遇到一个需求,在业务逻辑上需要显示一个模型,这个模型大概是下面这样的:\n\n```json\n{\n  \"businessKeys\": [\n    {\n      \"type\": \"a\",\n      \"value\": \"aValue\"\n    },\n    {\n      \"type\": \"b\",\n      \"value\": \"bValue\"\n    },\n    {\n      \"type\": \"c\",\n      \"value\": \"cValue\"\n    },\n    {\n      \"type\": \"c\",\n      \"value\": \"cValue\"\n    }\n  ],\n  \"otherInfo\": \"otherInfo...\"\n}\n```\n\n在字段里面是有一个不定长的数组,数组里面实际上是一堆 key-value 形式的键值对. 之所以不定长是因为里面有时候有些 key 是没有对应的值的. 在 UI 上显示出来的时候,先前的做法就是绑定一个方法:\n\n```\n{{vm.getValueByBusinessKeysType(object,keyName)}}\n```\n\n在页面上使用一个方法表达式而不是直接的变量表达式的时候,会导致方法执行多次. 由于这个`getValueByBusinessKeysType`的方法,需要通过数组查找而不是直接一个 map 所以就会导致性能问题.\n\n目前的解决方案是:将数据在加载的时候经过扁平化处理,即将 key 直接以 property 的形式直接赋予 Object. 通过直接绑定 property 表达式来显示. 这样也有效提高了一些性能\n\n### Chain Filter\n\nAngular 的 Filter 性能一直不够好. 在刚刚接触 Angular 的时候,阅读文档发现 Filter 的功能还挺好用的,特别是做一些关键字过滤表格数据,格式处理等方面的工作,  \n实在是太方便了,于是我们在为我们的 table 的 header 上每个 column 都添加了一个关键字过滤框,使用 angular 的 filter 做分页的工作.\n\n由于我们的表格需要显示的业务数据比较多,column 数大概在 15-25 左右. 在每一个 header 的 column 上添加独立的关键字过滤框,大概就添加了 20 个.\n\n假设当前页面的总数据 会有有 30 条. 用户喜欢在几个过滤框上输入一些相关的关键字信息过滤.(filterA,filterB)\n\n```js\nfunction filterA(dataArray, filterCriteria) {\n  return filteredDataArrayByFilterCriteriaA;\n}\n\nfunction filterB(dataArray, filterCriteria) {\n  return filteredDataArrayByFilterCriteriaB;\n}\n```\n\n当每一个过滤框都属于一个单独的 filter 去绑定的话,如果执行 AB filter,将会按照下面的顺序执行\n\n> `dataArray` length:30 `filteredDataArrayByFilterCriteriaA` (至少两次 filterA,此时 length 约 20)  \n> `filteredDataArrayByFilterCriteriaB` (至少两次 filterB,此时 length 约 5)\n\n如果我们在计算关键字过滤的时候使用的是遍历查询,以单次对单个元素对比的操作工作量为 1.  \n那么在这两重 filter 的总计算工作量就会变成`30*2+20*2=100`次\n\n回到实际业务,通过在 filter 中添加 log 来记录 filter 循环运算的次数,惊讶的发现实际上 filter 的运算次数在 25 个 column 的情况下,  \n普遍一次过滤框的查询,会导致 3K 左右的运算次数,相当惊人.\n\n目前的解决方案是通过降低工程代码的可读性,将多个 filter 的功能合并成一个总的 filter,在总的 filter 里面处理一连串的单个 filter 过滤过程.\n\n之前的代码可能是这样:\n\n```html\n<tr ng-repeat=\"singleData in vm.dataArray | filterA | filterB | filterC ..... | filterZ\"></tr>\n```\n\n```js\nfunction filterA(dataArray) {\n  //implement filterA\n}\n\nfunction filterB(dataArray) {\n  //implement filterB\n}\n\nfunction filterC(dataArray) {\n  //implement filterC\n}\n```\n\n合并之后看起来是这样\n\n```html\n<tr ng-repeat=\"singleData in vm.dataArray | combinedFilter\"\n```\n\n```js\nfunction combinedFilter(dataArrat) {\n  //implement filterA\n  //implement filterB\n  //implement filterC\n}\n```\n\n### Using ng-model-option delay update\n\n因为使用了 angular 的 filter 功能做前端的关键词过滤,实际上所有的查询工作都是同步的. 因为是同步,所以在前端 javascript 进行相对较密集的查询运算的时候,卡顿就会相当明显. 如果对过滤输入框进行了`ng-model`的绑定,则当输入框的内容进行改变的时候,会立刻出发 filter 运算. 通常用户输入的时候大部分可能是连续的单词或者子字符串的输入,在一次主观上的输入还没有结束的时候,因为输入框中文字的改变,  \n而频繁触发查询,实际上页面性能也会相当不好. 这里有一个小 tips 就是为一些实时查询性不是很高的输入区域添加 ng-model-options,增加 angular 检查数据 update 的时间间隔, 相当于可以等用户把想要的搜索关键词输入完毕之后,再执行 js 代码的查询工作.\n\n## Summary\n\n本次结合了一些实际工作中使用 angular 遇到的性能问题的解决方案,当然也有遇到一些与原生 js,socket.io 相关的性能问题. 由于 tag 不同,不混淆在一起说了.\n","html":"<h1 id=\"angularjs-常规性能优化阶段总结\">Angular.js 常规性能优化阶段总结</h1>\n<h2 id=\"background\">Background</h2>\n<p>最近在为项目进行性能优化的时候,有总结到一些经验.<br>\n现在梳理一遍,方便以后排查问题.</p>\n<h2 id=\"references\">References</h2>\n<p>在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.<br>\n其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.</p>\n<p>下面是一些推荐阅读的博客,给我提供了很多帮助,加深了对 Angular 的认识.</p>\n<ul>\n<li><a href=\"https://github.com/xufei/blog/\">xufei blog</a> ...准备贴下一个地址的时候,居然发现这个知乎的地址居然也是 xufei 大大的回答. 恩.应该提供最有价值帮助的就是他了.</li>\n</ul>\n<h2 id=\"solutions\">Solutions</h2>\n<h3 id=\"pluginsangularjs-batarang\">Plugins:AngularJS Batarang</h3>\n<p>利用 Angular 官方开发的 Chrome 插件<code>AngularJS Batarang</code>来监控页面性能.<br>\n<a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\">Angular Batarang</a><br>\n<img src=\"/posts/2016/04/30/angular-ui-performance-tuning-experience/performance.png\" alt=\"运行截图\"></p>\n<p>通过<code>Angular Batarang</code>,我们可以轻易的统计在页面的<code>watcher</code>数量,<code>$scope</code>中变量的数量. 还有平均一段时间内<code>angular</code>执行<code>$digest</code>的数量.</p>\n<p>对于代码不熟悉的项目前端,查找分析性能瓶颈的时候,可以通过通过该插件进行二分对于,快速定位出瓶颈处. 当然,如果在对 angular 比较熟悉,在开发的过程中也遵循了常见的性能优化约定,该插件的监控作用就不大. 最后还是只能通过其他手段细化性能瓶颈定位粒度.</p>\n<p>经过本人测试,对于大部分使用 Angular 的页面都支持良好.(可惜不支持 CommonJS 打包成的我的主站的分析)</p>\n<h3 id=\"once-binding\">Once Binding</h3>\n<p>在常见的 CRUD 系统中,我们经常会遇到很多数据展示的区域,但是这些数据一旦渲染好,一般不需要强刷新. 比如页面标题,菜单选项等不需要实时更新的情况.所以这时候可以通过<code>Once Binding</code>,即一次绑定,渲染一次即可,不必监控该表达式.</p>\n<p>之前遇到的情况是,我们的页面 header 会有一个通知栏,展开会通知那些已经显示的列表.<br>\n单条通知样子类似于微博的这种:<br>\n<img src=\"/posts/2016/04/30/angular-ui-performance-tuning-experience/notification.png\" alt=\"通知栏\"> 在没优化之前,通知部分的伪代码如下:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"notification\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">ng-repeat</span>=<span class=\"hljs-string\">\"notification in vm.displayNotifications\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"{{notification.targetUrl}}\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{notifications.title}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{notifications.summary}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{notifications.time}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>经过一轮生产环境数据统计,某部分用户的未读通知范围会在 200 - 7W 条.<br>\n哈哈看到就尿了,如果这么算的话,7W 条的那个用户页面将会有至少 7W*4 = 28W 的 watcher 在监听他们的变化.<br>\n且不论数据为什么需要全部渲染出来,如果将代码修改成 Once Binding,则页面的长期 watcher 数量将会减少 28W 个.</p>\n<p>特别是对于使用了<code>ng-repeat</code>的元素,一定要考虑将</p>\n<p>使用一次绑定表达式之后如下</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"notification\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">ng-repeat</span>=<span class=\"hljs-string\">\"notification in vm.displayNotifications\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"{{::notification.targetUrl}}\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{::notifications.title}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{::notifications.summary}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{::notifications.time}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<h3 id=\"use-variable-instead-function-expression\">Use variable instead function expression</h3>\n<p>之前遇到一个需求,在业务逻辑上需要显示一个模型,这个模型大概是下面这样的:</p>\n<pre><code class=\"hljs json\">{\n  <span class=\"hljs-attr\">\"businessKeys\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"a\"</span>,\n      <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"aValue\"</span>\n    },\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"b\"</span>,\n      <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"bValue\"</span>\n    },\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"c\"</span>,\n      <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"cValue\"</span>\n    },\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"c\"</span>,\n      <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"cValue\"</span>\n    }\n  ],\n  <span class=\"hljs-attr\">\"otherInfo\"</span>: <span class=\"hljs-string\">\"otherInfo...\"</span>\n}\n</code></pre>\n<p>在字段里面是有一个不定长的数组,数组里面实际上是一堆 key-value 形式的键值对. 之所以不定长是因为里面有时候有些 key 是没有对应的值的. 在 UI 上显示出来的时候,先前的做法就是绑定一个方法:</p>\n<pre><code>{{vm.getValueByBusinessKeysType(object,keyName)}}\n</code></pre>\n<p>在页面上使用一个方法表达式而不是直接的变量表达式的时候,会导致方法执行多次. 由于这个<code>getValueByBusinessKeysType</code>的方法,需要通过数组查找而不是直接一个 map 所以就会导致性能问题.</p>\n<p>目前的解决方案是:将数据在加载的时候经过扁平化处理,即将 key 直接以 property 的形式直接赋予 Object. 通过直接绑定 property 表达式来显示. 这样也有效提高了一些性能</p>\n<h3 id=\"chain-filter\">Chain Filter</h3>\n<p>Angular 的 Filter 性能一直不够好. 在刚刚接触 Angular 的时候,阅读文档发现 Filter 的功能还挺好用的,特别是做一些关键字过滤表格数据,格式处理等方面的工作,<br>\n实在是太方便了,于是我们在为我们的 table 的 header 上每个 column 都添加了一个关键字过滤框,使用 angular 的 filter 做分页的工作.</p>\n<p>由于我们的表格需要显示的业务数据比较多,column 数大概在 15-25 左右. 在每一个 header 的 column 上添加独立的关键字过滤框,大概就添加了 20 个.</p>\n<p>假设当前页面的总数据 会有有 30 条. 用户喜欢在几个过滤框上输入一些相关的关键字信息过滤.(filterA,filterB)</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterA</span>(<span class=\"hljs-params\">dataArray, filterCriteria</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> filteredDataArrayByFilterCriteriaA;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterB</span>(<span class=\"hljs-params\">dataArray, filterCriteria</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> filteredDataArrayByFilterCriteriaB;\n}\n</code></pre>\n<p>当每一个过滤框都属于一个单独的 filter 去绑定的话,如果执行 AB filter,将会按照下面的顺序执行</p>\n<blockquote>\n<p><code>dataArray</code> length:30 <code>filteredDataArrayByFilterCriteriaA</code> (至少两次 filterA,此时 length 约 20)<br>\n<code>filteredDataArrayByFilterCriteriaB</code> (至少两次 filterB,此时 length 约 5)</p>\n</blockquote>\n<p>如果我们在计算关键字过滤的时候使用的是遍历查询,以单次对单个元素对比的操作工作量为 1.<br>\n那么在这两重 filter 的总计算工作量就会变成<code>30*2+20*2=100</code>次</p>\n<p>回到实际业务,通过在 filter 中添加 log 来记录 filter 循环运算的次数,惊讶的发现实际上 filter 的运算次数在 25 个 column 的情况下,<br>\n普遍一次过滤框的查询,会导致 3K 左右的运算次数,相当惊人.</p>\n<p>目前的解决方案是通过降低工程代码的可读性,将多个 filter 的功能合并成一个总的 filter,在总的 filter 里面处理一连串的单个 filter 过滤过程.</p>\n<p>之前的代码可能是这样:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">ng-repeat</span>=<span class=\"hljs-string\">\"singleData in vm.dataArray | filterA | filterB | filterC ..... | filterZ\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterA</span>(<span class=\"hljs-params\">dataArray</span>) </span>{\n  <span class=\"hljs-comment\">//implement filterA</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterB</span>(<span class=\"hljs-params\">dataArray</span>) </span>{\n  <span class=\"hljs-comment\">//implement filterB</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterC</span>(<span class=\"hljs-params\">dataArray</span>) </span>{\n  <span class=\"hljs-comment\">//implement filterC</span>\n}\n</code></pre>\n<p>合并之后看起来是这样</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">ng-repeat</span>=<span class=\"hljs-string\">\"singleData in vm.dataArray | combinedFilter\"</span>\n</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">combinedFilter</span>(<span class=\"hljs-params\">dataArrat</span>) </span>{\n  <span class=\"hljs-comment\">//implement filterA</span>\n  <span class=\"hljs-comment\">//implement filterB</span>\n  <span class=\"hljs-comment\">//implement filterC</span>\n}\n</code></pre>\n<h3 id=\"using-ng-model-option-delay-update\">Using ng-model-option delay update</h3>\n<p>因为使用了 angular 的 filter 功能做前端的关键词过滤,实际上所有的查询工作都是同步的. 因为是同步,所以在前端 javascript 进行相对较密集的查询运算的时候,卡顿就会相当明显. 如果对过滤输入框进行了<code>ng-model</code>的绑定,则当输入框的内容进行改变的时候,会立刻出发 filter 运算. 通常用户输入的时候大部分可能是连续的单词或者子字符串的输入,在一次主观上的输入还没有结束的时候,因为输入框中文字的改变,<br>\n而频繁触发查询,实际上页面性能也会相当不好. 这里有一个小 tips 就是为一些实时查询性不是很高的输入区域添加 ng-model-options,增加 angular 检查数据 update 的时间间隔, 相当于可以等用户把想要的搜索关键词输入完毕之后,再执行 js 代码的查询工作.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>本次结合了一些实际工作中使用 angular 遇到的性能问题的解决方案,当然也有遇到一些与原生 js,socket.io 相关的性能问题. 由于 tag 不同,不混淆在一起说了.</p>\n","disqus":{"shortname":"aquariuslt","url":"https://blog.aquariuslt.com/posts/2016/04/30/angular-ui-performance-tuning-experience","identifier":"-posts-2016-04-30-angular-ui-performance-tuning-experience"}}}