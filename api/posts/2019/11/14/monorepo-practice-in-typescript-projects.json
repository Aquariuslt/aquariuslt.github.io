{"key":"monorepo-practice-in-typescript-projects","url":"https://blog.aquariuslt.com/posts/2019/11/14/monorepo-practice-in-typescript-projects","path":"/posts/2019/11/14/monorepo-practice-in-typescript-projects","title":"Monorepo Practice in TypeScript Projects | TL; DR","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.aquariuslt.com","name":"Home","position":1},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts/2019/11/14/monorepo-practice-in-typescript-projects","name":"Monorepo Practice in TypeScript Projects","position":3}]},"type":"DETAIL","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"id":"google-analytics","name":"google-analytics","content":"UA-68904127-1"},{"name":"og:site_name","content":"TL; DR"},{"name":"og:type","content":"website"},{"name":"og:title","content":"Monorepo Practice in TypeScript Projects"},{"name":"og:description","content":"随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考之湖上的这篇文章: https://zhuanlan.zhihu.com/p/31289463\n"},{"name":"og:image","content":"./cover.png"},{"name":"og:type","content":"article"},{"name":"description","content":"随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考之湖上的这篇文章: https://zhuanlan.zhihu.com/p/31289463\n"}],"data":{"title":"Monorepo Practice in TypeScript Projects","id":"monorepo-practice-in-typescript-projects","created":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"npm","label":"NPM","total":0,"link":"/tags/npm"},{"id":"ci","label":"CI","total":1,"link":"/tags/ci"},{"id":"typescript","label":"Typescript","total":2,"link":"/tags/typescript"},{"id":"monorepo","label":"Monorepo","total":3,"link":"/tags/monorepo"},{"id":"lerna","label":"Lerna","total":4,"link":"/tags/lerna"},{"id":"jest","label":"Jest","total":5,"link":"/tags/jest"}],"cover":"/posts/2019/11/14/monorepo-practice-in-typescript-projects/cover.png","images":[],"toc":[{"label":"Monorepo Practice in TypeScript Projects","level":1,"id":"monorepo-practice-in-typescript-projects","position":0,"children":[{"label":"Background","level":2,"id":"background","position":1,"children":[{"label":"Problems","level":3,"id":"problems","position":2,"children":[],"pid":1},{"label":"Unit Testing","level":3,"id":"unit-testing","position":3,"children":[],"pid":1},{"label":"With Path Alias","level":3,"id":"with-path-alias","position":4,"children":[],"pid":1}],"pid":0},{"label":"Example Project","level":2,"id":"example-project","position":5,"children":[{"label":"Example Project Introduction","level":3,"id":"example-project-introduction","position":6,"children":[],"pid":5},{"label":"Example Project Folder Structure","level":3,"id":"example-project-folder-structure","position":7,"children":[],"pid":5}],"pid":0},{"label":"Solutions","level":2,"id":"solutions","position":8,"children":[{"label":"UnitTesting cross Monorepo","level":3,"id":"unittesting-cross-monorepo","position":9,"children":[],"pid":8},{"label":"Path Alias","level":3,"id":"path-alias","position":10,"children":[],"pid":8},{"label":"Summarization","level":3,"id":"summarization","position":11,"children":[],"pid":8},{"label":"More Complex Situation","level":3,"id":"more-complex-situation","position":12,"children":[],"pid":8}],"pid":0},{"label":"References","level":2,"id":"references","position":13,"children":[],"pid":0}],"pid":-1}],"summary":"随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考之湖上的这篇文章: https://zhuanlan.zhihu.com/p/31289463\n","src":"\n# Monorepo Practice in TypeScript Projects\n\n## Background\n\n随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。\n\n我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。\n\n> Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考之湖上的这篇文章: [https://zhuanlan.zhihu.com/p/31289463](https://zhuanlan.zhihu.com/p/31289463)\n\n由于在其他(这里值一些较较成熟的语言，如 Java)语言的包管理生态圈里已有很多成熟的解决方案，如 Java 世界里的 Maven/Gradle , 其中都有很多较佳时间在各种成熟的开源项目中有所体现。\n\n由于 Node 官方的 NPM Package Registry 并没有提供一个官方的解决方案，所以目前会有很多的实现方案，比如 `Lerna` , `Yarn Workspace` , 更甚者还有一些脚本替换发布方案。\n\n近期我在好几个 Node with TypeScript 项目(不管是工作中的项目抑或是自己的项目)中，都尝试开始使用 MonoRepo 的形式去组织代码结构与 CICD 流程。这里分享下对 Nodejs + TypeScript 的一些实践经验。\n\n### Problems\n\n要使用 Multi-Repo 还是 Monorepo，又或者是如何从 Multi-Repo 迁移、进化成 Monorepo，不同项目都面对着不同的问题。\n\n我抽取了我在这些 Node 项目在修改成 Monorepo 的过程中面对的一些问题，并在下文中给出目前我觉得较为合理的一些解决方案。\n\n### Unit Testing\n\n常规的 Multi-Repo 的单元测试流程理解起来会比较简单。以常见的 `jest` 来看，为单个 Repo 设立单元测试、为单个 Repo 关联代码覆盖率相关的 CI 配置/平台，都相当简单。\n\n当执行 Jest 进行单元测试的时候，我们只用维护一份 Jest 配置。接着一切便按照 Jest 的配置正常运作:\n\n- 代码覆盖率相关的 CI 读取 Jest 配置中执行的 `coverageDirectory` 下相关的覆盖率报告文件\n- 需要在 Jest 执行的各种生命周期的 Hooks 都能通过配置一目了然\n\n当我们把这些 Multi-Repo 集中到一起的时候，问题便显现出来：\n\n- 运行测试是逐个 sub-packages 单独执行测试吗? 如 `lerna run test`\n- 单元测试的配置应该如何维护? 维护在 Monorepo 的根目录还是单独拆分维护在每个 sub-package 下?\n- 如何像 Multi-Repo 那样与测试覆盖率的 CI 集合起来?\n\n### With Path Alias\n\n现代化的 Node 项目(不管是 Node 还是前端项目)，很多时候都有一些 Path-Alias 的技巧。\n\n具体表现是什么呢? 比如利用 `webpack` 的 `path.resolve` 配置或者 `tsconfig` 中 `paths` 的配置，做一些路径的简化，以节省各种相对路径 `../..` 的使用。\n\n如 `@/main.ts` 实际指向了以项目根目录开始的 `<rootDir>/src/main.ts`\n\n但是，在 Monorepo 下，我们在想方便的以 `@` 作为 Path Alias，则会遇到很多思考上的问题。\n\n在单个 sub-package 内 理解并执行 Path-Alias 会跟原先的方式没什么区别。但是需要 root package\n\n也理解 sub-package 的 Path-Alias 配置则需要很多思考：\n\n- 多个使用 相同 Path-Alias 的 sub-packages 之间应该如何解析? 大家都在使用相同的 `@` 作为引用路径别名的情况下，怎么知道此时的 `@` 是对应哪一个正确的绝对路径呢\n- 在 Monorepo 的情况下，还该不该使用 Path-Alias\n\n相信这些问题，都将是大家在实践中会遇到的一些问题\n\n## Example Project\n\n下面以我的博客 repo v6.0 使用 TypeScript 和 monorepo 形式开发过程中的一些实践。\n\n将会以比较简短的篇幅描述项目 Monorepo 相关的目录结构与相关的配置、配置要点，并描述如何/使用哪种方案去解决以上提及的问题。\n\n### Example Project Introduction\n\n整个项目源代码形式都以 TypeScript 作为主要语言，项目使用 Monorepo 进行一些子库之间的依赖管理。\n\n其中使用 Lerna 进行 Monorepo 管理的主要工具，使用 Jest 作为贯穿所有子项目的单元测试框架。\n\n整类子项目大概可以分成以下几种类型：\n\n```\npackages\n├── api-generator      // 工具库 - 根据路由元数据生成 JSON 结构的 API 相应内容\n├── application        // 核心构建流程，讲所有工具库和主题通过一定的构建流程串联在一起\n├── article-tools      // 工具库 - 将 .md 文件结合Markdown工具库转换成文章数据\n├── common             // 公共接口声明\n├── config             // 工具库 - 博客项目的配置发现与读取类库\n├── markdown           // 工具库 - 基于 Markdown-it 编写的各种扩展与插件\n├── migration          // 临时脚本 - 将上一版本的博客应用数据结构迁移的脚本集\n├── pwa-tools          // 工具库 - 基于 Workbox 生成 PWA 相关资源\n├── routes-tools       // 工具库 - 生成静态路由极其 Meta 信息\n├── theme-react        // 基于 React + Material UI 的前端主题\n└── theme-vue          // 基于 Vue + vuematerial 的前端主题\n```\n\n按照互相之间的依赖路径，会是以下这样一种依赖形式: (可以通过 `lerna ls --graph --all` 命令查看 )\n\n```\n{\n  \"@blog/api-generator\": [\n    \"@blog/article-tools\",\n    \"@blog/common\",\n    \"@blog/routes-tools\"\n  ],\n  \"@blog/application\": [\n    \"@blog/api-generator\",\n    \"@blog/article-tools\",\n    \"@blog/common\",\n    \"@blog/config\"\n  ],\n  \"@blog/article-tools\": [\n    \"@blog/common\",\n    \"@blog/markdown\"\n  ],\n  \"@blog/common\": [\n  ],\n  \"@blog/config\": [\n  ],\n  \"@blog/markdown\": [\n    \"@blog/common\"\n  ],\n  \"@blog/migration\": [\n    \"@blog/article-tools\",\n    \"@blog/markdown\"\n  ],\n  \"@blog/pwa-tools\": [\n    \"@blog/common\"\n  ],\n  \"@blog/routes-tools\": [\n    \"@blog/article-tools\",\n    \"@blog/common\",\n    \"@blog/config\"\n  ],\n  \"@blog/theme-react\": [\n    \"@blog/common\",\n    \"@blog/config\"\n  ],\n  \"@blog/theme-vue\": [\n    \"@blog/common\",\n    \"@blog/config\",\n    \"@blog/routes-tools\"\n  ]\n}\n```\n\n### Example Project Folder Structure\n\n现在我们来看整个项目的结构，以及其特点 (为节省面板，省略部分结构相同的工具类库目录)\n\n```\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── data\n├── lerna.json\n├── package.json\n├── packages\n│   ├── api-generator\n│   ├── application\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── nest-cli.json\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.build.json\n│   │   ├── tsconfig.json\n│   ├── article-tools\n│   ├── common\n│   │   ├── README.md\n│   │   ├── constants\n│   │   ├── interfaces\n│   │   ├── package.json\n│   │   ├── tsconfig.json\n│   │   ├── utils\n│   │   └── yarn.lock\n│   ├── config\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   └── yarn.lock\n│   ├── markdown\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   └── yarn.lock\n│   ├── migration\n│   ├── pwa-tools\n│   ├── routes-tools\n│   ├── theme-react\n│   │   ├── dist\n│   │   ├── gulpfile.ts\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   ├── tsconfig.webpack.json\n│   │   ├── webpack\n│   │   ├── yarn-error.log\n│   │   └── yarn.lock\n│   └── theme-vue\n│       ├── README.md\n│       ├── dist\n│       ├── package.json\n│       ├── public\n│       ├── src\n│       ├── tsconfig.json\n│       ├── vue.config.js\n│       ├── vue.config.ts\n│       ├── webpack.config.js\n│       └── yarn.lock\n```\n\n可以看到，中间标记为工具库一类的类库，都有 `dist` 和 `src` 目录，作为以 TypeScript 为源代码的语言，我给他们人为地设定了基本的 `TypeScript` + `Lib` 的构建路径，所以在单个项目接口来看，他们都具有通用的 `tsconfig.json` 和 jest 使用的 `jest.config` (in package.json).\n\n**tsconfig.json**\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"declaration\": true,\n    \"removeComments\": true,\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"resolveJsonModule\": true,\n    \"target\": \"es6\",\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"baseUrl\": \"./\",\n    \"incremental\": true,\n    \"noImplicitAny\": false,\n    \"typeRoots\": [\"./node_modules/@types\"]\n  },\n  \"exclude\": [\"node_modules\", \"dist\", \"reports\", \"**/*.test.ts\"]\n}\n```\n\n**jest.config**\n\n```json\n{\n  \"jest\": {\n    \"moduleFileExtensions\": [\"ts\", \"js\", \"json\"],\n    \"transform\": {\n      \"^.+\\\\.ts$\": \"ts-jest\",\n      \"^.*\\\\.md$\": \"jest-raw-loader\"\n    },\n    \"collectCoverageFrom\": [\"!**/__tests__/**\", \"<rootDir>/src/**/*.ts\"],\n    \"testMatch\": [\"<rootDir>/src/**/*.test.ts\"],\n    \"testEnvironment\": \"node\",\n    \"coverageDirectory\": \"<rootDir>/reports/coverage\"\n  }\n}\n```\n\n对于单一一个类库，必定有着两步 npm script: build, test:\n\n- npm run build 将执行命令 tsc，根据 tsconfig.json 的配置，将 `src` 目录下的 ts 文件转译成 `dist` 目录下的 commonjs 文件。\n- npm run test 将执行命令 jest，根据 jest 的配置， 读取 `\"<rootDir>/src/**/*.test.ts\"` unix path glob pattern 匹配的测试文件执行单元测试。\n\n## Solutions\n\n言归正传，我们回去之前引出的  Monorepo 在实践中诞生的第一个问题\n\n- UnitTesting cross Monorepo\n\n不过我们可以由浅入深，先来看看这些由纯工具类库构造成的 Monorepo 如何执行单元测试，再进化到遇到其他乱七八糟复杂的复杂情况时，应当如何应对。\n\n### UnitTesting cross Monorepo\n\n由于我们可以直接在每个工具类库下单独执行 `npm run test` 来分别执行单元测试，那么则可以在项目根目录下通过 `lerna run test` 执行。\n\n啊哈！思考往往没有这么简单。我们执行单元测试的过程，不仅仅是为了为了分批执行多个子项目的单元测试，判断中间是否有非 0 退出的错误案例，用以快速反馈本次 commit 是否可能造成了破坏性的后果。还能结合很多测试结果相关的 CI 工具，反馈单元测试覆盖率等关键指标。\n\n在开源界免费、支持度比较好覆盖率分析平台，不得不说 [Codecov](https://codecov.io/) 。基本上在尝试过所有类似的、免费的覆盖率报告分析平台后，最后都选择迁移到 Codecov 上。\n\n那这里引发的关键思考点是: 我们分别在每个子项目下分别执行 `npm run test` ，根据各个子项目的 jestconfig, 将会在不同的子项目目录下生成覆盖率报告 (这里特指 jest 生成的 linux 标准的 `[lcov.info](http://lcov.info)` ) 文件。那么我们的 codecov 有办法汇总多个不同的 lcov.info 文件并为 Monorepo 的单个大项目仓库生成一份覆盖率报告吗 ?\n\n我至今还没为这种思路找到经典、合理的解决方案。\n\n如果在 Monorepo 的根目录里执行 `jest` ，接着为整个项目生成一份覆盖率报告，这样来说是不是比较方便的解决这个问题呢?\n\n由于我们的工具类子仓库大部分都含有相同的目录结构，比如单元测试文件都可以用固定的 glob 表达式进行匹配，因而我们可以在项目根目录里安装 `typescript` 和 `jest` 相关依赖，然后自上而下的查找 sub-packages 中的测试文件执行测试，使得我们可以通过在不同的路径执行 `jest` 而达到不同的效果:\n\n- 在根目录下执行 jest，可以一次执行所有 sub-packages 的测试，并在根目录指定的文件夹下生成覆盖率报告\n- 在单个 sub-package 下执行 jest，可以快速的执行单个 sub-packages 下的测试，执行效率高，且能适配大多数 IDE、Editor 的单元测试执行上下文自动发现\n\n所以这里的解决方案的前置要求便是:\n\n- 每个 sub-package 具有类似的、统一的测试路径结构风格\n- 每个 sub-package 使用到的 jest extension 不允许存在互斥的情况\n- 根目录的 jest 配置是所有 sub-packages 的并集\n\n到了这里，我们可以看一下在这种解决方案下的更目录的 jestconfig:\n\n其中关键的节点是 `testMatch` 与 `collectCoverageFrom` 下的字段，用 `<rootDir>/packages/**/src/**/*` 去匹配所有 sub-packages 下的源代码与测试代码。\n\n```json\n{\n  \"jest\": {\n    \"moduleFileExtensions\": [\"ts\", \"js\", \"json\"],\n    \"transform\": {\n      \"^.+\\\\.ts$\": \"ts-jest\",\n      \"^.*\\\\.md$\": \"jest-raw-loader\"\n    },\n    \"collectCoverageFrom\": [\n      \"!**/__tests__/**\",\n      \"!**/src/index.ts\",\n      \"!**/src/main.ts\",\n      \"!**/src/plugins.ts\",\n      \"!**/*.module.ts\",\n      \"!**/migration.ts\",\n      \"<rootDir>/src/**/*.ts\",\n      \"<rootDir>/packages/**/src/**/*.ts\"\n    ],\n    \"testMatch\": [\"<rootDir>/src/**/*.test.ts\", \"<rootDir>/packages/**/src/**/*.test.ts\"],\n    \"testEnvironment\": \"node\",\n    \"coverageDirectory\": \"<rootDir>/reports/coverage\"\n  }\n}\n```\n\n如此一来，我们便解决了基本的问题。\n\n下面我们来看糅合了实际工作中一些复杂的情况：整合带 Path Alias 的子项目。\n\n### Path Alias\n\n这里将会以博客项目中的 `application` 子项目作为讲解。\n\n`application` 子项目是一个使用了 nestjs 作为基本框架的项目，他在整个博客应用中起的作用是:\n\n调用其他类库，并按照一定的顺序执行整个构建工作流，如扫描读取所有 Markdown 文件并提取其元数据，根据元信息构造路由，根据路由信息构造 API 内容 等等。\n\n所以作为整个 Monorepo 中具有唯一性的、没有被其他 sub-package 依赖的调用方项目，我为他设置了一个 Path Alias: `@-> ./src`\n\n在子项目路径  `packages/application` 目录下，tsconfig.json 中的路径别称是:\n\n```json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n在 jestconfig 中也需要声明这个 Path Alias:\n\n```json\n{\n  \"jest\": {\n    \"moduleNameMapper\": {\n      \"^@/(.*)$\": \"<rootDir>/src/$1\"\n    }\n  }\n}\n```\n\n为了遵循原先的解决方案需求，为应对这种具有 Path Alias 的子项目，我的实践如下:\n\n- 子项目本身设立 Path Alias\n- 子项目的测试代码结构与其他类库路径风格对齐\n- 根目录在 jestconfig 下添加相关的 Path Alias 设置，即:\n\n```json\n{\n  \"jest\": {\n    \"moduleNameMapper\": {\n      \"^@/(.*)$\": \"<rootDir>/packages/application/src/$1\"\n    }\n  }\n}\n```\n\n这样便能解决 Path Alias x UnitTesting 的问题。\n\n### Summarization\n\n结合在项目中遇到的以上问题以及目前的实践方案，也反向引导出我们在项目中也需要遵循一些认为的、容易接受的约定。\n\n总结这几个问题的解决思路，可以汇总成一下个情景。\n\n我们在遇到 TypeScript + Jest + Monorepo 的场景时，需要遵循以下几种约定:\n\n- 带有 Path Alias 的子项目，尽量不要被其他子项目所依赖\n- 所有子项目的测试文件路径表达式尽量一致\n\n在执行测试和构建方面，则需要注意以下的配置方式:\n\n- 在根目录下执行 Jest，Jest 的配置是所有子项目 Jest 配置的并集\n- 在根目录下执行 Jest，Jest 的配置需要理解带 Path Alias 子项目的路径 Mapping (即需要根目录理解此子项目的 Mapping 配置)\n\n### More Complex Situation\n\n中间还会发现有一些更复杂的情况\n\n- 多个子项目的 tsconfig.json 不尽相同，无法合并出合理的并集?\n- 子项目是一个前端项目，用到了很多不同的 loader 与插件，如 React/Vue ，根目录的配置是否也需要理解并安装这些 loader 呢?\n\n## References\n\n- Lerna at Github [https://github.com/lerna/lerna](https://github.com/lerna/lerna)\n- Javascript Monorepo with Lerna [https://medium.com/@erzhtor/javascript-monorepo-with-lerna-5729d6242302](https://medium.com/@erzhtor/javascript-monorepo-with-lerna-5729d6242302)\n","html":"<h1 id=\"monorepo-practice-in-typescript-projects\">Monorepo Practice in TypeScript Projects</h1>\n<h2 id=\"background\">Background</h2>\n<p>随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。</p>\n<p>我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。</p>\n<blockquote>\n<p>Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考之湖上的这篇文章: <a href=\"https://zhuanlan.zhihu.com/p/31289463\">https://zhuanlan.zhihu.com/p/31289463</a></p>\n</blockquote>\n<p>由于在其他(这里值一些较较成熟的语言，如 Java)语言的包管理生态圈里已有很多成熟的解决方案，如 Java 世界里的 Maven/Gradle , 其中都有很多较佳时间在各种成熟的开源项目中有所体现。</p>\n<p>由于 Node 官方的 NPM Package Registry 并没有提供一个官方的解决方案，所以目前会有很多的实现方案，比如 <code>Lerna</code> , <code>Yarn Workspace</code> , 更甚者还有一些脚本替换发布方案。</p>\n<p>近期我在好几个 Node with TypeScript 项目(不管是工作中的项目抑或是自己的项目)中，都尝试开始使用 MonoRepo 的形式去组织代码结构与 CICD 流程。这里分享下对 Nodejs + TypeScript 的一些实践经验。</p>\n<h3 id=\"problems\">Problems</h3>\n<p>要使用 Multi-Repo 还是 Monorepo，又或者是如何从 Multi-Repo 迁移、进化成 Monorepo，不同项目都面对着不同的问题。</p>\n<p>我抽取了我在这些 Node 项目在修改成 Monorepo 的过程中面对的一些问题，并在下文中给出目前我觉得较为合理的一些解决方案。</p>\n<h3 id=\"unit-testing\">Unit Testing</h3>\n<p>常规的 Multi-Repo 的单元测试流程理解起来会比较简单。以常见的 <code>jest</code> 来看，为单个 Repo 设立单元测试、为单个 Repo 关联代码覆盖率相关的 CI 配置/平台，都相当简单。</p>\n<p>当执行 Jest 进行单元测试的时候，我们只用维护一份 Jest 配置。接着一切便按照 Jest 的配置正常运作:</p>\n<ul>\n<li>代码覆盖率相关的 CI 读取 Jest 配置中执行的 <code>coverageDirectory</code> 下相关的覆盖率报告文件</li>\n<li>需要在 Jest 执行的各种生命周期的 Hooks 都能通过配置一目了然</li>\n</ul>\n<p>当我们把这些 Multi-Repo 集中到一起的时候，问题便显现出来：</p>\n<ul>\n<li>运行测试是逐个 sub-packages 单独执行测试吗? 如 <code>lerna run test</code></li>\n<li>单元测试的配置应该如何维护? 维护在 Monorepo 的根目录还是单独拆分维护在每个 sub-package 下?</li>\n<li>如何像 Multi-Repo 那样与测试覆盖率的 CI 集合起来?</li>\n</ul>\n<h3 id=\"with-path-alias\">With Path Alias</h3>\n<p>现代化的 Node 项目(不管是 Node 还是前端项目)，很多时候都有一些 Path-Alias 的技巧。</p>\n<p>具体表现是什么呢? 比如利用 <code>webpack</code> 的 <code>path.resolve</code> 配置或者 <code>tsconfig</code> 中 <code>paths</code> 的配置，做一些路径的简化，以节省各种相对路径 <code>../..</code> 的使用。</p>\n<p>如 <code>@/main.ts</code> 实际指向了以项目根目录开始的 <code>&lt;rootDir&gt;/src/main.ts</code></p>\n<p>但是，在 Monorepo 下，我们在想方便的以 <code>@</code> 作为 Path Alias，则会遇到很多思考上的问题。</p>\n<p>在单个 sub-package 内 理解并执行 Path-Alias 会跟原先的方式没什么区别。但是需要 root package</p>\n<p>也理解 sub-package 的 Path-Alias 配置则需要很多思考：</p>\n<ul>\n<li>多个使用 相同 Path-Alias 的 sub-packages 之间应该如何解析? 大家都在使用相同的 <code>@</code> 作为引用路径别名的情况下，怎么知道此时的 <code>@</code> 是对应哪一个正确的绝对路径呢</li>\n<li>在 Monorepo 的情况下，还该不该使用 Path-Alias</li>\n</ul>\n<p>相信这些问题，都将是大家在实践中会遇到的一些问题</p>\n<h2 id=\"example-project\">Example Project</h2>\n<p>下面以我的博客 repo v6.0 使用 TypeScript 和 monorepo 形式开发过程中的一些实践。</p>\n<p>将会以比较简短的篇幅描述项目 Monorepo 相关的目录结构与相关的配置、配置要点，并描述如何/使用哪种方案去解决以上提及的问题。</p>\n<h3 id=\"example-project-introduction\">Example Project Introduction</h3>\n<p>整个项目源代码形式都以 TypeScript 作为主要语言，项目使用 Monorepo 进行一些子库之间的依赖管理。</p>\n<p>其中使用 Lerna 进行 Monorepo 管理的主要工具，使用 Jest 作为贯穿所有子项目的单元测试框架。</p>\n<p>整类子项目大概可以分成以下几种类型：</p>\n<pre class=\"hljs\"><code>packages\n├── api-generator      // 工具库 - 根据路由元数据生成 JSON 结构的 API 相应内容\n├── application        // 核心构建流程，讲所有工具库和主题通过一定的构建流程串联在一起\n├── article-tools      // 工具库 - 将 .md 文件结合Markdown工具库转换成文章数据\n├── common             // 公共接口声明\n├── config             // 工具库 - 博客项目的配置发现与读取类库\n├── markdown           // 工具库 - 基于 Markdown-it 编写的各种扩展与插件\n├── migration          // 临时脚本 - 将上一版本的博客应用数据结构迁移的脚本集\n├── pwa-tools          // 工具库 - 基于 Workbox 生成 PWA 相关资源\n├── routes-tools       // 工具库 - 生成静态路由极其 Meta 信息\n├── theme-react        // 基于 React + Material UI 的前端主题\n└── theme-vue          // 基于 Vue + vuematerial 的前端主题\n</code></pre>\n<p>按照互相之间的依赖路径，会是以下这样一种依赖形式: (可以通过 <code>lerna ls --graph --all</code> 命令查看 )</p>\n<pre class=\"hljs\"><code>{\n  &quot;@blog/api-generator&quot;: [\n    &quot;@blog/article-tools&quot;,\n    &quot;@blog/common&quot;,\n    &quot;@blog/routes-tools&quot;\n  ],\n  &quot;@blog/application&quot;: [\n    &quot;@blog/api-generator&quot;,\n    &quot;@blog/article-tools&quot;,\n    &quot;@blog/common&quot;,\n    &quot;@blog/config&quot;\n  ],\n  &quot;@blog/article-tools&quot;: [\n    &quot;@blog/common&quot;,\n    &quot;@blog/markdown&quot;\n  ],\n  &quot;@blog/common&quot;: [\n  ],\n  &quot;@blog/config&quot;: [\n  ],\n  &quot;@blog/markdown&quot;: [\n    &quot;@blog/common&quot;\n  ],\n  &quot;@blog/migration&quot;: [\n    &quot;@blog/article-tools&quot;,\n    &quot;@blog/markdown&quot;\n  ],\n  &quot;@blog/pwa-tools&quot;: [\n    &quot;@blog/common&quot;\n  ],\n  &quot;@blog/routes-tools&quot;: [\n    &quot;@blog/article-tools&quot;,\n    &quot;@blog/common&quot;,\n    &quot;@blog/config&quot;\n  ],\n  &quot;@blog/theme-react&quot;: [\n    &quot;@blog/common&quot;,\n    &quot;@blog/config&quot;\n  ],\n  &quot;@blog/theme-vue&quot;: [\n    &quot;@blog/common&quot;,\n    &quot;@blog/config&quot;,\n    &quot;@blog/routes-tools&quot;\n  ]\n}\n</code></pre>\n<h3 id=\"example-project-folder-structure\">Example Project Folder Structure</h3>\n<p>现在我们来看整个项目的结构，以及其特点 (为节省面板，省略部分结构相同的工具类库目录)</p>\n<pre class=\"hljs\"><code>├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── data\n├── lerna.json\n├── package.json\n├── packages\n│   ├── api-generator\n│   ├── application\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── nest-cli.json\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.build.json\n│   │   ├── tsconfig.json\n│   ├── article-tools\n│   ├── common\n│   │   ├── README.md\n│   │   ├── constants\n│   │   ├── interfaces\n│   │   ├── package.json\n│   │   ├── tsconfig.json\n│   │   ├── utils\n│   │   └── yarn.lock\n│   ├── config\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   └── yarn.lock\n│   ├── markdown\n│   │   ├── README.md\n│   │   ├── dist\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   └── yarn.lock\n│   ├── migration\n│   ├── pwa-tools\n│   ├── routes-tools\n│   ├── theme-react\n│   │   ├── dist\n│   │   ├── gulpfile.ts\n│   │   ├── package.json\n│   │   ├── src\n│   │   ├── tsconfig.json\n│   │   ├── tsconfig.webpack.json\n│   │   ├── webpack\n│   │   ├── yarn-error.log\n│   │   └── yarn.lock\n│   └── theme-vue\n│       ├── README.md\n│       ├── dist\n│       ├── package.json\n│       ├── public\n│       ├── src\n│       ├── tsconfig.json\n│       ├── vue.config.js\n│       ├── vue.config.ts\n│       ├── webpack.config.js\n│       └── yarn.lock\n</code></pre>\n<p>可以看到，中间标记为工具库一类的类库，都有 <code>dist</code> 和 <code>src</code> 目录，作为以 TypeScript 为源代码的语言，我给他们人为地设定了基本的 <code>TypeScript</code> + <code>Lib</code> 的构建路径，所以在单个项目接口来看，他们都具有通用的 <code>tsconfig.json</code> 和 jest 使用的 <code>jest.config</code> (in package.json).</p>\n<p><strong>tsconfig.json</strong></p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"commonjs\"</span>,\n    <span class=\"hljs-attr\">\"declaration\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"removeComments\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"emitDecoratorMetadata\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"experimentalDecorators\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"resolveJsonModule\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"target\"</span>: <span class=\"hljs-string\">\"es6\"</span>,\n    <span class=\"hljs-attr\">\"sourceMap\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"outDir\"</span>: <span class=\"hljs-string\">\"./dist\"</span>,\n    <span class=\"hljs-attr\">\"baseUrl\"</span>: <span class=\"hljs-string\">\"./\"</span>,\n    <span class=\"hljs-attr\">\"incremental\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"noImplicitAny\"</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">\"typeRoots\"</span>: [<span class=\"hljs-string\">\"./node_modules/@types\"</span>]\n  },\n  <span class=\"hljs-attr\">\"exclude\"</span>: [<span class=\"hljs-string\">\"node_modules\"</span>, <span class=\"hljs-string\">\"dist\"</span>, <span class=\"hljs-string\">\"reports\"</span>, <span class=\"hljs-string\">\"**/*.test.ts\"</span>]\n}\n</code></pre>\n<p><strong>jest.config</strong></p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"jest\"</span>: {\n    <span class=\"hljs-attr\">\"moduleFileExtensions\"</span>: [<span class=\"hljs-string\">\"ts\"</span>, <span class=\"hljs-string\">\"js\"</span>, <span class=\"hljs-string\">\"json\"</span>],\n    <span class=\"hljs-attr\">\"transform\"</span>: {\n      <span class=\"hljs-attr\">\"^.+\\\\.ts$\"</span>: <span class=\"hljs-string\">\"ts-jest\"</span>,\n      <span class=\"hljs-attr\">\"^.*\\\\.md$\"</span>: <span class=\"hljs-string\">\"jest-raw-loader\"</span>\n    },\n    <span class=\"hljs-attr\">\"collectCoverageFrom\"</span>: [<span class=\"hljs-string\">\"!**/__tests__/**\"</span>, <span class=\"hljs-string\">\"&lt;rootDir&gt;/src/**/*.ts\"</span>],\n    <span class=\"hljs-attr\">\"testMatch\"</span>: [<span class=\"hljs-string\">\"&lt;rootDir&gt;/src/**/*.test.ts\"</span>],\n    <span class=\"hljs-attr\">\"testEnvironment\"</span>: <span class=\"hljs-string\">\"node\"</span>,\n    <span class=\"hljs-attr\">\"coverageDirectory\"</span>: <span class=\"hljs-string\">\"&lt;rootDir&gt;/reports/coverage\"</span>\n  }\n}\n</code></pre>\n<p>对于单一一个类库，必定有着两步 npm script: build, test:</p>\n<ul>\n<li>npm run build 将执行命令 tsc，根据 tsconfig.json 的配置，将 <code>src</code> 目录下的 ts 文件转译成 <code>dist</code> 目录下的 commonjs 文件。</li>\n<li>npm run test 将执行命令 jest，根据 jest 的配置， 读取 <code>&quot;&lt;rootDir&gt;/src/**/*.test.ts&quot;</code> unix path glob pattern 匹配的测试文件执行单元测试。</li>\n</ul>\n<h2 id=\"solutions\">Solutions</h2>\n<p>言归正传，我们回去之前引出的  Monorepo 在实践中诞生的第一个问题</p>\n<ul>\n<li>UnitTesting cross Monorepo</li>\n</ul>\n<p>不过我们可以由浅入深，先来看看这些由纯工具类库构造成的 Monorepo 如何执行单元测试，再进化到遇到其他乱七八糟复杂的复杂情况时，应当如何应对。</p>\n<h3 id=\"unittesting-cross-monorepo\">UnitTesting cross Monorepo</h3>\n<p>由于我们可以直接在每个工具类库下单独执行 <code>npm run test</code> 来分别执行单元测试，那么则可以在项目根目录下通过 <code>lerna run test</code> 执行。</p>\n<p>啊哈！思考往往没有这么简单。我们执行单元测试的过程，不仅仅是为了为了分批执行多个子项目的单元测试，判断中间是否有非 0 退出的错误案例，用以快速反馈本次 commit 是否可能造成了破坏性的后果。还能结合很多测试结果相关的 CI 工具，反馈单元测试覆盖率等关键指标。</p>\n<p>在开源界免费、支持度比较好覆盖率分析平台，不得不说 <a href=\"https://codecov.io/\">Codecov</a> 。基本上在尝试过所有类似的、免费的覆盖率报告分析平台后，最后都选择迁移到 Codecov 上。</p>\n<p>那这里引发的关键思考点是: 我们分别在每个子项目下分别执行 <code>npm run test</code> ，根据各个子项目的 jestconfig, 将会在不同的子项目目录下生成覆盖率报告 (这里特指 jest 生成的 linux 标准的 <code>[lcov.info](http://lcov.info)</code> ) 文件。那么我们的 codecov 有办法汇总多个不同的 lcov.info 文件并为 Monorepo 的单个大项目仓库生成一份覆盖率报告吗 ?</p>\n<p>我至今还没为这种思路找到经典、合理的解决方案。</p>\n<p>如果在 Monorepo 的根目录里执行 <code>jest</code> ，接着为整个项目生成一份覆盖率报告，这样来说是不是比较方便的解决这个问题呢?</p>\n<p>由于我们的工具类子仓库大部分都含有相同的目录结构，比如单元测试文件都可以用固定的 glob 表达式进行匹配，因而我们可以在项目根目录里安装 <code>typescript</code> 和 <code>jest</code> 相关依赖，然后自上而下的查找 sub-packages 中的测试文件执行测试，使得我们可以通过在不同的路径执行 <code>jest</code> 而达到不同的效果:</p>\n<ul>\n<li>在根目录下执行 jest，可以一次执行所有 sub-packages 的测试，并在根目录指定的文件夹下生成覆盖率报告</li>\n<li>在单个 sub-package 下执行 jest，可以快速的执行单个 sub-packages 下的测试，执行效率高，且能适配大多数 IDE、Editor 的单元测试执行上下文自动发现</li>\n</ul>\n<p>所以这里的解决方案的前置要求便是:</p>\n<ul>\n<li>每个 sub-package 具有类似的、统一的测试路径结构风格</li>\n<li>每个 sub-package 使用到的 jest extension 不允许存在互斥的情况</li>\n<li>根目录的 jest 配置是所有 sub-packages 的并集</li>\n</ul>\n<p>到了这里，我们可以看一下在这种解决方案下的更目录的 jestconfig:</p>\n<p>其中关键的节点是 <code>testMatch</code> 与 <code>collectCoverageFrom</code> 下的字段，用 <code>&lt;rootDir&gt;/packages/**/src/**/*</code> 去匹配所有 sub-packages 下的源代码与测试代码。</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"jest\"</span>: {\n    <span class=\"hljs-attr\">\"moduleFileExtensions\"</span>: [<span class=\"hljs-string\">\"ts\"</span>, <span class=\"hljs-string\">\"js\"</span>, <span class=\"hljs-string\">\"json\"</span>],\n    <span class=\"hljs-attr\">\"transform\"</span>: {\n      <span class=\"hljs-attr\">\"^.+\\\\.ts$\"</span>: <span class=\"hljs-string\">\"ts-jest\"</span>,\n      <span class=\"hljs-attr\">\"^.*\\\\.md$\"</span>: <span class=\"hljs-string\">\"jest-raw-loader\"</span>\n    },\n    <span class=\"hljs-attr\">\"collectCoverageFrom\"</span>: [\n      <span class=\"hljs-string\">\"!**/__tests__/**\"</span>,\n      <span class=\"hljs-string\">\"!**/src/index.ts\"</span>,\n      <span class=\"hljs-string\">\"!**/src/main.ts\"</span>,\n      <span class=\"hljs-string\">\"!**/src/plugins.ts\"</span>,\n      <span class=\"hljs-string\">\"!**/*.module.ts\"</span>,\n      <span class=\"hljs-string\">\"!**/migration.ts\"</span>,\n      <span class=\"hljs-string\">\"&lt;rootDir&gt;/src/**/*.ts\"</span>,\n      <span class=\"hljs-string\">\"&lt;rootDir&gt;/packages/**/src/**/*.ts\"</span>\n    ],\n    <span class=\"hljs-attr\">\"testMatch\"</span>: [<span class=\"hljs-string\">\"&lt;rootDir&gt;/src/**/*.test.ts\"</span>, <span class=\"hljs-string\">\"&lt;rootDir&gt;/packages/**/src/**/*.test.ts\"</span>],\n    <span class=\"hljs-attr\">\"testEnvironment\"</span>: <span class=\"hljs-string\">\"node\"</span>,\n    <span class=\"hljs-attr\">\"coverageDirectory\"</span>: <span class=\"hljs-string\">\"&lt;rootDir&gt;/reports/coverage\"</span>\n  }\n}\n</code></pre>\n<p>如此一来，我们便解决了基本的问题。</p>\n<p>下面我们来看糅合了实际工作中一些复杂的情况：整合带 Path Alias 的子项目。</p>\n<h3 id=\"path-alias\">Path Alias</h3>\n<p>这里将会以博客项目中的 <code>application</code> 子项目作为讲解。</p>\n<p><code>application</code> 子项目是一个使用了 nestjs 作为基本框架的项目，他在整个博客应用中起的作用是:</p>\n<p>调用其他类库，并按照一定的顺序执行整个构建工作流，如扫描读取所有 Markdown 文件并提取其元数据，根据元信息构造路由，根据路由信息构造 API 内容 等等。</p>\n<p>所以作为整个 Monorepo 中具有唯一性的、没有被其他 sub-package 依赖的调用方项目，我为他设置了一个 Path Alias: <code>@-&gt; ./src</code></p>\n<p>在子项目路径  <code>packages/application</code> 目录下，tsconfig.json 中的路径别称是:</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"paths\"</span>: {\n      <span class=\"hljs-attr\">\"@/*\"</span>: [<span class=\"hljs-string\">\"src/*\"</span>]\n    }\n  }\n}\n</code></pre>\n<p>在 jestconfig 中也需要声明这个 Path Alias:</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"jest\"</span>: {\n    <span class=\"hljs-attr\">\"moduleNameMapper\"</span>: {\n      <span class=\"hljs-attr\">\"^@/(.*)$\"</span>: <span class=\"hljs-string\">\"&lt;rootDir&gt;/src/$1\"</span>\n    }\n  }\n}\n</code></pre>\n<p>为了遵循原先的解决方案需求，为应对这种具有 Path Alias 的子项目，我的实践如下:</p>\n<ul>\n<li>子项目本身设立 Path Alias</li>\n<li>子项目的测试代码结构与其他类库路径风格对齐</li>\n<li>根目录在 jestconfig 下添加相关的 Path Alias 设置，即:</li>\n</ul>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"jest\"</span>: {\n    <span class=\"hljs-attr\">\"moduleNameMapper\"</span>: {\n      <span class=\"hljs-attr\">\"^@/(.*)$\"</span>: <span class=\"hljs-string\">\"&lt;rootDir&gt;/packages/application/src/$1\"</span>\n    }\n  }\n}\n</code></pre>\n<p>这样便能解决 Path Alias x UnitTesting 的问题。</p>\n<h3 id=\"summarization\">Summarization</h3>\n<p>结合在项目中遇到的以上问题以及目前的实践方案，也反向引导出我们在项目中也需要遵循一些认为的、容易接受的约定。</p>\n<p>总结这几个问题的解决思路，可以汇总成一下个情景。</p>\n<p>我们在遇到 TypeScript + Jest + Monorepo 的场景时，需要遵循以下几种约定:</p>\n<ul>\n<li>带有 Path Alias 的子项目，尽量不要被其他子项目所依赖</li>\n<li>所有子项目的测试文件路径表达式尽量一致</li>\n</ul>\n<p>在执行测试和构建方面，则需要注意以下的配置方式:</p>\n<ul>\n<li>在根目录下执行 Jest，Jest 的配置是所有子项目 Jest 配置的并集</li>\n<li>在根目录下执行 Jest，Jest 的配置需要理解带 Path Alias 子项目的路径 Mapping (即需要根目录理解此子项目的 Mapping 配置)</li>\n</ul>\n<h3 id=\"more-complex-situation\">More Complex Situation</h3>\n<p>中间还会发现有一些更复杂的情况</p>\n<ul>\n<li>多个子项目的 tsconfig.json 不尽相同，无法合并出合理的并集?</li>\n<li>子项目是一个前端项目，用到了很多不同的 loader 与插件，如 React/Vue ，根目录的配置是否也需要理解并安装这些 loader 呢?</li>\n</ul>\n<h2 id=\"references\">References</h2>\n<ul>\n<li>Lerna at Github <a href=\"https://github.com/lerna/lerna\">https://github.com/lerna/lerna</a></li>\n<li>Javascript Monorepo with Lerna <a href=\"https://medium.com/@erzhtor/javascript-monorepo-with-lerna-5729d6242302\">https://medium.com/@erzhtor/javascript-monorepo-with-lerna-5729d6242302</a></li>\n</ul>\n","disqus":{"shortname":"aquariuslt","url":"https://blog.aquariuslt.com/posts/2019/11/14/monorepo-practice-in-typescript-projects","identifier":"-posts-2019-11-14-monorepo-practice-in-typescript-projects"}}}