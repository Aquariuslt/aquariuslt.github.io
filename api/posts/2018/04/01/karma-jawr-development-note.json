{"key":"karma-jawr-development-note","url":"https://zexo.dev/posts/2018/04/01/karma-jawr-development-note","path":"/posts/2018/04/01/karma-jawr-development-note","title":"A Karma Plugin: Karma-JAWR Development Note - zexo.dev","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zexo.dev","name":"Home","position":1},{"@type":"ListItem","item":"https://zexo.dev/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://zexo.dev/posts/2018/04/01/karma-jawr-development-note","name":"A Karma Plugin: Karma-JAWR Development Note","position":3}]},"type":"DETAIL","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"id":"google-analytics","name":"google-analytics","content":"UA-68904127-2"},{"name":"og:site_name","content":"zexo.dev"},{"name":"og:type","content":"website"},{"name":"og:title","itemprop":"name","content":"A Karma Plugin: Karma-JAWR Development Note"},{"name":"og:description","itemprop":"description","content":"上一篇文章基于 Karma 的非分离式前端单元测试基础方案描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解jawr这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。\n"},{"name":"og:image","itemprop":"image","content":"https:/zexo.dev/posts/2018/04/01/karma-jawr-development-note/cover.png"},{"name":"og:type","content":"article"},{"name":"description","itemprop":"description","content":"上一篇文章基于 Karma 的非分离式前端单元测试基础方案描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解jawr这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。\n"}],"data":{"title":"A Karma Plugin: Karma-JAWR Development Note","id":"karma-jawr-development-note","created":"2018-04-01T00:00:00.000Z","updated":"2018-04-01T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"karma","label":"Karma","total":0,"link":"/tags/karma"},{"id":"node","label":"Node","total":1,"link":"/tags/node"},{"id":"angularjs","label":"AngularJS","total":2,"link":"/tags/angularjs"},{"id":"javascript","label":"JavaScript","total":3,"link":"/tags/javascript"},{"id":"jawr","label":"JAWR","total":4,"link":"/tags/jawr"}],"cover":"/posts/2018/04/01/karma-jawr-development-note/cover.png","images":[],"toc":[{"label":"基于 Karma 的非分离式前端单元测试基础方案","level":1,"id":"基于-karma-的非分离式前端单元测试基础方案","position":0,"children":[],"pid":-1},{"label":"Background","level":2,"id":"background","position":1,"children":[],"pid":0},{"label":"Why","level":3,"id":"why","position":2,"children":[],"pid":1},{"label":"Knowledge Base","level":2,"id":"knowledge-base","position":3,"children":[],"pid":0},{"label":"History: node-di, angular.js and karma","level":3,"id":"history-node-di-angularjs-and-karma","position":4,"children":[],"pid":3},{"label":"Karma Plugin Types","level":3,"id":"karma-plugin-types","position":5,"children":[],"pid":3},{"label":"Frameworks","level":4,"id":"frameworks","position":6,"children":[],"pid":5},{"label":"Reporters","level":4,"id":"reporters","position":7,"children":[],"pid":5},{"label":"Launchers","level":4,"id":"launchers","position":8,"children":[],"pid":5},{"label":"Preprocessors","level":4,"id":"preprocessors","position":9,"children":[],"pid":5},{"label":"Development Note","level":2,"id":"development-note","position":10,"children":[],"pid":0},{"label":"Concert & Situations","level":3,"id":"concert-situations","position":11,"children":[],"pid":10},{"label":"Design","level":3,"id":"design","position":12,"children":[],"pid":10},{"label":"Development Roadmap","level":3,"id":"development-roadmap","position":13,"children":[],"pid":10},{"label":"Local Testing","level":4,"id":"local-testing","position":14,"children":[],"pid":13},{"label":"Integrate with CI","level":4,"id":"integrate-with-ci","position":15,"children":[],"pid":13},{"label":"Pre-Release and Testing","level":4,"id":"pre-release-and-testing","position":16,"children":[],"pid":13},{"label":"References","level":2,"id":"references","position":17,"children":[],"pid":0}],"summary":"上一篇文章基于 Karma 的非分离式前端单元测试基础方案描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解jawr这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。\n","src":"\n# 基于 Karma 的非分离式前端单元测试基础方案\n\n## Background\n\n### Why\n\n上一篇文章**基于 Karma 的非分离式前端单元测试基础方案**描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。\n\n## Knowledge Base\n\n在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解`jawr`这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。\n\n### History: node-di, angular.js and karma\n\n在介绍整个问题之前，无可避免的先介绍一下**karma**的一些背景。\n\n如果曾经接触过 angular.js 相关项目的开发，那就一定需要了解一下 angular.js 的依赖注入机制相关知识。\n\nangular.js v1 的依赖注入机制及其实现呢，其实就是来自于`node-di`的实现(后来 DEPRECATED 并迁移到`angular/di.js`，虽然后面 angular v2+也并没有使用这个实现)。而`node-di`，`angular.js v1`，和`karma`中的依赖注入实现的主要作者都是同一位大神: [vojtajina](https://github.com/vojtajina)\n\n所以我们可以看到在根据获取依赖的时候的一些类似的语法，诸如`$inject`等。\n\n所以一旦你看过一些其他的 karma 相关的 framework 的源代码，大概就知道要如何起手了去看了，起码你能够从一些基本的 ioc 设计原则上知道 karma 如何加载相关插件，等等。\n\n### Karma Plugin Types\n\n在 karma 的官方文档的[plugins 页面](https://karma-runner.github.io/2.0/dev/plugins.html)，提供了 karma 不同类型的插件及其常见列表。(其中很大部分是 karma 团队自己维护的，有一个官方的参考对象)。\n\n这里转贴一部分常见的不同几个类型。\n\n#### Frameworks\n\n- karma-jasmine\n- karma-mocha\n- karma-requirejs\n\n> karma frameworks 类型比较杂，功能可能是覆盖所有下面多种情况的一种或者多种\n\n#### Reporters\n\n- karma-junit-reporter\n- karma-coverage-istanbul-reporter\n\n> karma reporters 常见的功能是在 karma 运行完测试流程之后，根据测试过程记录下的各种记录文件，生成覆盖率，测试用例列表等报告的功能。\n\n#### Launchers\n\n- karma-chrome-launcher\n- karma-firefox-launcher\n\n> karma launcher 的功能就是提供给你启动所有位于系统中的浏览器的链接功能。比如出场率相当高的 karma-chrome-launcher 就实现了各个系统的 **Chrome**，**Chromium**，**Chrome Dev**，**Headless Chrome(puppeteer)** 的链接启动功能，通过默认的参数/或者自己穿进去的环境变量 等形式 可以唤起对应版本的浏览器实例来运行脚本。\n\n#### Preprocessors\n\n- karma-webpack\n- karma-babel-preprocessor\n\n> Preprocessors 顾名思义就是预处理器。很有可能你的单元测试代码是使用 ES6+的语法进行编写的，可能需要通过 babel 进行转译，或者根据 webpack 的配置 + 不同的 loader 进行转译，才能在运行中的浏览器示例上正常被解析执行。所以在一些 karma config options 里面能够看到类似下面的预处理流程：\n>\n> ```\n> preprocessors: {\n>      '/**/*.spec.js': ['webpack', 'sourcemap']\n> },\n> ```\n\n## Development Note\n\n### Concert & Situations\n\n在编写`karma-jawr`插件之前，我的设想需求，从编写单元测试代码的角度反向推导开之后，是这样一个流程：\n\n**jawr.properties**(片段)\n\n```\n# JAWR Bundle Definitions\njawr.js.bundle.extJs.id=/jsBundles/extJs.js\njawr.js.bundle.extJs.composite=true\njawr.js.bundle.extJs.child.names=\\\n  extDebug,\\\n  extProd\n## ExtJS Debug Source\njawr.js.bundle.extDebug.debugonly=true\njawr.js.bundle.extDebug.mappings=/js/vendor/ext/ext-base-debug.js, /js/vendor/ext/ext-all-debug-w-comments.js\n## Home Page Application JS Bundles\njawr.js.bundle.home.id=/jsBundles/home.js\njawr.js.bundle.home.composite=true\njawr.js.bundle.home.child.names=homeStore, homeUi, homeImpl\n```\n\n**xxx.xhtml**\n\n```htmlbars\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns:jawr=\"https://jawr.java.net/jsf/facelets\">\n<head>\n  <title>Karma Jawr Sample Page</title>\n  <link rel=\"shortcut icon\" href=\"${pageContext.request.contextPath}/images/icons/favicon.png\" type=\"image/x-icon\"/>\n  <jawr:style src=\"/cssBundles/ext.css\"/>\n  <jawr:script src=\"/jsBundles/extJs.js\"/>\n  <jawr:script src=\"/jsBundles/home.js\"/>\n</head>\n\n<body>\n\n<script type=\"text/javascript\">\n  Ext.onReady(function() {\n    Ext.QuickTips.init();\n    new karma.jawr.sample.app.Home({\n      renderTo: Ext.getBody()\n    });\n  });\n</script>\n</body>\n</html>\n\n```\n\n**xxx.spec.js**(片段)\n\n```\nrequire('@/jsBundles/extJs.js');\nrequire('@/jsBundles/home.js');\n\ndescribe('ext', function() {\n  it('# check extjs is loaded', function() {\n    var expectExtVersion = '3.3.1';\n    expect(Ext.version).to.eq(expectExtVersion);\n  });\n\n  it('# expect home ui is rendered', function() {\n    expect(Ext.getCmp('app.home')).not.to.eq(undefined);\n  });\n});\n\n```\n\n在进行测试的流程里面\n\n首先单元测试文件经过 preprocessor 的处理，能够把`require('@/jsBundles/extJs.js')` 正确根据`jawr.properties`的配置内容加载 extjs ~~这里且不说 extjs 本身的代码是否支持 umd 形式的 export~~ 接着在浏览器执行的时候的 html 引入的时候，已经是能够被浏览器正确识别的，转译后的代码。\n\n所以从流程上，结合已有的插件，列出了从后到前的顺序点：\n\n- 编写 BDD 形式的单元测试文件，通过 require/import + jawr bundle id 导入对应的业务代码依赖\n- 经过 webpack 转译成可被浏览器识别的代码\n- 在 karma 启动时的 client html 中通过 mocha 执行所有测试用例\n\n### Design\n\n那么主要的问题就在于，如何使得测试文件中的 `require('@/jsBundles/home.js');` 能够正确根据 jawr 的配置 反向引导对应的源代码呢？\n\n除此之外，还有一些 jawr+spring 国际化本身的一些实现，如何根据对应的国际化文件，生成那些全局，执行后返回对应语言版本国际化变量呢?\n\n对于第一步，目前设计的解决方案是如下：\n\n**第一步:** 给`karma.conf.js` 提供一个额外的 options field: jawr 主要是提供一些 jawr 相关配置文件的绝对路径\n\n目前我给他设置了一个 type-definition\n\n```typescript\ndeclare interface JawrOptions {\n  configLocation: string;\n  webappLocation: string;\n  targetLocation: string;\n\n  // optional locale config location for jawr i18n generator\n  localeConfigLocation?: string;\n}\n```\n\n实际上的使用大概是这样: karma.confg.js\n\n```\nmodule.exports = function(config){\n\tconfig.set({\n\t\t/*....*/\n\t\tjawr: {\n\t      configLocation: pathUtil.resolve('src/main/resources/jawr/') + 'jawr.properties',\n\t      webappLocation: pathUtil.resolve('src/main/webapp'),\n\t      targetLocation: pathUtil.resolve('src/test/js/build'),\n\t      localeConfigLocation: pathUtil.resolve('src/main/resources')\n\t    },\n\t})\n}\n```\n\n里面需要知道的是:\n\n- jawr.properties 的路径\n- webapp 文件夹的路径(目的是为了定位 js,css 业务源代码的路径)\n- 生成的中间临时文件夹的路径: 根据 jawr 配置文件生成的实际路径的处于`*.spec.js`和源代码中间的临时 link 文件夹\n- 如果启用了可选的国际化模块，则需要填写国际化源代码文件的路径\n\n**第二步** 根据 jawr 的 Java 源代码，使用 js 实现以下功能\n\n- 解析 jawr 配置文件，根据每个 bundle id 来查找到对应的源代码文件\n- 解析 i18n 配置文件，生成对应的全局变量行数\n\n**第三步** 通过 karma 结合 webpack 做预处理器，结合`mocha`，`chai`，`sinon` 做基本的测试。\n\n### Development Roadmap\n\n#### Local Testing\n\n如果没有了解 npm 加载模块机制和 karma 所使用的 di 约定的时候，可能本地测试必须依赖已经发布的 npm package.\n\n正确的做法应该是:\n\n在**karma.conf.js** 的 plugins 显式声明一个本地的引用该引用等同`package.json`里面`main`的指向\n\n```\nplugins: [\n      'karma-chrome-launcher',\n      'karma-chai',\n      'karma-mocha',\n      'karma-spec-reporter',\n      'karma-coverage',\n      'karma-coverage-istanbul-reporter',\n      'karma-sourcemap-loader',\n      'karma-sinon',\n      'karma-webpack',\n      localJawrFramework //  ==> var localJawrFramework = require('../../lib');\n    ],\n```\n\n**package.json**\n\n```json\n{\n  \"name\": \"karma-jawr\",\n  \"main\": \"lib/index.js\"\n}\n```\n\n**lib/index.js**\n\n```javascript\nvar frameworkLogger = require('./logger');\n\nvar jawrHandler = require('./jawr.handler');\n\n/**\n * @param {Array} files: file pattern\n * @param {JawrOptions} jawrOptions: jawrOptions\n * @param {Object} logger: karma logger\n * */\nvar framework = function(files, jawrOptions, logger) {\n  frameworkLogger.initLogger(logger);\n  jawrHandler.handle(jawrOptions);\n};\n\nframework.$inject = ['config.files', 'config.jawr', 'logger'];\nmodule.exports = { 'framework:jawr': ['factory', framework] };\n```\n\n#### Integrate with CI\n\n目前只有测试部分与`travis-ci`和`circleci`集成了。\n\n[circleci](https://circleci.com/gh/aquariuslt/karma-jawr) [travis-ci](https://travis-ci.org/aquariuslt/karma-jawr)\n\n#### Pre-Release and Testing\n\n为了解决其他在实际应用中遇到的问题，包括但不限于各种\n\n- jawr 配置的胡乱使用\n- node.js 的 properties 解释实现并没有覆盖 properties 事实标准的所有情况\n\n等...我是自己维护了 issue 列表并且把每次修改的测试用例都加到本身的单元测试流程中\n\n目前详见[issues](https://github.com/aquariuslt/karma-jawr/issues)\n\n~~有一个目前因为技术原因暂时被我 标记了 wont fix~~\n\n## References\n\n[项目源代码 Repo](https://github.com/aquariuslt/karma-jawr)\n\n[Karma 作者的设计论文](https://github.com/karma-runner/karma/raw/master/thesis.pdf)\n\n[Karma 测试框架的前世今生 - 淘宝 TED | Karma 作者论文译文](http://taobaofed.org/blog/2016/01/08/karma-origin/)\n","html":"<h1 id=\"基于-karma-的非分离式前端单元测试基础方案\">基于 Karma 的非分离式前端单元测试基础方案</h1>\n<h2 id=\"background\">Background</h2>\n<h3 id=\"why\">Why</h3>\n<p>上一篇文章<strong>基于 Karma 的非分离式前端单元测试基础方案</strong>描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。</p>\n<h2 id=\"knowledge-base\">Knowledge Base</h2>\n<p>在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解<code>jawr</code>这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。</p>\n<h3 id=\"history-node-di-angularjs-and-karma\">History: node-di, angular.js and karma</h3>\n<p>在介绍整个问题之前，无可避免的先介绍一下<strong>karma</strong>的一些背景。</p>\n<p>如果曾经接触过 angular.js 相关项目的开发，那就一定需要了解一下 angular.js 的依赖注入机制相关知识。</p>\n<p>angular.js v1 的依赖注入机制及其实现呢，其实就是来自于<code>node-di</code>的实现(后来 DEPRECATED 并迁移到<code>angular/di.js</code>，虽然后面 angular v2+也并没有使用这个实现)。而<code>node-di</code>，<code>angular.js v1</code>，和<code>karma</code>中的依赖注入实现的主要作者都是同一位大神: <a href=\"https://github.com/vojtajina\">vojtajina</a></p>\n<p>所以我们可以看到在根据获取依赖的时候的一些类似的语法，诸如<code>$inject</code>等。</p>\n<p>所以一旦你看过一些其他的 karma 相关的 framework 的源代码，大概就知道要如何起手了去看了，起码你能够从一些基本的 ioc 设计原则上知道 karma 如何加载相关插件，等等。</p>\n<h3 id=\"karma-plugin-types\">Karma Plugin Types</h3>\n<p>在 karma 的官方文档的<a href=\"https://karma-runner.github.io/2.0/dev/plugins.html\">plugins 页面</a>，提供了 karma 不同类型的插件及其常见列表。(其中很大部分是 karma 团队自己维护的，有一个官方的参考对象)。</p>\n<p>这里转贴一部分常见的不同几个类型。</p>\n<h4 id=\"frameworks\">Frameworks</h4>\n<ul>\n<li>karma-jasmine</li>\n<li>karma-mocha</li>\n<li>karma-requirejs</li>\n</ul>\n<blockquote>\n<p>karma frameworks 类型比较杂，功能可能是覆盖所有下面多种情况的一种或者多种</p>\n</blockquote>\n<h4 id=\"reporters\">Reporters</h4>\n<ul>\n<li>karma-junit-reporter</li>\n<li>karma-coverage-istanbul-reporter</li>\n</ul>\n<blockquote>\n<p>karma reporters 常见的功能是在 karma 运行完测试流程之后，根据测试过程记录下的各种记录文件，生成覆盖率，测试用例列表等报告的功能。</p>\n</blockquote>\n<h4 id=\"launchers\">Launchers</h4>\n<ul>\n<li>karma-chrome-launcher</li>\n<li>karma-firefox-launcher</li>\n</ul>\n<blockquote>\n<p>karma launcher 的功能就是提供给你启动所有位于系统中的浏览器的链接功能。比如出场率相当高的 karma-chrome-launcher 就实现了各个系统的 <strong>Chrome</strong>，<strong>Chromium</strong>，<strong>Chrome Dev</strong>，<strong>Headless Chrome(puppeteer)</strong> 的链接启动功能，通过默认的参数/或者自己穿进去的环境变量 等形式 可以唤起对应版本的浏览器实例来运行脚本。</p>\n</blockquote>\n<h4 id=\"preprocessors\">Preprocessors</h4>\n<ul>\n<li>karma-webpack</li>\n<li>karma-babel-preprocessor</li>\n</ul>\n<blockquote>\n<p>Preprocessors 顾名思义就是预处理器。很有可能你的单元测试代码是使用 ES6+的语法进行编写的，可能需要通过 babel 进行转译，或者根据 webpack 的配置 + 不同的 loader 进行转译，才能在运行中的浏览器示例上正常被解析执行。所以在一些 karma config options 里面能够看到类似下面的预处理流程：</p>\n<pre class=\"hljs\"><code>preprocessors: {\n     '/**/*.spec.js': ['webpack', 'sourcemap']\n},\n</code></pre>\n</blockquote>\n<h2 id=\"development-note\">Development Note</h2>\n<h3 id=\"concert-situations\">Concert &amp; Situations</h3>\n<p>在编写<code>karma-jawr</code>插件之前，我的设想需求，从编写单元测试代码的角度反向推导开之后，是这样一个流程：</p>\n<p><strong>jawr.properties</strong>(片段)</p>\n<pre class=\"hljs\"><code># JAWR Bundle Definitions\njawr.js.bundle.extJs.id=/jsBundles/extJs.js\njawr.js.bundle.extJs.composite=true\njawr.js.bundle.extJs.child.names=\\\n  extDebug,\\\n  extProd\n## ExtJS Debug Source\njawr.js.bundle.extDebug.debugonly=true\njawr.js.bundle.extDebug.mappings=/js/vendor/ext/ext-base-debug.js, /js/vendor/ext/ext-all-debug-w-comments.js\n## Home Page Application JS Bundles\njawr.js.bundle.home.id=/jsBundles/home.js\njawr.js.bundle.home.composite=true\njawr.js.bundle.home.child.names=homeStore, homeUi, homeImpl\n</code></pre>\n<p><strong>xxx.xhtml</strong></p>\n<pre class=\"hljs\"><code><span class=\"xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span> <span class=\"hljs-meta-keyword\">PUBLIC</span> <span class=\"hljs-meta-string\">\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span>\n  <span class=\"hljs-meta-string\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">xmlns:jawr</span>=<span class=\"hljs-string\">\"https://jawr.java.net/jsf/facelets\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Karma Jawr Sample Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"shortcut icon\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"${pageContext.request.contextPath}/images/icons/favicon.png\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"image/x-icon\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jawr:style</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/cssBundles/ext.css\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jawr:script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/jsBundles/extJs.js\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jawr:script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/jsBundles/home.js\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\">\n  Ext.onReady(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    Ext.QuickTips.init();\n    <span class=\"hljs-keyword\">new</span> karma.jawr.sample.app.Home({\n      <span class=\"hljs-attr\">renderTo</span>: Ext.getBody()\n    });\n  });\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n\n</span></code></pre>\n<p><strong>xxx.spec.js</strong>(片段)</p>\n<pre class=\"hljs\"><code>require('@/jsBundles/extJs.js');\nrequire('@/jsBundles/home.js');\n\ndescribe('ext', function() {\n  it('# check extjs is loaded', function() {\n    var expectExtVersion = '3.3.1';\n    expect(Ext.version).to.eq(expectExtVersion);\n  });\n\n  it('# expect home ui is rendered', function() {\n    expect(Ext.getCmp('app.home')).not.to.eq(undefined);\n  });\n});\n\n</code></pre>\n<p>在进行测试的流程里面</p>\n<p>首先单元测试文件经过 preprocessor 的处理，能够把<code>require('@/jsBundles/extJs.js')</code> 正确根据<code>jawr.properties</code>的配置内容加载 extjs <s>这里且不说 extjs 本身的代码是否支持 umd 形式的 export</s> 接着在浏览器执行的时候的 html 引入的时候，已经是能够被浏览器正确识别的，转译后的代码。</p>\n<p>所以从流程上，结合已有的插件，列出了从后到前的顺序点：</p>\n<ul>\n<li>编写 BDD 形式的单元测试文件，通过 require/import + jawr bundle id 导入对应的业务代码依赖</li>\n<li>经过 webpack 转译成可被浏览器识别的代码</li>\n<li>在 karma 启动时的 client html 中通过 mocha 执行所有测试用例</li>\n</ul>\n<h3 id=\"design\">Design</h3>\n<p>那么主要的问题就在于，如何使得测试文件中的 <code>require('@/jsBundles/home.js');</code> 能够正确根据 jawr 的配置 反向引导对应的源代码呢？</p>\n<p>除此之外，还有一些 jawr+spring 国际化本身的一些实现，如何根据对应的国际化文件，生成那些全局，执行后返回对应语言版本国际化变量呢?</p>\n<p>对于第一步，目前设计的解决方案是如下：</p>\n<p><strong>第一步:</strong> 给<code>karma.conf.js</code> 提供一个额外的 options field: jawr 主要是提供一些 jawr 相关配置文件的绝对路径</p>\n<p>目前我给他设置了一个 type-definition</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">interface</span> JawrOptions {\n  configLocation: <span class=\"hljs-built_in\">string</span>;\n  webappLocation: <span class=\"hljs-built_in\">string</span>;\n  targetLocation: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-comment\">// optional locale config location for jawr i18n generator</span>\n  localeConfigLocation?: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p>实际上的使用大概是这样: karma.confg.js</p>\n<pre class=\"hljs\"><code>module.exports = function(config){\n\tconfig.set({\n\t\t/*....*/\n\t\tjawr: {\n\t      configLocation: pathUtil.resolve('src/main/resources/jawr/') + 'jawr.properties',\n\t      webappLocation: pathUtil.resolve('src/main/webapp'),\n\t      targetLocation: pathUtil.resolve('src/test/js/build'),\n\t      localeConfigLocation: pathUtil.resolve('src/main/resources')\n\t    },\n\t})\n}\n</code></pre>\n<p>里面需要知道的是:</p>\n<ul>\n<li>jawr.properties 的路径</li>\n<li>webapp 文件夹的路径(目的是为了定位 js,css 业务源代码的路径)</li>\n<li>生成的中间临时文件夹的路径: 根据 jawr 配置文件生成的实际路径的处于<code>*.spec.js</code>和源代码中间的临时 link 文件夹</li>\n<li>如果启用了可选的国际化模块，则需要填写国际化源代码文件的路径</li>\n</ul>\n<p><strong>第二步</strong> 根据 jawr 的 Java 源代码，使用 js 实现以下功能</p>\n<ul>\n<li>解析 jawr 配置文件，根据每个 bundle id 来查找到对应的源代码文件</li>\n<li>解析 i18n 配置文件，生成对应的全局变量行数</li>\n</ul>\n<p><strong>第三步</strong> 通过 karma 结合 webpack 做预处理器，结合<code>mocha</code>，<code>chai</code>，<code>sinon</code> 做基本的测试。</p>\n<h3 id=\"development-roadmap\">Development Roadmap</h3>\n<h4 id=\"local-testing\">Local Testing</h4>\n<p>如果没有了解 npm 加载模块机制和 karma 所使用的 di 约定的时候，可能本地测试必须依赖已经发布的 npm package.</p>\n<p>正确的做法应该是:</p>\n<p>在<strong>karma.conf.js</strong> 的 plugins 显式声明一个本地的引用该引用等同<code>package.json</code>里面<code>main</code>的指向</p>\n<pre class=\"hljs\"><code>plugins: [\n      'karma-chrome-launcher',\n      'karma-chai',\n      'karma-mocha',\n      'karma-spec-reporter',\n      'karma-coverage',\n      'karma-coverage-istanbul-reporter',\n      'karma-sourcemap-loader',\n      'karma-sinon',\n      'karma-webpack',\n      localJawrFramework //  ==&gt; var localJawrFramework = require('../../lib');\n    ],\n</code></pre>\n<p><strong>package.json</strong></p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"karma-jawr\"</span>,\n  <span class=\"hljs-attr\">\"main\"</span>: <span class=\"hljs-string\">\"lib/index.js\"</span>\n}\n</code></pre>\n<p><strong>lib/index.js</strong></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> frameworkLogger = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./logger'</span>);\n\n<span class=\"hljs-keyword\">var</span> jawrHandler = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./jawr.handler'</span>);\n\n<span class=\"hljs-comment\">/**\n * @param {Array} files: file pattern\n * @param {JawrOptions} jawrOptions: jawrOptions\n * @param {Object} logger: karma logger\n * */</span>\n<span class=\"hljs-keyword\">var</span> framework = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">files, jawrOptions, logger</span>) </span>{\n  frameworkLogger.initLogger(logger);\n  jawrHandler.handle(jawrOptions);\n};\n\nframework.$inject = [<span class=\"hljs-string\">'config.files'</span>, <span class=\"hljs-string\">'config.jawr'</span>, <span class=\"hljs-string\">'logger'</span>];\n<span class=\"hljs-built_in\">module</span>.exports = { <span class=\"hljs-string\">'framework:jawr'</span>: [<span class=\"hljs-string\">'factory'</span>, framework] };\n</code></pre>\n<h4 id=\"integrate-with-ci\">Integrate with CI</h4>\n<p>目前只有测试部分与<code>travis-ci</code>和<code>circleci</code>集成了。</p>\n<p><a href=\"https://circleci.com/gh/aquariuslt/karma-jawr\">circleci</a> <a href=\"https://travis-ci.org/aquariuslt/karma-jawr\">travis-ci</a></p>\n<h4 id=\"pre-release-and-testing\">Pre-Release and Testing</h4>\n<p>为了解决其他在实际应用中遇到的问题，包括但不限于各种</p>\n<ul>\n<li>jawr 配置的胡乱使用</li>\n<li>node.js 的 properties 解释实现并没有覆盖 properties 事实标准的所有情况</li>\n</ul>\n<p>等...我是自己维护了 issue 列表并且把每次修改的测试用例都加到本身的单元测试流程中</p>\n<p>目前详见<a href=\"https://github.com/aquariuslt/karma-jawr/issues\">issues</a></p>\n<p><s>有一个目前因为技术原因暂时被我 标记了 wont fix</s></p>\n<h2 id=\"references\">References</h2>\n<p><a href=\"https://github.com/aquariuslt/karma-jawr\">项目源代码 Repo</a></p>\n<p><a href=\"https://github.com/karma-runner/karma/raw/master/thesis.pdf\">Karma 作者的设计论文</a></p>\n<p><a href=\"http://taobaofed.org/blog/2016/01/08/karma-origin/\">Karma 测试框架的前世今生 - 淘宝 TED | Karma 作者论文译文</a></p>\n","disqus":{"shortname":"aquariuslt","url":"https://zexo.dev/posts/2018/04/01/karma-jawr-development-note","identifier":"-posts-2018-04-01-karma-jawr-development-note"}}}