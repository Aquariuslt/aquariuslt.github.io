{"key":"/","url":"https://zexo.dev/","path":"/home","title":"zexo.dev","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zexo.dev","name":"Home","position":1}]},"type":"LIST","metas":[{"name":"google-site-verification","content":"s3PYm0fCo0ImPqqXoPLiUb_bFdlYODKw54VGSkcFgyE"},{"id":"google-analytics","name":"google-analytics","content":"UA-68904127-2"},{"name":"description","itemprop":"description","content":"Home"},{"name":"og:site_name","content":"zexo.dev"},{"name":"og:type","content":"website"}],"data":[{"title":"管理你的 .ignore 类文件","id":"dot-ignore-management-for-npm-package","created":"2020-03-15T00:00:00.000Z","updated":"2020-03-15T00:00:00.000Z","categories":["Blog"],"tags":["Node","NPM","Git"],"cover":"/posts/2020/03/15/dot-ignore-management-for-npm-package/gitignore.png","summary":"每次初始化项目的时候，都根据 不同项目的语言、框架、IDE、一遍组合人工创建与合并 .gitignore 文件，比较麻烦。我经常在疑惑，是否有较为标准的 schematic 概念可以协助组装起来?比方说，我常用的 IDE 是 IntelliJ IDEA，偶尔使用 VSCode 看看日志、进行简单的编辑文本工作;\n","link":"/posts/2020/03/15/dot-ignore-management-for-npm-package"},{"title":"使用 renovate 监控第三方依赖更新","id":"keep-your-repo-dependencies-up-to-date-with-renovate","created":"2020-03-01T00:00:00.000Z","updated":"2020-03-01T00:00:00.000Z","categories":["Blog"],"tags":["Node","CI","NPM","Renovate","Github"],"cover":"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate/revonate.png","summary":"依赖更新管理曾一直是我容易纠结的一个问题。我希望一直保持我的仓库使用的第三方 package 一直能保持 安全情况下 的最新版本，随着最新版本的更新，一般伴随着以下几种用户关心的内容：fixing: 修复了一些 bugperformance tuning: 一些性能优化\n","link":"/posts/2020/03/01/keep-your-repo-dependencies-up-to-date-with-renovate"},{"title":"使用 Patch Package 魔改第三方NPM包","id":"using-patch-package-patching-node-modules","created":"2020-02-12T00:00:00.000Z","updated":"2020-02-12T00:00:00.000Z","categories":["Blog"],"tags":["Node","CI"],"cover":"/posts/2020/02/12/using-patch-package-patching-node-modules/cover.png","summary":"开源社区一直有一个做法(说法): 一言不合就 Fork。自古以来文人相轻，这些一言不合就 fork 的做法挺能体现这些现象的。目前看来，对于一个开源项目，我遇到的所谓的一言不合就 fork ，但不是以 fork 作为正常的工作流(也就是说后续不会往 origin repository 提交 Pull Request)，大致来自于以下几种原因：\n","link":"/posts/2020/02/12/using-patch-package-patching-node-modules"},{"title":"Year in Review 2019","id":"review-2019","created":"2020-01-28T00:00:00.000Z","updated":"2020-01-28T00:00:00.000Z","categories":["Blog"],"tags":["Diary"],"cover":"/posts/2020/01/28/review-2019/cover.png","summary":"新年伊始，适逢 2019-nCov 疫情，多了几天在家办公的时间。正好回顾下忙碌的 2019 年。19 年 4 月，得知房租将上涨后，找了一家新的房子，从步行上班距离的城中村搬到了骑车上班距离的远一点的空公寓。家具又是自己买了一番(虽然大出血但是内心自我感觉住宿品质回到了在珠海的时候)。\n","link":"/posts/2020/01/28/review-2019"},{"title":"Monorepo Practice in TypeScript Projects","id":"monorepo-practice-in-typescript-projects","created":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","categories":["Blog"],"tags":["NPM","CI","Typescript","Monorepo","Lerna","Jest"],"cover":"/posts/2019/11/14/monorepo-practice-in-typescript-projects/cover.png","summary":"随着 Node 生态社区的发展，越来越多的 Nodejs 代码仓库开始采用 Monorepo 的形式进行管理。我们可以看到一些前端 UI 框架、Web 框架，在新版本/一开始就采用了 monorepo 的形式管理代码。Q: 什么是 Monorepo? Monorepo 的基本好处是什么? A: 这里不多阐述，可以参考知乎上的这篇文章: https://zhuanlan.zhihu.com/p/31289463\n","link":"/posts/2019/11/14/monorepo-practice-in-typescript-projects"},{"title":"Github Actions: New YAML Syntax","id":"github-actions-new-yaml-syntax","created":"2019-08-18T00:00:00.000Z","updated":"2019-08-18T00:00:00.000Z","categories":["Blog"],"tags":["NPM","CI","Github","TravisCI","Actions","Docker"],"cover":"/posts/2019/08/18/github-actions-new-yaml-syntax/migrating-github-actions.png","summary":"在之前一篇博文里刚介绍完 Github Actions 配置的HCL语法不久，Github 官方就标记为 deprecated 了。原因是社区声音推崇他们使用新的 YAML 语法，这类的语法配置与现有的其他 CI 平台相对更加接近，更加容易举一反三写出合理的配置。\n","link":"/posts/2019/08/18/github-actions-new-yaml-syntax"},{"title":"Travel in Beijing","id":"travel-in-beijing","created":"2019-07-23T00:00:00.000Z","updated":"2019-07-23T00:00:00.000Z","categories":["Blog"],"tags":["Trips"],"cover":"/posts/2019/07/23/travel-in-beijing/palace-museum-01.png","summary":"毕业第四年后，终于有机会第一次旅行，目的地选择了北京。本次北京行采用的是语文课本童年回忆随缘踩点法，在打卡景点的同时，顺便会一下闻名已久的北京帮朋友。算上两天年假，一共有四天假期，周四晚上飞机，周一晚上回深圳。于是按照时间线来一发流水账，在总结下本次北京行的直观感受。\n","link":"/posts/2019/07/23/travel-in-beijing"},{"title":"Github Actions: Overview and Practice","id":"github-actions-overview-and-practice","created":"2019-07-07T00:00:00.000Z","updated":"2019-07-07T00:00:00.000Z","categories":["Blog"],"tags":["NPM","CI","Github","TravisCI","Actions","Docker"],"cover":"/posts/2019/07/07/github-actions-overview-and-practice/github-actions.png","summary":"Github Actions 自从开放 beta 以来，感觉一直没有掀起什么大浪。但是他的在 CI 平台插件方面的概念其实是符合一直以来的方向的: Docker Image as Plugins我在二月份开始已经申请到了 Github Actions Beta 的体验许可，为了体验 Github Actions 的功能，以及跟目前其他开源项目所用的持续集成平台进行简单的对比，下面将以一个 通过 Gtihub Action 发布 npm package 的过程作为初步体验，讲讲我对 Github Actions 在 CI 方面的认识。\n","link":"/posts/2019/07/07/github-actions-overview-and-practice"},{"title":"A Karma Plugin: Karma-JAWR Development Note","id":"karma-jawr-development-note","created":"2018-04-01T00:00:00.000Z","updated":"2018-04-01T00:00:00.000Z","categories":["Blog"],"tags":["Karma","Node","AngularJS","JavaScript","JAWR"],"cover":"/posts/2018/04/01/karma-jawr-development-note/cover.png","summary":"上一篇文章基于 Karma 的非分离式前端单元测试基础方案描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解jawr这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。\n","link":"/posts/2018/04/01/karma-jawr-development-note"},{"title":"基于Karma的非分离式前端单元测试基础方案","id":"karma-based-traditional-java-web-frontend-unittest-solution","created":"2018-03-04T00:00:00.000Z","updated":"2018-03-04T00:00:00.000Z","categories":["Blog"],"tags":["Java","JAWR","Karma","JavaScript","Webpack","ExtJS","Spring","JSF","SpringMVC"],"cover":"/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution/cover.png","summary":"TL;DR之前在为公司一个稍微有些年头的核心系统的代码寻找一个合理的单元测试方案，在摆弄了一段时间后，目前奠定了一个基于 Karma 的前端单元测试方案。如果你的项目符合以下条件，那么这个解决方案和其中的思路也许能对你的项目有点帮助。原本的项目与前端相关的部分属于 Java Web 项目，抛开与本次主题无关的部分，具体影响单元测试方案选型和落地的几个因素，我把他归结成几类：\n","link":"/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution"}]}