<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Aquariuslt Blog</title>
        <link>https://blog.aquariuslt.com</link>
        <description>Personal Blog | Coder | WoWer | On the way.</description>
        <lastBuildDate>Sat, 13 Jul 2019 19:10:25 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <copyright>copyright 2019 aquariuslt blog</copyright>
        <category>Blog</category>
        <category>Blog</category>
        <category>Blog</category>
        <category>Blog</category>
        <category>Others</category>
        <category>Blog</category>
        <category>Blog</category>
        <category>Others</category>
        <category>Blog</category>
        <category>Blog</category>
        <category>Note</category>
        <category>Note</category>
        <category>Blog</category>
        <category>Debug</category>
        <category>Debug</category>
        <category>Others</category>
        <category>Blog</category>
        <category>Debug</category>
        <category>Blog</category>
        <category>Blog</category>
        <category>Blog</category>
        <atom:link href="https://blog.aquariuslt.com//feed/atom" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Github Actions: Overview and Practice]]></title>
            <link>https://blog.aquariuslt.com/posts/2019/07/07/github-actions-overview-and-practice</link>
            <guid>https://blog.aquariuslt.com/posts/2019/07/07/github-actions-overview-and-practice</guid>
            <pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[Github Actions 自从开放 beta 以来，感觉一直没有掀起什么大浪。但是他的在 CI 平台插件方面的概念其实是符合一直以来的方向的: `Docker Image as Plugins`我]]></description>
            <content:encoded><![CDATA[<h1 id="github-actions-overview-and-practice">Github Actions: Overview and Practice</h1>
<h2 id="background">Background</h2>
<p>Github Actions 自从开放 beta 以来，感觉一直没有掀起什么大浪。但是他的在 CI 平台插件方面的概念其实是符合一直以来的方向的: <code>Docker Image as Plugins</code></p>
<p>我在二月份开始已经申请到了 Github Actions Beta 的体验许可，为了体验 Github Actions 的功能，以及跟目前其他开源项目所用的持续集成平台进行简单的对比，下面将以一个 通过 Gtihub Action 发布 npm package 的过程作为初步体验，讲讲我对 Github Actions 在 CI 方面的认识。</p>
<h2 id="before-reading">Before Reading</h2>
<p>再开始阅读之前，准备了一些截图，简要的从表现上了解下 Github Actions 的一些功能</p>
<ul>
<li>What is Github Actions</li>
<li>How workflow configuration look like</li>
<li>How workflow runtime look like</li>
</ul>
<h3 id="what-is-github-actions">What is Github Actions</h3>
<p>Github 官方介绍，简要的将就是 Github 官方提供的 CI 平台，其最大的特点便是插件化形式来进行CI Stages的组装。</p>
<blockquote>
<p>GitHub Actions allow you to implement custom logic without having to create an app to perform the task you need. You can combine GitHub Actions to create workflows using an action defined in your repository, a public repository on GitHub, or a published Docker container image. GitHub Actions are customizable and can use the GitHub API and any publicly available third-party APIs to interact with a repository. For example, an action can publish npm modules, send SMS alerts when urgent issues are created, or deploy production ready code. You can discover, create, and share your GitHub Actions with the GitHub community.</p>
</blockquote>
<p>先是官方带头在平台基础上创建了一些通用性比较高的、对标其他同类平台的一些主打功能，以一个封装好的 <code>Actions</code> 概念暴露出来，然后每个 Repository 便可使用这些官方预设的 <code>Actions</code> 来组装自己的 <code>Workflow</code> 。</p>
<p>官方 Actions 集合 <a href="https://github.com/actions">https://github.com/actions</a> 里找到官方维护的 actions. 常见的一些actions有:</p>
<ul>
<li>npm</li>
<li>docker</li>
<li>shell</li>
</ul>
<p><img src="https://img.aquariuslt.com/posts/2019/07/github-official-actions-repo.png" alt=""></p>
<p>当然也有很多非官方维护的 Actions，可以通过发布到 Github Marketplace 被查找到，也可以把Actions 构建成 <code>docker image</code> + <code>[entrypoints.sh](http://entrypoints.sh)</code> 的形式， 在项目 Workflow 的配置文件中以docker image 路径进行引用。</p>
<h3 id="how-configuration-look-like">How configuration look like</h3>
<p>如果有使用过 Travis-CI, CircleCI, Gitlab-CI 的经验，大概可以想起，对应的 CI 配置文件，大都通过 yml 作为基础语法，来描述整个 CI Pipeline 涉及的几个步骤。</p>
<p>在 Github Web界面中，对一个Repository 的 Workflow 进行可视化的编辑时，如下图:</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/workflow-editor-example.png" alt=""></p>
<p>实际上他背后也是一个配置文件，用这个配置文件来描述 workflow 的触发条件，步骤，以及每个步骤执行时的参数...  只不过 Github 官方提供了基于这个配置文件的在线可视化编辑，使得编辑过程比较容易直观。</p>
<p>关于配置文件的语法、编写形式，下面会以样例提及。</p>
<h3 id="how-workflow-runtime-look-like">How workflow runtime look like</h3>
<p>在 Github 界面上查看单个项目的 Workflow 下图这样子:</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/workflow-example.png" alt=""></p>
<p>这个 Workflow 比较直观的表示了一个基本的 <code>构建-发布</code> 流程:</p>
<ol>
<li>在 Github 收到 <code>push</code> 事件的时候，触发该 workflow</li>
<li>首先同时执行 <code>dockerlint</code> 和 <code>shelllint</code> 步骤</li>
<li>以上两步都通过后，根据项目的 dockerfile 构建 docker 镜像</li>
<li>对 docker 镜像进行多次打Tag (latest, timestamp)，同时判断是否需要进行发布(判断当前分支是否 master 分支)</li>
<li>使用 secrets 进行 docker login 步骤</li>
<li>调用 docker publish 对刚才打过 tag 的镜像 发布到官方的 docker registry 中去</li>
</ol>
<p>这样一看，对 Github Actions 和 Workflow 的界面表现形式有了一个模糊的了解。基于其他 CI 平台的使用经验，大概可以想象自己目前的 CI Pipeline 转移到 Github Actions 上，表现出来会是怎样一个形式。</p>
<h2 id="example-project">Example Project</h2>
<p>现在介绍用来做样例的项目。</p>
<p>这是一个 npm package，已经发布到 npm 上。</p>
<p>npm地址: <a href="https://www.npmjs.com/package/jest-properties-loader">https://www.npmjs.com/package/jest-properties-loader</a></p>
<p>github地址: <a href="https://github.com/aquariuslt/jest-properties-loader">https://github.com/aquariuslt/jest-properties-loader</a></p>
<p>现在我们来了解下:</p>
<ul>
<li>项目目录结构</li>
<li>本地发布前、发布时，一般要做什么步骤</li>
</ul>
<p>接着在下一章介绍，如果通过 Travis-CI 或者 CircleCI 进行 持续构建和自动触发发布，一般的思路和实现方式。</p>
<p>最后再简介如何通过 Github Actions 实现同样的功能。</p>
<h3 id="project-overview">Project Overview</h3>
<p>这个 npm package 的作用，主要是为 jest 提供一个 <code>.properties</code> 文件的 json 格式转换。</p>
<p>不过其实我们不需要了解他的作用，仅仅把他当做一个普通的 public npm package吧。</p>
<p>项目的文件结构如下:</p>
<pre><code>├── LICENSE
├── README.md
├── lib
│   └── index.js
├── package.json
├── test
│   ├── __fixtures__
│   │   └── sample.properties
│   └── loader.test.js
└── yarn.lock
</code></pre>
<h3 id="manual-release-flow">Manual Release Flow</h3>
<p><strong>Running Tests</strong></p>
<p>当我们准备发布一个新版本时，先通过测试</p>
<pre><code class="hljs bash">yarn <span class="hljs-built_in">test</span>
</code></pre>
<p><strong>Build Distribution (Optional)</strong></p>
<p>如果项目需要构建，则需要有类似 <code>build</code> 的一步。</p>
<p>不过这个项目，我直接以可直接运行的 commonjs 的语法进行编写，所以省去了这一步。</p>
<p>Update Version</p>
<p>发布前，我们需要更新仓库版本号，遵循 <code>semantic versioning</code> 的原则，进行代码版本号更新。</p>
<pre><code class="hljs bash">yarn version
</code></pre>
<p>Login NPM</p>
<p>现在一切就绪，我们准备进行npm package发布。</p>
<p>一种方式是通过 <code>npm login</code> 命令 进行发布, 然后输入npm用户名和密码</p>
<pre><code class="hljs bash">npm login
</code></pre>
<p>当然也有另外一种 npm 推荐的方式，那边是使用使用 NPM 的 <a href="https://docs.npmjs.com/about-authentication-tokens">Auth Token</a> 进行验证。</p>
<p>参考链接中的步骤创建好一个 Auth Token 后，将其释放在 <code>.npmrc</code> 文件内</p>
<pre><code class="hljs bash"><span class="hljs-built_in">export</span> NPM_TOKEN=<span class="hljs-string">"00000000-0000-0000-0000-000000000000"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"//registry.npmjs.org/:_authToken=<span class="hljs-variable">${NPM_TOKEN}</span>"</span> &gt;&gt; .npmrc
</code></pre>
<p>参考文章: <a href="https://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules">https://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules</a></p>
<p><strong>NPM Publish</strong></p>
<pre><code class="hljs bash">npm publish
</code></pre>
<p>至此，我们便手动的将一个 npm package 的新版本发布到 npm registry 了。</p>
<h2 id="existing-ci-cd-flow">Existing CI CD Flow</h2>
<p>现在我们看看如果是 Travis CI 进行自动构建 npm 包发布是怎么做呢</p>
<p>Travis CI 的 Example 样例如下:</p>
<pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span>
<span class="hljs-attr">node_js:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">"10"</span>

<span class="hljs-attr">script:</span> <span class="hljs-string">npm</span> <span class="hljs-string">test</span>

<span class="hljs-comment"># Submit Coverage Status to coveralls.io</span>
<span class="hljs-attr">after_script:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">cat</span> <span class="hljs-string">./test/coverage/lcov.info</span> <span class="hljs-string">| ./node_modules/.bin/coveralls


</span><span class="hljs-attr">deploy:</span>
<span class="hljs-attr">  provider:</span> <span class="hljs-string">npm</span>
<span class="hljs-attr">  email:</span> <span class="hljs-string">$NPM_AUTH_EMAIL</span>
<span class="hljs-attr">  api_key:</span> <span class="hljs-string">$NPM_AUTH_TOKEN</span>
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    tags:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">    branch:</span> <span class="hljs-string">release</span>
</code></pre>
<p>具体点讲，这份配置文件关于自动发布 npm package 的过程便是</p>
<ol>
<li>触发条件: 当触发 travis-ci 的 webhooks 是 <code>tags</code> 而且 分支名为 <code>release</code>  时，触发此deploy操作。</li>
<li>使用 travis-ci 提供的 <a href="https://docs.travis-ci.com/user/deployment/npm/">https://docs.travis-ci.com/user/deployment/npm/</a>  <code>npm release provider</code>  配合 github secret <code>$NPM_AUTH_TOKEN</code> 进行发布。( token 为上一部分介绍的 npm token)</li>
</ol>
<p>配置过程相当简洁，唯一一点是 npm publish 过程并不透明，我们无法知道 travis ci 的具体实现。</p>
<h2 id="introducing-github-actions-solution">Introducing Github Actions Solution</h2>
<p>现在开始介绍我如何使用 Github Actions 构建一个workflow，来进行npm package的发布。</p>
<p>下面介绍理想中的思路，然后拆分开来讲讲我是如何实现的。</p>
<h3 id="release-flow-design-based-on-github-actions">Release flow design based on Github Actions</h3>
<p>在理想的设计里，基本遵循两部分操作:</p>
<ol>
<li>每次提交代码 (<code>push event</code>)，触发基本的 build &amp; test pipeline</li>
<li>每次准备发布新版本的时候，通过 <code>yarn version</code> 给即将发布的 npm package 版本迭代版本号，此操作不仅会更新 <code>package.json</code> 中的版本，还会给这个更新版本的 commit 自动打上一个tag</li>
<li>需要发布的时候，在 Repository 的 Github 主页中，从新版本中的 tag 创建一个新的 release。
这个 <code>release event</code> 会触发 release pipeline，执行发布新版本的操作。</li>
</ol>
<h3 id="create-a-workflow-file">Create a workflow file</h3>
<p>按照 Github Actions 的约定，我们需要在 Repository 根目录的 <code>.github</code> 目录下，创建一个 <code>main.workflow</code> 文件。Github 将会以 <code>.github/main.workflow</code> 作为 workflow 的入口配置文件。</p>
<p><code>.workflow</code> 文件是 Github Workflow 的文件名后缀，其语法为 <code>hcl</code> 。</p>
<p>hcl 全称 <strong>HashiCorp Configuration Language</strong>，其具体的语法规则比较容易明白，实际上可以快速的以 <code>json</code>,  <code>yml</code> 的概念去理解他。</p>
<p>Tips: 如果平时使用 IntelliJ IDEA 进行开发，那么可以通过给 <code>.workflow</code> 添加语法支持，将其识别为 <code>HCL</code> 语法，即可获得高亮与格式化</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/workflow-syntax-highlight.png" alt=""></p>
<p>为了实现基本操作中的第一部分: 每次提交代码时，触发基本的 build &amp; test pipeline</p>
<p>我在 <code>main.workflow</code> 中声明 <code>build &amp; test</code> 的 pipeline。</p>
<p>这里为了方便，我使用了 <code>workflow/ci</code> 作为他的简称。</p>
<pre><code class="hljs hcl">workflow &quot;workflow/ci&quot; {
  on = &quot;push&quot;
  resolves = [&quot;test&quot;]
}

action &quot;install&quot; {
  uses = &quot;actions/npm@master&quot;
  runs = &quot;yarn&quot;
}

action &quot;test&quot; {
  uses = &quot;actions/npm@master&quot;
  needs = [&quot;install&quot;]
  runs = &quot;yarn&quot;
  args = &quot;test&quot;
}
</code></pre>
<p>以上代码块，声明了一个 <code>workflow</code> 和两个 <code>actions</code> 。</p>
<p>以 workflow 作为入口，actions 里的 <code>resolves</code> 和 <code>needs</code> 作为依赖指向，可以生成有向无环图来描述这个构建流程。</p>
<p>其实际可以理解为：</p>
<ol>
<li>当触发了 github repository 的 push event 的时候，执行该名为 <code>workflow/ci</code>  的 workflow</li>
<li><code>workflow/ci</code> 实际上只要执行名为 <code>test</code> 的action，所以会从整个配置文件里，查找 action = <code>test</code> 的 action 并执行。</li>
<li>当准备执行 <code>test</code> actions之前，检查他的 <code>needs</code> 部分，哦原来执行 <code>test</code> 之前，还要先执行一个 <code>install</code> 的action。那么现在需要按顺序执行 <code>install</code> <code>test</code> 这两个actions</li>
</ol>
<p>我们开始看 <code>install</code>.</p>
<p><code>install</code> 的内容，便是执行 <code>yarn</code> 这个命令，来安装依赖，那么这个 <code>uses</code> 何解?</p>
<p><code>uses</code> 实际指向了一个 github actions 的名字，现在名为 <code>actions/npm@master</code> ，那么他会从 <code>[https://github.com/actions/npm](https://github.com/actions/npm)</code> 的 master 分支下，查找 <code>Dockerfile</code> ，构建出一个docker 镜像，并且使用该docker 镜像，执行 <code>runs</code> 和 <code>args</code> 下的命令操作，对工作目录(workspace)进行更变。</p>
<p>说白了，这就是在一个有 <code>npm</code> 环境下执行 <code>yarn</code> 的一个操作，来安装依赖。</p>
<p>至于如何理解 Github Actions 本身的基础运作，可能需要单独开启一篇进行讲解。</p>
<p>现在再看 <code>test</code></p>
<p>说白了，就是在已安装了node依赖的工作目录下，执行 <code>yarn test</code> 命令</p>
<p>所以每当触发 Github 的 push event之后，我们可以在 Github Actions 流程里看到 <code>workflow/ci</code> 的执行。</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/workflow-ci-overview.png" alt=""></p>
<h3 id="add-publish-workflow">Add Publish workflow</h3>
<p>现在我们来添加一个名为 <code>release</code> 的workflow。在 <code>main.workflow</code> 下追加如下内容:</p>
<pre><code class="hljs hcl">workflow &quot;release&quot; {
  on = &quot;release&quot;
  resolves = [&quot;npm:release&quot;]
}

action &quot;filter:release&quot; {
  uses = &quot;actions/bin/filter@master&quot;
  args = &quot;action created*&quot;
}


action &quot;npm:release&quot; {
  needs = &quot;filter:release&quot;
  uses = &quot;actions/npm@master&quot;
  secrets = [&quot;NPM_AUTH_TOKEN&quot;]
  args = &quot;publish&quot;
}
</code></pre>
<p>里面的内容大概如下:</p>
<ol>
<li>当收到 github 的 release event 时，触发此操作。(通常是在 Repository 主页的 Release 一栏，创建或更新 新版本 release 时触发的 event)</li>
<li>在执行真正的 npm publish 操作之前，先使用一个名为 <code>filter: release</code> 的 action，判断是否真正的需要执行publish。</li>
<li>我们使用 github 官方的提供的 <code>actions/npm</code> ， npm 环境，传入一个 <code>NPM_AUTH_TOKEN</code>  的环境变量，然后执行 <code>npm publish</code>  命令进行发布。</li>
</ol>
<p>现在，我们在 github release 页面创建一个新 release 时</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/create-release.png" alt=""></p>
<p>将会触发 <code>npm:release</code> workflow：</p>
<p><img src="https://img.aquariuslt.com/posts/2019/07/trigger-release-workflow.png" alt=""></p>
<p>接着可以看到如下 detail  log， 详见 <a href="https://github.com/aquariuslt/jest-properties-loader/runs/163050939">https://github.com/aquariuslt/jest-properties-loader/runs/163050939</a></p>
<pre><code>Successfully built fbc21be41b97
Successfully tagged gcr.io/gct-12-lnx0cl9uvvzo-abntpgke1w/484654f7adf6911ca799c01d40b80af4456b46c3418f33934c643ccc7f245f38/8a5edab282632443219e051e4ade2d1d5bbc671c781051bf1437897cbdfea0f1:fc613b4dfd6736a7bd268c8a0e74ed0d1c04a959f59dd74ef2874983fd443fc9
Already have image (with digest): gcr.io/github-actions-images/action-runner:latest
npm notice 
npm notice package: jest-properties-loader@1.0.3
npm notice === Tarball Contents === 
npm notice 764B  package.json                       
npm notice 1.1kB LICENSE                            
npm notice 325B  README.md                          
npm notice 531B  .github/main.workflow              
npm notice 200B  lib/index.js                       
npm notice 15B   test/__fixtures__/sample.properties
npm notice 547B  test/loader.test.js                
npm notice === Tarball Details === 
npm notice name:          jest-properties-loader                  
npm notice version:       1.0.3                                   
npm notice package size:  2.0 kB                                  
npm notice unpacked size: 3.4 kB                                  
npm notice shasum:        dc929c7b12c0bf8e57f100f8cfb95be26fe9464e
npm notice integrity:     sha512-dhmq60thri/8x[...]HG4ITr5zZ8fIw==
npm notice total files:   7                                       
+ jest-properties-loader@1.0.3
npm notice

### SUCCEEDED npm:release 14:18:26Z (16.054s)
</code></pre>
<p>至此，新版本的 <code>jest-properties-loader</code> 已发发布到 npm 中。</p>
<p><strong>为什么第二步中，我需要做这样一个 filter 呢?</strong></p>
<p>答: 因为按照 Github 的 event 列表，在 web 页面上创建一个新 release，会同时触发两个 release 事件: <code>release: created</code> 和 <code>release: published</code> 。当这两个 release 事件都触发这个 workflow的时候，一旦其中一个 <code>npm publish</code> 命令成功发布新版本的包之后， 另外一个在执行发布操作时，就会返回一个 <strong>版本已存在</strong> 的错误，导致整个 commit status 是失败的。</p>
<p>所以我通过 github 官方的 <code>bin/filter</code> action来进行触发事件的过滤，保证同一次界面上的 <code>release</code> 操作只会执行一次 <code>npm publish</code> .</p>
<p><strong>为什么在使用 <code>actions/npm</code> 时，传递一个 $NPM_AUTH_TOKEN secret 变量即可进行发布?</strong></p>
<p>看上去跟之前提及的 &quot;创建好一个 Auth Token 后，将其释放在 <code>.npmrc</code> 文件内&quot; 似乎不太一样?</p>
<p>这是因为 <code>actions/npm</code> 的 entrypoint.sh 文件，就是做了这样一部环境变量的判断。约定为 <code>$NPM_AUTH_TOKEN</code> 时，便将其写入到 <code>.npmrc</code>  文件中。</p>
<p><a href="http://entrypoints.sh">entrypoints.sh</a> 文件大致如下，详见  <a href="https://github.com/actions/npm/blob/master/entrypoint.sh">https://github.com/actions/npm/blob/master/entrypoint.sh</a></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh
</span>
<span class="hljs-built_in">set</span> -e

<span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$NPM_AUTH_TOKEN</span>"</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-comment"># Respect NPM_CONFIG_USERCONFIG if it is provided, default to $HOME/.npmrc</span>
  NPM_CONFIG_USERCONFIG=<span class="hljs-string">"<span class="hljs-variable">${NPM_CONFIG_USERCONFIG-"$HOME/.npmrc"}</span>"</span>
  NPM_REGISTRY_URL=<span class="hljs-string">"<span class="hljs-variable">${NPM_REGISTRY_URL-registry.npmjs.org}</span>"</span>
  NPM_STRICT_SSL=<span class="hljs-string">"<span class="hljs-variable">${NPM_STRICT_SSL-true}</span>"</span>
  NPM_REGISTRY_SCHEME=<span class="hljs-string">"https"</span>
  <span class="hljs-keyword">if</span> ! <span class="hljs-variable">$NPM_STRICT_SSL</span>
  <span class="hljs-keyword">then</span>
    NPM_REGISTRY_SCHEME=<span class="hljs-string">"http"</span>
  <span class="hljs-keyword">fi</span>

  <span class="hljs-comment"># Allow registry.npmjs.org to be overridden with an environment variable</span>
  <span class="hljs-built_in">printf</span> <span class="hljs-string">"//%s/:_authToken=%s\\nregistry=%s\\nstrict-ssl=%s"</span> <span class="hljs-string">"<span class="hljs-variable">$NPM_REGISTRY_URL</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$NPM_AUTH_TOKEN</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${NPM_REGISTRY_SCHEME}</span>://<span class="hljs-variable">$NPM_REGISTRY_URL</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${NPM_STRICT_SSL}</span>"</span> &gt; <span class="hljs-string">"<span class="hljs-variable">$NPM_CONFIG_USERCONFIG</span>"</span>

  chmod 0600 <span class="hljs-string">"<span class="hljs-variable">$NPM_CONFIG_USERCONFIG</span>"</span>
<span class="hljs-keyword">fi</span>

sh -c <span class="hljs-string">"npm $*"</span>
</code></pre>
<h2 id="finally">Finally</h2>
<p>最后总结，通过本次 Github Actions 的实践，大致了解了:</p>
<ul>
<li>Github Actions 的基本概念</li>
<li>Workflow 的基本组成，配置概念及其运行表象</li>
<li>Travis CI Pipeline 对应的 Github Actions</li>
<li>如何通过 Github Actions 自动发布 NPM Package</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Github Actions Official Document - <a href="https://developer.github.com/actions/">https://developer.github.com/actions/</a></li>
<li>Github Actions Marketplace - <a href="https://github.com/marketplace">https://github.com/marketplace</a></li>
<li>Creating a workflow with github actions - <a href="https://help.github.com/en/articles/creating-a-workflow-with-github-actions">https://help.github.com/en/articles/creating-a-workflow-with-github-actions</a></li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li>Automate your NPM publish with GitHub Actions - <a href="https://medium.com/faun/automate-your-npm-publish-with-github-actions-dfe8059645dd">https://medium.com/faun/automate-your-npm-publish-with-github-actions-dfe8059645dd</a></li>
<li>HCL (HashiCorp  Configuration Language) - <a href="https://github.com/hashicorp/hcl">https://github.com/hashicorp/hcl</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://img.aquariuslt.com/posts/2019/07/github-actions.png"/>
        </item>
        <item>
            <title><![CDATA[A Karma Plugin: Karma-JAWR Development Note]]></title>
            <link>https://blog.aquariuslt.com/posts/2018/04/01/karma-jawr-development-note</link>
            <guid>https://blog.aquariuslt.com/posts/2018/04/01/karma-jawr-development-note</guid>
            <pubDate>Sun, 01 Apr 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[上一篇文章**基于 Karma 的非分离式前端单元测试基础方案**描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。在总结开发这个 karma 插件的笔记的时]]></description>
            <content:encoded><![CDATA[<h1 id="基于-karma-的非分离式前端单元测试基础方案">基于 Karma 的非分离式前端单元测试基础方案</h1>
<h2 id="background">Background</h2>
<h3 id="why">Why</h3>
<p>上一篇文章<strong>基于 Karma 的非分离式前端单元测试基础方案</strong>描述了在拆分基于 JAWR 的，前后端的方案的时候，无可避免的为中间编写一个插件的背景故事。</p>
<h2 id="knowledge-base">Knowledge Base</h2>
<p>在总结开发这个 karma 插件的笔记的时候，最终目的并不是希望读这篇文章的童鞋了解<code>jawr</code>这个插件所解决的核心问题，更多的是介绍 karma 和 karma 插件的设计理念，稍微对 karma 这个 test-runner 有一个更好的印象；亦或是在前端单元测试框架选型/亦或是根据实际项目需要，为了使得项目可被测试，无可避免的做出比较多的修改的时候，能够遵循这种插件开发的约定，使得项目测试方面更好的走向工程化。</p>
<h3 id="history-node-di-angularjs-and-karma">History: node-di, angular.js and karma</h3>
<p>在介绍整个问题之前，无可避免的先介绍一下<strong>karma</strong>的一些背景。</p>
<p>如果曾经接触过 angular.js 相关项目的开发，那就一定需要了解一下 angular.js 的依赖注入机制相关知识。</p>
<p>angular.js v1 的依赖注入机制及其实现呢，其实就是来自于<code>node-di</code>的实现(后来 DEPRECATED 并迁移到<code>angular/di.js</code>，虽然后面 angular v2+也并没有使用这个实现)。而<code>node-di</code>，<code>angular.js v1</code>，和<code>karma</code>中的依赖注入实现的主要作者都是同一位大神: <a href="https://github.com/vojtajina">vojtajina</a></p>
<p>所以我们可以看到在根据获取依赖的时候的一些类似的语法，诸如<code>$inject</code>等。</p>
<p>所以一旦你看过一些其他的 karma 相关的 framework 的源代码，大概就知道要如何起手了去看了，起码你能够从一些基本的 ioc 设计原则上知道 karma 如何加载相关插件，等等。</p>
<h3 id="karma-plugin-types">Karma Plugin Types</h3>
<p>在 karma 的官方文档的<a href="https://karma-runner.github.io/2.0/dev/plugins.html">plugins 页面</a>，提供了 karma 不同类型的插件及其常见列表。(其中很大部分是 karma 团队自己维护的，有一个官方的参考对象)。</p>
<p>这里转贴一部分常见的不同几个类型。</p>
<h4 id="frameworks">Frameworks</h4>
<ul>
<li>karma-jasmine</li>
<li>karma-mocha</li>
<li>karma-requirejs</li>
</ul>
<blockquote>
<p>karma frameworks 类型比较杂，功能可能是覆盖所有下面多种情况的一种或者多种</p>
</blockquote>
<h4 id="reporters">Reporters</h4>
<ul>
<li>karma-junit-reporter</li>
<li>karma-coverage-istanbul-reporter</li>
</ul>
<blockquote>
<p>karma reporters 常见的功能是在 karma 运行完测试流程之后，根据测试过程记录下的各种记录文件，生成覆盖率，测试用例列表等报告的功能。</p>
</blockquote>
<h4 id="launchers">Launchers</h4>
<ul>
<li>karma-chrome-launcher</li>
<li>karma-firefox-launcher</li>
</ul>
<blockquote>
<p>karma launcher 的功能就是提供给你启动所有位于系统中的浏览器的链接功能。比如出场率相当高的 karma-chrome-launcher 就实现了各个系统的 <strong>Chrome</strong>，<strong>Chromium</strong>，<strong>Chrome Dev</strong>，<strong>Headless Chrome(puppeteer)</strong> 的链接启动功能，通过默认的参数/或者自己穿进去的环境变量 等形式 可以唤起对应版本的浏览器实例来运行脚本。</p>
</blockquote>
<h4 id="preprocessors">Preprocessors</h4>
<ul>
<li>karma-webpack</li>
<li>karma-babel-preprocessor</li>
</ul>
<blockquote>
<p>Preprocessors 顾名思义就是预处理器。很有可能你的单元测试代码是使用 ES6+的语法进行编写的，可能需要通过 babel 进行转译，或者根据 webpack 的配置 + 不同的 loader 进行转译，才能在运行中的浏览器示例上正常被解析执行。所以在一些 karma config options 里面能够看到类似下面的预处理流程：</p>
<pre><code>preprocessors: {
     '/**/*.spec.js': ['webpack', 'sourcemap']
},
</code></pre>
</blockquote>
<h2 id="development-note">Development Note</h2>
<h3 id="concert-situations">Concert &amp; Situations</h3>
<p>在编写<code>karma-jawr</code>插件之前，我的设想需求，从编写单元测试代码的角度反向推导开之后，是这样一个流程：</p>
<p><strong>jawr.properties</strong>(片段)</p>
<pre><code># JAWR Bundle Definitions
jawr.js.bundle.extJs.id=/jsBundles/extJs.js
jawr.js.bundle.extJs.composite=true
jawr.js.bundle.extJs.child.names=\
  extDebug,\
  extProd
## ExtJS Debug Source
jawr.js.bundle.extDebug.debugonly=true
jawr.js.bundle.extDebug.mappings=/js/vendor/ext/ext-base-debug.js, /js/vendor/ext/ext-all-debug-w-comments.js
## Home Page Application JS Bundles
jawr.js.bundle.home.id=/jsBundles/home.js
jawr.js.bundle.home.composite=true
jawr.js.bundle.home.child.names=homeStore, homeUi, homeImpl
</code></pre>
<p><strong>xxx.xhtml</strong></p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:jawr</span>=<span class="hljs-string">"https://jawr.java.net/jsf/facelets"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Karma Jawr Sample Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"${pageContext.request.contextPath}/images/icons/favicon.png"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/x-icon"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">jawr:style</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/cssBundles/ext.css"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">jawr:script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/jsBundles/extJs.js"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">jawr:script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/jsBundles/home.js"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">
  Ext.onReady(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    Ext.QuickTips.init();
    <span class="hljs-keyword">new</span> karma.jawr.sample.app.Home({
      renderTo: Ext.getBody()
    });
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</span></code></pre>
<p><strong>xxx.spec.js</strong>(片段)</p>
<pre><code>require('@/jsBundles/extJs.js');
require('@/jsBundles/home.js');

describe('ext', function() {
  it('# check extjs is loaded', function() {
    var expectExtVersion = '3.3.1';
    expect(Ext.version).to.eq(expectExtVersion);
  });

  it('# expect home ui is rendered', function() {
    expect(Ext.getCmp('app.home')).not.to.eq(undefined);
  });
});

</code></pre>
<p>在进行测试的流程里面</p>
<p>首先单元测试文件经过 preprocessor 的处理，能够把<code>require('@/jsBundles/extJs.js')</code> 正确根据<code>jawr.properties</code>的配置内容加载 extjs <s>这里且不说 extjs 本身的代码是否支持 umd 形式的 export</s> 接着在浏览器执行的时候的 html 引入的时候，已经是能够被浏览器正确识别的，转译后的代码。</p>
<p>所以从流程上，结合已有的插件，列出了从后到前的顺序点：</p>
<ul>
<li>编写 BDD 形式的单元测试文件，通过 require/import + jawr bundle id 导入对应的业务代码依赖</li>
<li>经过 webpack 转译成可被浏览器识别的代码</li>
<li>在 karma 启动时的 client html 中通过 mocha 执行所有测试用例</li>
</ul>
<h3 id="design">Design</h3>
<p>那么主要的问题就在于，如何使得测试文件中的 <code>require('@/jsBundles/home.js');</code> 能够正确根据 jawr 的配置 反向引导对应的源代码呢？</p>
<p>除此之外，还有一些 jawr+spring 国际化本身的一些实现，如何根据对应的国际化文件，生成那些全局，执行后返回对应语言版本国际化变量呢?</p>
<p>对于第一步，目前设计的解决方案是如下：</p>
<p><strong>第一步:</strong> 给<code>karma.conf.js</code> 提供一个额外的 options field: jawr 主要是提供一些 jawr 相关配置文件的绝对路径</p>
<p>目前我给他设置了一个 type-definition</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> JawrOptions {
  configLocation: <span class="hljs-built_in">string</span>;
  webappLocation: <span class="hljs-built_in">string</span>;
  targetLocation: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// optional locale config location for jawr i18n generator</span>
  localeConfigLocation?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>实际上的使用大概是这样: karma.confg.js</p>
<pre><code>module.exports = function(config){
	config.set({
		/*....*/
		jawr: {
	      configLocation: pathUtil.resolve('src/main/resources/jawr/') + 'jawr.properties',
	      webappLocation: pathUtil.resolve('src/main/webapp'),
	      targetLocation: pathUtil.resolve('src/test/js/build'),
	      localeConfigLocation: pathUtil.resolve('src/main/resources')
	    },
	})
}
</code></pre>
<p>里面需要知道的是:</p>
<ul>
<li>jawr.properties 的路径</li>
<li>webapp 文件夹的路径(目的是为了定位 js,css 业务源代码的路径)</li>
<li>生成的中间临时文件夹的路径: 根据 jawr 配置文件生成的实际路径的处于<code>*.spec.js</code>和源代码中间的临时 link 文件夹</li>
<li>如果启用了可选的国际化模块，则需要填写国际化源代码文件的路径</li>
</ul>
<p><strong>第二步</strong> 根据 jawr 的 Java 源代码，使用 js 实现以下功能</p>
<ul>
<li>解析 jawr 配置文件，根据每个 bundle id 来查找到对应的源代码文件</li>
<li>解析 i18n 配置文件，生成对应的全局变量行数</li>
</ul>
<p><strong>第三步</strong> 通过 karma 结合 webpack 做预处理器，结合<code>mocha</code>，<code>chai</code>，<code>sinon</code> 做基本的测试。</p>
<h3 id="development-roadmap">Development Roadmap</h3>
<h4 id="local-testing">Local Testing</h4>
<p>如果没有了解 npm 加载模块机制和 karma 所使用的 di 约定的时候，可能本地测试必须依赖已经发布的 npm package.</p>
<p>正确的做法应该是:</p>
<p>在<strong>karma.conf.js</strong> 的 plugins 显式声明一个本地的引用该引用等同<code>package.json</code>里面<code>main</code>的指向</p>
<pre><code>plugins: [
      'karma-chrome-launcher',
      'karma-chai',
      'karma-mocha',
      'karma-spec-reporter',
      'karma-coverage',
      'karma-coverage-istanbul-reporter',
      'karma-sourcemap-loader',
      'karma-sinon',
      'karma-webpack',
      localJawrFramework //  ==&gt; var localJawrFramework = require('../../lib');
    ],
</code></pre>
<p><strong>package.json</strong></p>
<pre><code class="hljs json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"karma-jawr"</span>,
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"lib/index.js"</span>
}
</code></pre>
<p><strong>lib/index.js</strong></p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> frameworkLogger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>);

<span class="hljs-keyword">var</span> jawrHandler = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./jawr.handler'</span>);

<span class="hljs-comment">/**
 * @param {Array} files: file pattern
 * @param {JawrOptions} jawrOptions: jawrOptions
 * @param {Object} logger: karma logger
 * */</span>
<span class="hljs-keyword">var</span> framework = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">files, jawrOptions, logger</span>) </span>{
  frameworkLogger.initLogger(logger);
  jawrHandler.handle(jawrOptions);
};

framework.$inject = [<span class="hljs-string">'config.files'</span>, <span class="hljs-string">'config.jawr'</span>, <span class="hljs-string">'logger'</span>];
<span class="hljs-built_in">module</span>.exports = { <span class="hljs-string">'framework:jawr'</span>: [<span class="hljs-string">'factory'</span>, framework] };
</code></pre>
<h4 id="integrate-with-ci">Integrate with CI</h4>
<p>目前只有测试部分与<code>travis-ci</code>和<code>circleci</code>集成了。</p>
<p><a href="https://circleci.com/gh/aquariuslt/karma-jawr">circleci</a> <a href="https://travis-ci.org/aquariuslt/karma-jawr">travis-ci</a></p>
<h4 id="pre-release-and-testing">Pre-Release and Testing</h4>
<p>为了解决其他在实际应用中遇到的问题，包括但不限于各种</p>
<ul>
<li>jawr 配置的胡乱使用</li>
<li>node.js 的 properties 解释实现并没有覆盖 properties 事实标准的所有情况</li>
</ul>
<p>等...我是自己维护了 issue 列表并且把每次修改的测试用例都加到本身的单元测试流程中</p>
<p>目前详见<a href="https://github.com/aquariuslt/karma-jawr/issues">issues</a></p>
<p><s>有一个目前因为技术原因暂时被我 标记了 wont fix</s></p>
<h2 id="references">References</h2>
<p><a href="https://github.com/aquariuslt/karma-jawr">项目源代码 Repo</a></p>
<p><a href="https://github.com/karma-runner/karma/raw/master/thesis.pdf">Karma 作者的设计论文</a></p>
<p><a href="http://taobaofed.org/blog/2016/01/08/karma-origin/">Karma 测试框架的前世今生 - 淘宝 TED | Karma 作者论文译文</a></p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/31/800/300"/>
        </item>
        <item>
            <title><![CDATA[基于Karma的非分离式前端单元测试基础方案]]></title>
            <link>https://blog.aquariuslt.com/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution</link>
            <guid>https://blog.aquariuslt.com/posts/2018/03/04/karma-based-traditional-java-web-frontend-unittest-solution</guid>
            <pubDate>Sun, 04 Mar 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[TL;DR之前在为公司一个稍微有些年头的核心系统的代码寻找一个合理的单元测试方案，在摆弄了一段时间后，目前奠定了一个基于 Karma 的前端单元测试方案。如果你的项目符合以下条件，那么这个解决方案和其]]></description>
            <content:encoded><![CDATA[<h1 id="基于-karma-的非分离式前端单元测试基础方案">基于 Karma 的非分离式前端单元测试基础方案</h1>
<p>TL;DR</p>
<h2 id="background">Background</h2>
<p>之前在为公司一个稍微有些年头的核心系统的代码寻找一个合理的单元测试方案，在摆弄了一段时间后，目前奠定了一个基于 Karma 的前端单元测试方案。</p>
<p>如果你的项目符合以下条件，那么这个解决方案和其中的思路也许能对你的项目有点帮助。</p>
<p>原本的项目与前端相关的部分属于 Java Web 项目，抛开与本次主题无关的部分，具体影响单元测试方案选型和落地的几个因素，我把他归结成几类：</p>
<ul>
<li>原本的前后端框架选型</li>
<li>在原本的前端代码中，是否具有可见的可测试的单元</li>
<li>在基础的前后端相关框架中，随着时间的变迁，是否有不合理的写法、运用导致在通往可被测试的过程中需要做较大量的代码改动</li>
<li>单元测试方案与流程，是否拥有持续集成的能力</li>
</ul>
<h3 id="existing-platform-technical-selection">Existing Platform &amp; Technical Selection</h3>
<p>先裸列出项目中与前端相关的，和后端有分离不开的技术点，后面再来看如何一步一步处理这些问题。</p>
<p>那么在没有引入前端测试解决方案之前，项目中使用到的技术栈就是：</p>
<ul>
<li>Maven (Java 端构建相关，需要关注其构建过程是否用了影响前端的静态资源文件生成路径)</li>
<li>JAWR(曾是 Java 官方社区维护的一个前端资源解决方案)</li>
<li>SpringMVC (提供了相关的 DispatcherServlet，和一个 JAWR 的 i18n 方案)</li>
<li>JSF(与前端资源在页面加载方案有关，因为 jawr 提供了一系列的 JSTL/facelets tags)</li>
</ul>
<p>为此我根据项目中前后端在测试方面未能被解耦的情况，抽离出一个最小化能体现这几点技术的一个样例项目项目地址： <a href="https://github.com/aquariuslt/karma-jawr-sample">karma-jawr-sample</a></p>
<blockquote>
<p>为了方便看到项目之前的样子，我给他还没引入单元测试的过程里面打了一个 tag:<br>
<a href="https://github.com/aquariuslt/karma-jawr-sample/releases/tag/no-frontend-unittest">https://github.com/aquariuslt/karma-jawr-sample/releases/tag/no-frontend-unittest</a><br>
可以在这里看到当时的一个可运行的一个版本。</p>
</blockquote>
<h4 id="references">References:</h4>
<ul>
<li><a href="https://github.com/j-a-w-r/jawr-main-repo">jawr-main-repo</a> 目前的 jawr 官方源代码 repo</li>
<li><a href="https://j-a-w-r.github.io/docs/messages_gen.html">jawr i18n message generator</a> jawr 的前端国际化方案(带与 SpringMVC 集成文档)</li>
<li><a href="https://j-a-w-r.github.io/tutorials/quickstart.html">jawr-quickstart</a> jawr 的官方文档首页</li>
</ul>
<blockquote>
<p>TODO：添加一份相关的前端资源请求解析流程图，正在勾画 ing</p>
</blockquote>
<h3 id="existing-frontend-core-framework-test-support">Existing Frontend Core Framework Test Support</h3>
<p>在稍微了解了项目当前使用到的前端相关选型之后，就要开始思考几个问题：</p>
<ol>
<li>在当前项目中使用的框架 本身是具有可模块化，测试化的思想吗？</li>
<li>在 1 确定的前提下，是否会出现，随着时间的发展，为项目贡献代码的过程中出现了错误的使用方法，导致越来越难以测试？</li>
<li>如何可以将目前主流框架的单元测试框架和手段应用到项目中？还是要自己造个轮子？</li>
<li>这个流程设计得具有通用性吗，对于其他使用类似技术栈的项目，是否可以快速应用上去？</li>
</ol>
<h4 id="extjs-jawr-modularize-component-based-development">ExtJS + JAWR Modularize + Component Based Development</h4>
<p>历史的车轮滚滚前进，不同时代的项目技术选型也都都有当时的前瞻性。</p>
<p>幸运的是， 项目在这方面的技术选型的时候，当时的前辈应该是考虑到了几点</p>
<ul>
<li><strong>jawr</strong> 为源代码模块化提供了基础，正因为源代码能够被模块化，测试的单元至少可以限定在一小部模块(取决于实际使用情况)</li>
<li><strong>ExtJS</strong> 无论是项目使用到的 3/4 本身已经是组件化开发思想的一个先祖了，在代码写的最乱的情况我们也能够将一个页面的整个 layout 当成是一个大组件，测试单元从真正的单一最小化组件变成一个少复杂的大组件而已。一旦可被测试，后面的测试思想便能够引导整个开发团队接纳运用这方面的思想。</li>
</ul>
<p>结论： 我们就认为在最原始的项目结构里面，前端部分是可以被单元测试的。</p>
<h4 id="wrong-usage-since-long-long-ago">Wrong Usage Since Long Long Ago</h4>
<p>项目代码的发展啊，当然要框架本身思想牛逼，但是也要考虑到历史的行程，那就是会不会出现各种滥用的情况，导致代码结构絮乱，为了完成需求各种邪门歪道奇技淫巧，而不遵循正确的开发手段。</p>
<p>我稍微分析了下项目有哪些反模式的地方，加大了可被测试的难度(这部分后面会用一些过渡类型的手段来补救，但终究不属于合理 CRUD 的做法)</p>
<ul>
<li>页面之间传值大量通过全局变量做引用(有隐式提升的全局变量，也有刻意为之的全局变量)</li>
<li>实际页面在加载的时候，会用到第三方的，页面运行时才加载的，的其他 JS 代码提供释放出的变量/方法(比如版本更新比较快的内部框架)</li>
</ul>
<p>还有一些属于并非反模式，但是加大了前后端耦合度的：</p>
<ul>
<li>jawr i18n message generator 会在运行时提供释放一系列全局函数，执行之后才返回当前对应文本的对应语言版本。需要被测试的时候，我们必须有一个不依赖任何后端服务器的 能够根据配置国际化配置文件来模拟 java 版本实现，生成同样的全局函数的手段。</li>
</ul>
<h3 id="situations-blocking-writing-unittest">Situations Blocking Writing UnitTest</h3>
<p>Block 住单元测试执行的情况，大部分都是由于业务代码的问题，少部分是 ExtJS 操作 CSS 动画的问题。这部分在设计测试框架及其流程的时候没有先考虑到，需要根据实际情况做调整。</p>
<blockquote>
<p>TODO: 后面会持续举例子</p>
</blockquote>
<h3 id="is-it-easy-to-understand">Is It Easy to Understand</h3>
<p>假设我提出了一个单元测试的技术选型和对应的流程，那么编写测试代码的时候的开发体验如何，无疑会影响大家后面持续自发编写测试用例的激情。</p>
<p>为了提高整个单元测试框架和流程的说服力，我觉得符合以下特点越多 越能够被人接受：</p>
<ul>
<li>单元测试技术选型必须有主流测试框架作为背书</li>
<li>单元测试框架组合程度相对较高</li>
<li>绝对不能依赖后台运行时服务，可以真正的单独运行</li>
<li>有可持续更新的文档来对应各种应用场景，防止为了测试写测试，或者其他反正确实践手段</li>
</ul>
<p>下面 <strong>Design &amp; Benefits</strong> 这一章，会描述选型背后的一些顾虑和我眼中的亮点。</p>
<h2 id="design-and-benefits">Design and Benefits</h2>
<h3 id="design-background">Design Background</h3>
<p>我对前端的单元测试的认识，大概是从 2016 年开始，一方面是当时的几大框架 比如<code>Angular 2</code>,<code>React</code>,<code>Vue</code> 有一些比较流行的手脚架，提供了基本的测试框架，和完善的最基础情况的单元测试 example，帮助我在确立目前项目的前端单元测试方案中提供了很多正确的思路)</p>
<p>(感谢后来的<code>angular-cli~@angular/cli</code>，<code>vue-cli</code>,<code>create-react-app</code>背后的相关的 template 项目，提供了多种测试方案的 example)</p>
<p>在对比了一些用过的前端单元测试的 Test-Runner 譬如<a href="https://karma-runner.github.io/">karma</a>， <a href="https://github.com/avajs/ava">ava</a>，<a href="https://facebook.github.io/jest/">jest</a>，<a href="https://jasmine.github.io/">jasmine</a> 之后</p>
<p>目前是选用了一套以<code>karma</code>为基础的测试方案。中间为了提升编写测试代码的体验，配合<code>webpack</code>和一个 karma 插件<a href="https://www.npmjs.com/package/karma-jawr">karma-jawr</a></p>
<p>下面这部分，会描述实际用到的测试相关的 lib 及其作用</p>
<h3 id="test-framework-selection">Test Framework Selection</h3>
<p>可以先看看整个<code>package.json</code>里面单元测试相关的 lib <a href="https://github.com/aquariuslt/karma-jawr-sample/blob/master/package.json">样例</a></p>
<pre><code class="hljs json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"karma-jawr-sample"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.4"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"spring + jawr + extjs sample project with unittest using karma-jawr"</span>,
  <span class="hljs-attr">"repository"</span>: <span class="hljs-string">"https://github.com/aquariuslt/spring-jawr-ext.git"</span>,
  <span class="hljs-attr">"author"</span>: <span class="hljs-string">"Aquariuslt &lt;superaquariuslt@gmail.com&gt;"</span>,
  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-attr">"keywords"</span>: [<span class="hljs-string">"extjs"</span>, <span class="hljs-string">"ext3"</span>, <span class="hljs-string">"spring"</span>, <span class="hljs-string">"jawr"</span>, <span class="hljs-string">"jsf"</span>, <span class="hljs-string">"karma"</span>, <span class="hljs-string">"mocha"</span>],
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"gulp test"</span>
  },
  <span class="hljs-attr">"devDependencies"</span>: {
    <span class="hljs-attr">"@types/chai"</span>: <span class="hljs-string">"^4.1.2"</span>,
    <span class="hljs-attr">"@types/extjs"</span>: <span class="hljs-string">"^4.2.32"</span>,
    <span class="hljs-attr">"@types/lodash"</span>: <span class="hljs-string">"^4.14.104"</span>,
    <span class="hljs-attr">"@types/mocha"</span>: <span class="hljs-string">"^2.2.48"</span>,
    <span class="hljs-attr">"@types/sinon"</span>: <span class="hljs-string">"^4.3.0"</span>,
    <span class="hljs-attr">"ajv"</span>: <span class="hljs-string">"^6.2.1"</span>,
    <span class="hljs-attr">"chai"</span>: <span class="hljs-string">"^4.1.2"</span>,
    <span class="hljs-attr">"coveralls"</span>: <span class="hljs-string">"^3.0.0"</span>,
    <span class="hljs-attr">"css-loader"</span>: <span class="hljs-string">"^0.28.10"</span>,
    <span class="hljs-attr">"file-loader"</span>: <span class="hljs-string">"^1.1.11"</span>,
    <span class="hljs-attr">"gulp"</span>: <span class="hljs-string">"^3.9.1"</span>,
    <span class="hljs-attr">"gulp-sequence"</span>: <span class="hljs-string">"^1.0.0"</span>,
    <span class="hljs-attr">"istanbul"</span>: <span class="hljs-string">"^0.4.5"</span>,
    <span class="hljs-attr">"istanbul-instrumenter-loader"</span>: <span class="hljs-string">"^3.0.0"</span>,
    <span class="hljs-attr">"karma"</span>: <span class="hljs-string">"^2.0.0"</span>,
    <span class="hljs-attr">"karma-chai"</span>: <span class="hljs-string">"^0.1.0"</span>,
    <span class="hljs-attr">"karma-chrome-launcher"</span>: <span class="hljs-string">"^2.2.0"</span>,
    <span class="hljs-attr">"karma-coverage"</span>: <span class="hljs-string">"^1.1.1"</span>,
    <span class="hljs-attr">"karma-coverage-istanbul-reporter"</span>: <span class="hljs-string">"^1.4.1"</span>,
    <span class="hljs-attr">"karma-firefox-launcher"</span>: <span class="hljs-string">"^1.1.0"</span>,
    <span class="hljs-attr">"karma-iframes"</span>: <span class="hljs-string">"^1.1.1"</span>,
    <span class="hljs-attr">"karma-jawr"</span>: <span class="hljs-string">"^0.1.12"</span>,
    <span class="hljs-attr">"karma-junit-reporter"</span>: <span class="hljs-string">"^1.2.0"</span>,
    <span class="hljs-attr">"karma-mocha"</span>: <span class="hljs-string">"^1.3.0"</span>,
    <span class="hljs-attr">"karma-sinon"</span>: <span class="hljs-string">"^1.0.5"</span>,
    <span class="hljs-attr">"karma-sourcemap-loader"</span>: <span class="hljs-string">"^0.3.7"</span>,
    <span class="hljs-attr">"karma-spec-reporter"</span>: <span class="hljs-string">"^0.0.32"</span>,
    <span class="hljs-attr">"karma-webpack"</span>: <span class="hljs-string">"^2.0.13"</span>,
    <span class="hljs-attr">"lodash"</span>: <span class="hljs-string">"^4.17.5"</span>,
    <span class="hljs-attr">"mocha"</span>: <span class="hljs-string">"^4.1.0"</span>,
    <span class="hljs-attr">"mocha-lcov-reporter"</span>: <span class="hljs-string">"^1.3.0"</span>,
    <span class="hljs-attr">"puppeteer"</span>: <span class="hljs-string">"^1.1.1"</span>,
    <span class="hljs-attr">"sinon"</span>: <span class="hljs-string">"^4.4.2"</span>,
    <span class="hljs-attr">"style-loader"</span>: <span class="hljs-string">"^0.19.0"</span>,
    <span class="hljs-attr">"url-loader"</span>: <span class="hljs-string">"^0.6.2"</span>,
    <span class="hljs-attr">"webpack"</span>: <span class="hljs-string">"^3.11.0"</span>
  }
}
</code></pre>
<p>值得提到的相关 lib 是：</p>
<ul>
<li>karma: test-runner 本身</li>
<li>karma-chai, karma-chrome-launcher, karma-coverage 等等等以 <code>karma-</code> 作为开头的 便是 karma 与其他框架集成的相关框架</li>
<li>mocha</li>
<li>chai 提供测试断言相关 API</li>
<li>sinon 提供 mock 相关 API</li>
<li>puppeteer 提供 headless Chrome 的 node.js API 可以在 CI 服务器上方面的提供浏览器环境</li>
<li>webpack 及其相关 loader 通过 webpack + 各种 loader 可以方便的引用各种测试家具(fixture), 生成 sourcemap，和根据项目实际情况各种忽略规则。</li>
</ul>
<p>每个 lib 单独使用起来都能够稍作文章，但是最终要的就是这些测试用到的相关 lib，都是可以自由组合的，这也是使用 karma 作为单元测试流程基础的一部分。</p>
<h3 id="diagram">Diagram</h3>
<p>具体的测试执行流程 其实都可以通过项目里面的<code>karma.conf.js</code>来定义。</p>
<p>这里以样例项目代码的<code>tasks/config/karma.conf.js</code>来描述一下这个项目在启动测试步骤的时候，经过了些什么。</p>
<h4 id="karmaconfjs">karma.conf.js</h4>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> webpackTestConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.test.config'</span>);
<span class="hljs-keyword">var</span> pathUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils/path.util'</span>);

<span class="hljs-keyword">var</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'puppeteer'</span>);
process.env.CHROMIUM_BIN = puppeteer.executablePath();

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) </span>{
  config.set({
    <span class="hljs-attr">logLevel</span>: config.LOG_DEBUG,
    <span class="hljs-attr">customLaunchers</span>: {
      <span class="hljs-attr">ChromiumHeadlessNoSandbox</span>: {
        <span class="hljs-attr">base</span>: <span class="hljs-string">'ChromiumHeadless'</span>,
        <span class="hljs-attr">flags</span>: [<span class="hljs-string">'--no-sandbox'</span>]
      }
    },
    <span class="hljs-attr">browsers</span>: [<span class="hljs-string">'ChromiumHeadlessNoSandbox'</span>],
    <span class="hljs-attr">plugins</span>: [
      <span class="hljs-string">'karma-chrome-launcher'</span>,
      <span class="hljs-string">'karma-chai'</span>,
      <span class="hljs-string">'karma-mocha'</span>,
      <span class="hljs-string">'karma-spec-reporter'</span>,
      <span class="hljs-string">'karma-coverage'</span>,
      <span class="hljs-string">'karma-coverage-istanbul-reporter'</span>,
      <span class="hljs-string">'karma-sourcemap-loader'</span>,
      <span class="hljs-string">'karma-sinon'</span>,
      <span class="hljs-string">'karma-webpack'</span>,
      <span class="hljs-string">'karma-jawr'</span>
    ],
    <span class="hljs-attr">frameworks</span>: [<span class="hljs-string">'jawr'</span>, <span class="hljs-string">'mocha'</span>, <span class="hljs-string">'sinon'</span>, <span class="hljs-string">'chai'</span>],
    <span class="hljs-attr">files</span>: [pathUtil.resolve(<span class="hljs-string">'src/test/js/unit/specs'</span>) + <span class="hljs-string">'/**/*.spec.js'</span>],
    <span class="hljs-attr">reporters</span>: [<span class="hljs-string">'spec'</span>, <span class="hljs-string">'coverage-istanbul'</span>],
    <span class="hljs-attr">preprocessors</span>: {
      <span class="hljs-string">'/**/*.spec.js'</span>: [<span class="hljs-string">'webpack'</span>, <span class="hljs-string">'sourcemap'</span>]
    },
    <span class="hljs-attr">jawr</span>: {
      <span class="hljs-attr">configLocation</span>: pathUtil.resolve(<span class="hljs-string">'src/main/resources/jawr/'</span>) + <span class="hljs-string">'jawr.properties'</span>,
      <span class="hljs-attr">webappLocation</span>: pathUtil.resolve(<span class="hljs-string">'src/main/webapp'</span>),
      <span class="hljs-attr">targetLocation</span>: pathUtil.resolve(<span class="hljs-string">'src/test/js/build'</span>),
      <span class="hljs-attr">localeConfigLocation</span>: pathUtil.resolve(<span class="hljs-string">'src/main/resources'</span>)
    },
    <span class="hljs-attr">webpack</span>: webpackTestConfig,
    <span class="hljs-attr">webpackMiddleware</span>: {
      <span class="hljs-attr">stats</span>: <span class="hljs-string">'errors-only'</span>,
      <span class="hljs-attr">noInfo</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">coverageIstanbulReporter</span>: {
      <span class="hljs-attr">dir</span>: pathUtil.resolve(<span class="hljs-string">'src/test/js/unit'</span>) + <span class="hljs-string">'/coverage'</span>,
      <span class="hljs-attr">reports</span>: [<span class="hljs-string">'html'</span>, <span class="hljs-string">'lcovonly'</span>, <span class="hljs-string">'text-summary'</span>],
      <span class="hljs-attr">fixWebpackSourcePaths</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">skipFilesWithNoCoverage</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">thresholds</span>: {
        <span class="hljs-attr">emitWarning</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">global</span>: {
          <span class="hljs-attr">statements</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">lines</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">branches</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">functions</span>: <span class="hljs-number">1</span>
        }
      }
    }
  });
};
</code></pre>
<ol>
<li>在启动 karma 服务器的时候，读取这个<code>karma.conf.js</code>来加载配置。</li>
<li>如果在 config 里面 没有<code>plugins</code> field，则会自动扫描并加载所有 packge.json 里面定义的，以<code>karma-</code>开头的，符合<code>karma-plugin</code> 依赖注入规则的插件。如果有，则之加载<code>plugins</code> field 里面定义的插件。</li>
<li>接着我们定义一个<code>files</code>数组，里面数组的每一行都可以使用 <a href="https://en.wikipedia.org/wiki/Glob_(programming)">unix glob style path patterns</a> 描述我们定义的所有的单元测试文件。</li>
</ol>
<p>这里是<code>pathUtil.resolve('src/test/js/unit/specs') + '/**/*.spec.js'</code>，意为扫描的是在<code>src/teest/js/unit/spec</code>文件夹及其子文件夹下，所有以<code>.spec.js</code>为结尾的文件。</p>
<ol start="4">
<li>
<p>接着我们定义一个<code>browsers</code> field，表示 karma 服务器启动之后，将会根据<code>browsers</code>中定义的浏览器名字，通过对应的<code>karma-${browsers-core}-launcher</code>提供 API 来唤起对应的浏览器，在运行时候把上面<code>files</code> field 定义的所有测试文件加载到所启动的浏览器的单一 tab 中。</p>
</li>
<li>
<p>浏览器直接加载那些<code>**/*.spec</code>类型的单元测试代码就可以了吗?如果用到了一些 CommonJS 语法 来编写单元测试，或者你想方便的加载一些测试家具，比如离线加载一些原本在运行时才能被加载的第三方 css，或者为了 mockup 返回的使用 json/文本形式保存的模拟的业务数据返回值... 等操作</p>
</li>
</ol>
<p>那么推荐的做法是在 <code>preprocessors</code>里面通过 karma 提供的 preprocessor API，结合第三方 processor 插件，来对单元测试的源代码做一个预处理的过程。</p>
<p>这里貌似有点拗口，我们通过加与不加<code>preprocessors</code>的时候的一个比较来说明两种情况的区别。</p>
<p><code>base.spec.js</code></p>
<pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'@/jsBundles/extJs.js'</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">'@/jsBundles/home.js'</span>);

describe(<span class="hljs-string">'ext'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  before(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    Ext.onReady(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      Ext.QuickTips.init();
      <span class="hljs-keyword">new</span> agile.example.app.Home({
        <span class="hljs-attr">renderTo</span>: Ext.getBody()
      });
    });
  });
  it(<span class="hljs-string">'# check extjs is loaded'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> expectExtVersion = <span class="hljs-string">'3.3.1'</span>;
    expect(Ext.version).to.eq(expectExtVersion);
  });
});
</code></pre>
<p>在没有<code>preprocessors</code>的情况，浏览器直接把<code>base.spec.js</code> 加载到 karma server 启动的浏览器页面中。由于不能识别代码里面的 CommonJS 语法而抛出错误，同样第，因为没有加载到 ExtJS 的源代码文件，也会抛出错误。</p>
<p>添加了<code>preprocessors</code> 里面<code>karma-webpack</code>,<code>karma-sourcemap-loader</code>，和添加了相关这些预处理器的相关插件的时候，在 karma server 启动的浏览器页面中，由于加载过的是被<code>webpack</code>解析构建好之后的 bundle 文件，则能够正确的按需加载所有需要加载的 js 文件。</p>
<p>在这里<code>karma-webpack</code>所提供的配置选项是<code>webpack</code>和<code>webpackMiddleware</code>两个 option，告诉了使用对于单个单元测试文件，使用哪个 webpack 的配置文件来解析单元测试源代码。</p>
<p>有关 karma 相关插件的开发，和这次为了解耦开发的<code>karma-jawr</code>插件，将会在另外一篇文章里面详解。</p>
<ol start="6">
<li>那么测试浏览器加载的所有单元测试文件，被当前用到的<code>mocha</code>框架解析并执行对应的测试代码，执行之后，我们想知道单元测试的完整覆盖率，那么我们要怎么做呢？</li>
</ol>
<p>那就是<code>reporters</code>这一个 field。</p>
<p>在<code>reporters</code> 里面定义的相关的报告生成器，他们实际上是把对应的测试框架的报告功能统一管理了，执行基于什么类型的单元测试框架，这个单元测试框架如果要统计并展现覆盖率，应该提供哪些配置细节，都在<code>reporters</code>里面定义相关的<code>karma-reporter</code>插件，并根据该插件要求的配置，来生成对应的覆盖率报告文件。</p>
<p>这里选用的是<code>spec</code> + <code>coverage-istanbul</code>插件他们将会根据<code>webpack.test.config</code>里面配置的 post-loader <code>istanbul-instrumenter-loader</code>反向与源代码联系在一起，在执行单元测试的过程中，记录各种方法，变量的调用情况，最后根据<code>coverageIstanbulReporter</code>中定义的<code>reports</code>类型，生成 html 报告，通用的<code>lcov.info</code>覆盖率描述文件，和一个终端输出的报告。</p>
<ol start="7">
<li>那么那个<code>karma-jawr</code>起到的是什么作用呢，这是一个为了根据前后端技术选型 解耦的 自己开发的一个 karma 插件，在下面这个 <strong>Decoupled Solution</strong> 一章会讲这里的设计</li>
</ol>
<h3 id="decoupled-solution">Decoupled Solution</h3>
<p>我们先来看看在本地开发环境下<s>即根据环境分离的相关配置都设置成 env=development,debug=on 之类的参数)</s></p>
<p>假设在样例项目中，我们在浏览器里面访问某个 url <code>xxxx/home</code>，在经过 SpringMVC 的 viewResolver，mapping 到一个<code>home.xhtml</code> 。此时 xhtml 的内容里面，有一些 jawr 相关的 facelets tags，譬如</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">jawr:style</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/cssBundles/ext.css"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">jawr:script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/jsBundles/extJs.js"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">jawr:script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/jsBundles/home.js"</span>/&gt;</span>
</span></code></pre>
<p>这表示他们会根据根据 jawr 的配置文件<code>jawr.properties</code></p>
<pre><code>jawr.js.bundle.names=i18n, extJs, home, login
jawr.css.bundle.names=extCss
# JAWR Bundle Definitions
jawr.js.bundle.extJs.id=/jsBundles/extJs.js
jawr.js.bundle.extJs.composite=true
jawr.js.bundle.extJs.child.names=\
  extDebug,\
  extProd
## ExtJS Debug Source
jawr.js.bundle.extDebug.debugonly=true
jawr.js.bundle.extDebug.mappings=/js/vendor/ext/ext-base-debug.js, /js/vendor/ext/ext-all-debug-w-comments.js
## ExtJS Prod Source
jawr.js.bundle.extProd.debugnever=true
jawr.js.bundle.extProd.mappings=/js/vendor/ext/ext-base.js, /js/vendor/ext/ext-all.js
## ExtJS CSS Source
jawr.css.bundle.extCss.id=/cssBundles/ext.css
jawr.css.bundle.extCss.mappings=/css/vendor/ext/ext-all.css
## Home Page Application JS Bundles
jawr.js.bundle.home.id=/jsBundles/home.js
jawr.js.bundle.home.composite=true
jawr.js.bundle.home.child.names=homeStore, homeUi, homeImpl
### Home Store
jawr.js.bundle.homeStore.mappings=/js/home/datastore/**
### Home Ui
jawr.js.bundle.homeUi.mappings=/js/home/ui/**
jawr.js.bundle.homeUi.dependencies=homeStore
### Home Impl
jawr.js.bundle.homeImpl.mappings=/js/home/impl/**
jawr.js.bundle.homeImpl.dependencies=homeUi

### Mappings include jawr bundle example
jawr.js.bundle.login.id=/jsBundles/login.js
jawr.js.bundle.login.mappings=homeUi
</code></pre>
<p>查找并释放转换为对应的 mapping 的若干个<code>&lt;script src=${source-path} type=${source-type}/&gt;</code>标签。</p>
<p>如果启用了 jawr 的 i18n message generator 功能，即添加了下面相关配置</p>
<pre><code># JAWR i18n Resolver with Spring MVC
jawr.locale.resolver=net.jawr.web.resource.bundle.locale.SpringLocaleResolver
jawr.js.bundle.i18n.id=/jsBundles/i18n.js
jawr.js.bundle.i18n.global=true
jawr.js.bundle.i18n.order=1
jawr.js.bundle.i18n.mappings=messages:i18n.i18n(locale)
</code></pre>
<p>那么还会多出系列 message generator 的全局函数。</p>
<p>实际渲染出的 html 页面为</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Finished adding global members. */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Start adding members resolved by '/cssBundles/ext.css'. Bundle id is: '/cssBundles/ext.css' */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/css/vendor/ext/ext-all.css?d=354974446"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Finished adding members resolved by /cssBundles/ext.css */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Start adding global members. */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/jawr_generator.js?d=1002165950&amp;generationConfigParam=messages%3Ai18n.i18n%28locale%29"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Finished adding global members. */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Start adding members resolved by '/jsBundles/extJs.js'. Bundle id is: '/jsBundles/extJs.js' */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/vendor/ext/ext-base-debug.js?d=905484299"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/vendor/ext/ext-all-debug-w-comments.js?d=1203100109"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Finished adding members resolved by /jsBundles/extJs.js */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Start adding members resolved by '/jsBundles/home.js'. Bundle id is: '/jsBundles/home.js' */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/home/datastore/home.base.datastore.js?d=394071763"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/home/ui/home.ui.js?d=1374816983"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/home/impl/home.impl.js?d=1755247404"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="hljs-comment">/* Finished adding members resolved by /jsBundles/home.js */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</span></code></pre>
<p>大致的可以用一个流程来解释一下这里的情况，与后面解耦部分密切相关的几点：</p>
<ul>
<li>我们需要知道一个页面所加载的前端资源，具体的模块配置入口是位于 jawr 配置文件的哪一个 bundle</li>
<li>这些页面加载的前端资源，在开发环境模式下，如何逐条转换成对应的 script，css 标签</li>
<li>如果开启了 jawr 对应的国际化功能，我们应该如何在测试中生成这些全局的国际化函数</li>
</ul>
<p>为了解耦呢，这个<code>karma-jawr</code>的中间件提供了这样一个功能</p>
<p>根据<code>jawr.properties</code>的位置，参考 jawr Java 的路径解释部分实现，生成了一个中间文件夹 <img src="https://img.aquariuslt.com/posts/karma-jawr-generated-index.jpg" alt="generated-indexes folder"> 配合 webpack 的<code>alias</code>功能，我们只要在单元测试代码里面使用类似这样的语法</p>
<pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'@/jsBundles/extJs.js'</span>);
</code></pre>
<p>便能够按需加载页面的资源文件执行，原本在 jsf facelet view 里面使用什么 tag 就知道在单元测试文件加载什么依赖。为了解决中间生成的国际化相关的全局函数，也是参考了 jawr Java 端读取 i18n 相关 properties 的实现，撸了一个输出结果一样的 i18n 的自动添加到每个 index.js 相关的文件列表的最前面，确保他们优先生效，不影响后面 webpack 的解析工作。</p>
<p>具体的实现思路，也可以单独作一篇文章，讲解 karma-framework 和 karma-preprocessor 等相关的机制和其作者的一些依赖注入在 node.js 方面的实现。</p>
<h3 id="benefits">Benefits</h3>
<p>主要是从开发体验上面来讲，好处是如下</p>
<ul>
<li>一旦了解 karma 的基本工作机制，便可以自由搭配各种可搭配的测试框架。(比如<code>mocha</code>换<code>jasmine</code>,<code>chai</code>换<code>expect.js</code>,<code>sinon</code>..额 sinon 目前还没见到可被替换的有效方案)</li>
<li>根据项目浏览器的兼容性，可以修改成各种浏览器及其相关启动 flag</li>
<li>基于 webpack 的各种 loader 特性，可以很方便的通过 require 语法引入各种测试家具: (json 格式不必额外的 loader, css 则是基于 style-loader，和 css-loader 的各种配合使用, 纯文本形式可以搭配 file-loader)。不必自己再写各种工具类轮子来实现持久化模拟数据读取的恶心轮子。</li>
</ul>
<p>一些额外的提升开发体验的糖果</p>
<ol>
<li>首先如果大家的 IDE 支持 webpack 的 alias 快速跳转(比如 IDEAU 2017.2 之后的版本) 根据引用部分</li>
<li>配合 IDEA 的 karma 插件，在编写单元测试的时候，可以动态给 karma.Server 注入不同的参数，配合本身<code>karma-webpack</code>内置的 webpack-dev-server 可以做到刷新立刻动态构建单元测试，提升单元测试开发效率。</li>
</ol>
<h2 id="example">Example</h2>
<h3 id="example-usage">Example Usage</h3>
<p>关于食用方法，可以参考上面提供的样例项目代码的地址。</p>
<p>大家可以直接根据<a href="https://travis-ci.org/aquariuslt/karma-jawr-sample/jobs/354402343">travivs-ci.org</a>上的构建记录来看看实际跑的时候经过了什么步骤。</p>
<pre><code>  ext
    ✓ # check extjs is loaded
    ✓ # expect home ui is rendered
  css
    ✓ # should load css from require syntax success
  home
    ✓ # test home resources load correctly
    ✓ # test home ui render correctly
    ✓ # test home ui render correctly 2
  i18n
    ✓ # check locale message is loaded normally
    ✓ # check locale message with arguments loaded normally
    special characters in locale message properties
      ✓ # check json array value in locale message properties
      ✓ # check if boolean value in locale message properties
      ✓ # check if string value contains escape characters
  ws
    ✓ # ext ajax simple mockup
HeadlessChrome 67.0.3372 (Linux 0.0.0): Executed 12 of 12 SUCCESS (0.109 secs / 0.056 secs)
TOTAL: 12 SUCCESS
16 03 2018 16:33:19.396:DEBUG [reporter.coverage-istanbul]: File [/home/travis/build/aquariuslt/karma-jawr-sample/src/main/webapp/js/home/datastore/home.base.datastore.js] ignored, nothing could be mapped
16 03 2018 16:33:19.397:DEBUG [reporter.coverage-istanbul]: Writing coverage reports: [ 'html', 'lcovonly', 'text-summary' ]
=============================== Coverage summary ===============================
Statements   : 100% ( 11/11 )
Branches     : 100% ( 0/0 )
Functions    : 100% ( 3/3 )
Lines        : 100% ( 11/11 )
================================================================================
16 03 2018 16:33:19.461:DEBUG [karma]: Run complete, exiting.
16 03 2018 16:33:19.462:DEBUG [launcher]: Disconnecting all browsers
16 03 2018 16:33:19.474:DEBUG [launcher]: Process ChromiumHeadless exited with code 0
16 03 2018 16:33:19.474:DEBUG [temp-dir]: Cleaning temp dir /tmp/karma-79051576
16 03 2018 16:33:19.482:DEBUG [launcher]: Finished all browsers
[16:33:19] Finished 'ext:unittest' after 12 s
[16:33:19] Finished 'test' after 12 s
</code></pre>
<h2 id="result">Result</h2>
<p>基于这个方案落地并付诸实践整个测试流程之后，引导大家逐渐开始为该项目编写前端部分的单元测试，并且逐渐可以发展到其他使用到类似技术栈和遇到同样痛点的项目组。</p>
<p>目前项目前端业务源代码总量大概在 300K 行 经过三个月的单元测试编写，目前从覆盖率上讲，从 0 达到了 11%左右。</p>
<p>我们在为一些特别难以测试的案例里面，根据不同典型的错误场景，也做了不同的对应解决方案，有直接安全重构的，有扩展全局测试用例 timeout 时间的，有非安全重构的。都逐渐提醒整个开发团队在编写新代码或者为旧代码扩展的时候，对代码有着更多的精益思考。虽然前端代码的时间方面，并没有真正做到测试先行的最终目标，但是从不能被单元测试到可被单元测试，代码风格和代码质量都朝着正确的方向走去，少走了很多歪路。</p>
<h2 id="summary">Summary</h2>
<p>这次为项目设计的这个单元测试流程，考验了很多方面的开发与设计能力：</p>
<p>首先必须了解目前项目使用的后端技术栈，推导出当时选型时候的设计背景，再上熟练运用后端技术栈中的前端资源解决方案。在根据公司项目抽离出不相关的技术栈，搭建一个最小化能复现当时技术栈的相关代码结构，也考验分离项目结构的基本功。</p>
<p>其次必须对主流的前端单元测试方案有所了解，使用什么框架，结合什么插件，这些框架哪些部分在进行前后端结构解耦的时候需要考虑，如何快速测试方案是否具有可用性。</p>
<p>后面还得了解测试背后如何方便能够展现覆盖率，如何能够通过测试流程自动发现代码中存在的问题，还得有足够的持续集成相关经验。</p>
<p>串联起来比较考验综合能力，在落地宣讲的时候，为了寻求背书支撑也做了很多资料搜集的功夫。</p>
<p>综合起来就是 考验了小部分项目结构分析能力，前端框架和构建工具选型水平，持续集成选型，和在必要的时候造个中间件的轮子的能力。感觉当时要是哪个方面少了哪一点 可能最后都不能得出一个较为可行的方案。算是一个多面打杂之后的综合输出考验吧。</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/220/800/300"/>
        </item>
        <item>
            <title><![CDATA[Latest Update on Blog App]]></title>
            <link>https://blog.aquariuslt.com/posts/2018/03/03/latest-update-on-blog-app</link>
            <guid>https://blog.aquariuslt.com/posts/2018/03/03/latest-update-on-blog-app</guid>
            <pubDate>Sat, 03 Mar 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[结合最近学到的一些知识，了解的一些规范，和实践过的一些新姿势，重构了 Blog 的整个应用。目前 Vue Branch 版本从`4.0.0-beta` 到了`4.0.1` ，算是可以标记 releas]]></description>
            <content:encoded><![CDATA[<h1 id="latest-update-on-blog-app">Latest Update on Blog App</h1>
<p>结合最近学到的一些知识，了解的一些规范，和实践过的一些新姿势，重构了 Blog 的整个应用。目前 Vue Branch 版本从<code>4.0.0-beta</code> 到了<code>4.0.1</code> ，算是可以标记 release 的一个版本了。</p>
<p><a href="https://github.com/aquariuslt/blog">项目地址</a>不变。(除了最近更新过一次 Github account 的 url，开头从大写变成小写，对其他第三方服务迁移的时候有点麻烦)。</p>
<h2 id="refactor-background">Refactor Background</h2>
<p>其实是很少符合很多最佳实践</p>
<ul>
<li>测试流程不完整</li>
<li>代码抽象结构不够好</li>
<li>依赖升级不够及时</li>
<li>Markdown 功能化不够完整(其实这次重构花了很多时间都没有做好)</li>
<li>之前 Gulp 的部分功能 发现 Webpack 已经有比较成熟的方案可以实现，需要替换</li>
</ul>
<h2 id="new-features">New Features</h2>
<p>目前添加的新功能：</p>
<ul>
<li>提供了<code>feed.xml</code>，支持 RSS 功能</li>
<li>支持 Github Pages SEO</li>
<li>支持国际化</li>
<li>同时支持<a href="https://travis-ci.org/aquariuslt/blog/">Travis-CI</a>，<a href="https://circleci.com/gh/aquariuslt/blog">Circle-CI</a> 构建和发布</li>
<li>将覆盖率报告展现在<a href="https://coveralls.io/github/aquariuslt/blog">coveralls.io</a>中</li>
</ul>
<h2 id="structuredesigndependencies-update">Structure/Design/Dependencies Update</h2>
<p>目前代码结构/框架选型/测试流程上的改进包括好几个方面</p>
<h3 id="config-design">Config Design</h3>
<ul>
<li>修改了入口配置文件<code>application.yml</code>的 schema，结构更加扁平</li>
<li>抽离<code>google site verification</code>到配置文件里</li>
</ul>
<h3 id="build-flow">Build Flow</h3>
<ul>
<li>将读取<code>*.md</code>文件的工具类，从 Gulp Tasks 中抽取出来，目的是将来该工具类可以单独分离成一个模块。目前该模块功能是根据源代码生成合适的 api-schema 的内容，并且在<code>marked</code>的功能上做了一个 wrapper，实现自定义 header，自定义代码区块高亮，自定义 id 生成样式等功能</li>
<li>添加生成符合 RSS 规范的相关文件的 Gulp Tasks</li>
<li>添加测试相关的 Gulp Tasks</li>
<li>添加生成静态子页面的 Gulp Task</li>
</ul>
<h3 id="testing-flow">Testing Flow</h3>
<ul>
<li>目前的测试流程，与语言框架无关的部分，主要是使用<code>karma</code> + <code>webpack</code> + <code>mocha</code> + <code>sinon</code> + <code>chai</code> +<code>puppeteer</code>来构建整体的测试流程。</li>
<li>覆盖率报告方面，主要是使用了<code>karma</code>的<code>spec coverage reporter</code>插件 来生成较为通用的<code>lcov.info</code>报告文件，方便与各大开放的覆盖率报告平台集成。</li>
<li>与语言框架相关的部分，根据 beta 版本的<code>@vue/test-utils</code> 的官方推荐单元测试编写方法改写了各大组件的测试前置代码(最新的几个版本坑有点多，大概是与那些在代码里面强行加入了 SSR 的检测之类的改动导致体验挺糟糕的)</li>
<li>使用了<code>moxios</code>这个<code>axios</code>官方的 mockup lib 来做模拟 http 请求方面的测试</li>
</ul>
<h3 id="dependencies3rd-party-lib-selection">Dependencies/3rd Party Lib Selection</h3>
<ul>
<li>PWA 相关配置方面，移除了从利用<code>sw-preache</code>构建出 PWA 相关文件的 Gulp，改而采用<code>offline-plugin</code> + runtime 模式来切分开发环境与生产环境的的加载。</li>
<li>webpack 和相关官方插件升级到 3 的最新版(重构之间 webpack 还发布了 4，但是有点破坏性的改动还没找到合适的替代方案，所以暂时观望和调试中)</li>
<li>添加<code>vue-i18n</code>做国际化</li>
<li>升级 babel 版本到 6 的最新版，重新配置了 babel 相关的配置文件，统一到较合适的阶段</li>
<li><code>vue-material</code>也升级到了 v1.0-beta 版本，为新的 API 修改一轮代码</li>
</ul>
<h2 id="benchmark">Benchmark</h2>
<p>目前首次页面加载总共需要 280KB 的流量。 <img src="https://img.aquariuslt.com/posts/blog-resource-transfer-time.png" alt="blog-resource-transfer-time"></p>
<p><img src="https://img.aquariuslt.com/posts/benchmark-blog-website.png" alt="benchmark-blog-website"> 重新用 Chrome 的 Audits 工具做了一次测试(中间有根据提示的一些最佳实践准则进行优化) 之后，主要痛点是首次渲染页面时间比较长。</p>
<h2 id="todo">TODO</h2>
<ul>
<li>重新思考 Markdown 转译工具部分代码的选型(当初选型用 marked 真是真是后悔，完全是照搬 perl 实现)</li>
<li>补全没写的一些单元测试样例</li>
<li>更新<code>vexo-cli</code>提供详细的文档和遵循设计规范的背书说明</li>
</ul>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/83/800/300"/>
        </item>
        <item>
            <title><![CDATA[Year in Review 2017]]></title>
            <link>https://blog.aquariuslt.com/posts/2018/01/01/review-2017</link>
            <guid>https://blog.aquariuslt.com/posts/2018/01/01/review-2017</guid>
            <pubDate>Mon, 01 Jan 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[之前一直想为公司的一个主力项目的前端添加单元测试流程，由于是跟后端项目耦合度相对较高的结构。在基于各大前端项目的单元测试方案 和 项目使用的后端服务前端资源解决方案之上，加上自己编写了一个帮助转换的 ]]></description>
            <content:encoded><![CDATA[<h1 id="year-in-review-2017">Year in Review 2017</h1>
<h2 id="busy-year">Busy Year</h2>
<h3 id="setup-frontend-js-unittest-framework-for-legacy-code">Setup Frontend JS UnitTest framework for legacy code</h3>
<p>之前一直想为公司的一个主力项目的前端添加单元测试流程，由于是跟后端项目耦合度相对较高的结构。在基于各大前端项目的单元测试方案 和 项目使用的后端服务前端资源解决方案之上，加上自己编写了一个帮助转换的 karma 测试插件，终于把这个测试流程较为优雅地落地。</p>
<h3 id="more-practice-in-docker">More practice in Docker</h3>
<p>今年上半年做过<a href="https://github.com/hyperledger">hyperledger</a>的 POC。通过在本地模拟一些集群和网络设定，实践了一些 Docker 的基础知识</p>
<p>接下来后面对团队内部的一些 CI 和容器化实践中，也稍微实践了一些容器化的其他方向应用。具体应该能写比较多的实践记录，后面会补上。</p>
<h3 id="became-technical-conferences-committee">Became Technical Conferences Committee</h3>
<p>得益于公司年底请来了 Thoughtworks 团队，Thoughtworks 团队的咨询师给公司发展技术社区的氛围提出了很多油可行性高的意见，其中一件事就是举办技术嘉年华一类的活动，以带动、增进公司的技术氛围。第一届的技术嘉年华我是里面 Committees 的其中一位，在负责事件策划，演讲题目 Review，等方面都可以提出自己的意见。</p>
<h2 id="devices">Devices</h2>
<p>今年在消费电子上投入也是挺大的，毕竟没有其他刚需。</p>
<h3 id="rmbp-15">RMBP 15</h3>
<p><img src="https://img.aquariuslt.com/posts/macbook-pro.jpg" alt="Macbook Pro"> 出了之前的小 RMBP 入手了顶配+定制显卡的 15 寸新 RMBP。</p>
<p>感谢猴子聚聚的员工优惠，可惜下单的时候没注意写成了中文键盘。目前用起来一切完美，就是没出 32G 内存有点可惜。</p>
<h3 id="sony-mdr-1000x">SONY MDR-1000x</h3>
<p>6 月份入手第一款降噪耳机。 <img src="https://img.aquariuslt.com/posts/mdr-1000x.png" alt="MDR-1000X"></p>
<p>舒适程度降噪效果比之前的好太多了。目前评价挺高</p>
<h3 id="ikbc-dc-108-wireless">IKBC DC 108 Wireless</h3>
<p>年度最不值花钱消费之一。</p>
<p>一直对 IKBC 这个双模+TypeC 的键盘有个小期望。毕竟市场上做蓝牙机械键盘的不多，而且 Type-C 接口的是第一款能买到的。</p>
<p>可惜买到之后发现是失望比较多，先是因为京东的原因给我发错了一款黑轴的，开箱按了一下像吃了屎，立刻联系换货正确版本到了之后，在 Mac 和 Win 蓝牙连接下经常有掉键的现象发生。特别是盲敲密码的时候，甚是恼火。</p>
<h2 id="summary">Summary</h2>
<p>关于去年一年的收获，其实在写这篇的时候还多想了很多个点。不过后面还是可以随时修改内容，也就先放简要的写这么多。</p>
<p>过去的一年排期比较满了，但是从技能增长的情况来看，比较接近目标。给自己一个 3.75 先，再接再厉。</p>
<h2 id="target-plan">Target &amp; Plan</h2>
<p>在新的一年里面，先制定几个非技术向的目标：</p>
<ul>
<li>多运动，定制运动目标</li>
<li>读点非技术向的书</li>
<li>加强理财技巧</li>
</ul>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/1006/800/300"/>
        </item>
        <item>
            <title><![CDATA[Vue Version Blog App]]></title>
            <link>https://blog.aquariuslt.com/posts/2017/05/05/vue-version-for-blog-app</link>
            <guid>https://blog.aquariuslt.com/posts/2017/05/05/vue-version-for-blog-app</guid>
            <pubDate>Fri, 05 May 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[这篇文章写于 2017-05-05. 下面一部分没实现的功能已经基本实现，并且做了更多的配置外化工作.详情将会发布到新的一篇文章里面.在阅读过 Vue 的官方文档之后,我尝试用其为一个数据可视化项目的]]></description>
            <content:encoded><![CDATA[<h1 id="vue-version-blog-app">Vue Version Blog App</h1>
<h2 id="change-log">Change Log</h2>
<p>这篇文章写于 2017-05-05. 下面一部分没实现的功能已经基本实现，并且做了更多的配置外化工作.</p>
<p>详情将会发布到新的一篇文章里面.</p>
<h2 id="background">Background</h2>
<p>在阅读过 Vue 的官方文档之后,我尝试用其为一个数据可视化项目的图表做一个 Refine,以寻求渲染性能与响应变化上性能的提升,与更细致,可自定义的动画效果.</p>
<p>虽然 Vue 是一个渐进式的前端框架,但是突然想以 Vue 全家桶去实现一次 Angular1.x 项目中所有的功能,于是便以自己的 Blog App 作为一个初始项目进行练手.</p>
<p>从四月份开始进行 Vue 的学习,目前 Vue 版本的 Blog App 已经实现了<a href="https://github.com/Aquariuslt/Blog/tree/NG2">@Angular 版本</a>的所有功能.</p>
<p>记录一下中间的历程.</p>
<p>根据目前所做的工作,</p>
<p>代码放在<a href="https://github.com/Aquariuslt/Blog">Vue 分支</a>上.</p>
<h2 id="features">Features</h2>
<p>目前实现的功能有:</p>
<ul>
<li>Single Page Application [单页应用]</li>
<li>Progressive Web Application [渐进式网页应用]</li>
<li>Markdown Writing [使用 Markdown 进行写作]</li>
<li>Support Code Highlight [支持代码高亮]</li>
<li>Disqus [支持 Disqus 评论]</li>
<li>Configurable [抽取配置到独立的配置文件]</li>
<li>Sitemap auto generating [自动生成 Sitemap]</li>
</ul>
<p>中间有一些跌坑之后还在纠结于没找到优雅的解决方案的地方:</p>
<ul>
<li>No Support Pre-rendering [不支持预渲染]
<blockquote>
<p>为单页应用进行预渲染,生成对应的静态 index.html,可以有效被搜索引擎收录 Vue 本身支持 webpack 的<code>prerender-spa-plugin</code>. 但<code>Vue-Material</code>的菜单展开方式是动态渲染的,所以目前还不能做到预渲染.(这里跌了几天的坑) 目前部署在 Github Pages 上的话会没有 SEO. 因为 SPA 在搜索引擎爬的时候会先返回一个 404,再根据 Github 的约定返回 404.html. 搜索引擎就把该 url 当成失效的链接. 部署在 VPS 上的话支持 SEO.</p>
</blockquote>
</li>
</ul>
<h2 id="development">Development</h2>
<h3 id="dependencies">Dependencies</h3>
<p>为了实现与 Angular 版本相同的效果,才用的 Vue 全家桶 + 其他主要的库是</p>
<ul>
<li>Vue [2.3.2]</li>
<li>Vuex</li>
<li>Vue-Router</li>
<li>VueMaterial</li>
<li>Axios [前后端通用的 http 请求框架]</li>
<li>Marked [Markdown 解析部分]</li>
<li>Hightlight.js [为 Markdown 的代码片段渲染出高亮效果]</li>
</ul>
<h3 id="development-course">Development Course</h3>
<p>从头到尾,大概的功能开发思路是如此的:</p>
<ol>
<li>阅读 Vue + Vuex + Vue-Router 的文档</li>
<li>学习 Vue-Webpack Template 中的项目结构与构建方式</li>
<li>重写基于 Marked 的 Markdown Post API</li>
<li>确定基本的 Gulp 构建任务流</li>
<li>以纯 ES6 的方式修改 Webpack 与 Gulp 任务流</li>
<li>使用 Vue 全家桶完成基本界面开发</li>
<li>重构应用部分的代码成模块化加载方式</li>
<li>添加 PWA,Sitemap 等功能</li>
<li>添加 CI 配置</li>
</ol>
<h2 id="usage-document">Usage &amp; Document</h2>
<p>参见: <a href="https://github.com/Aquariuslt/Blog/tree/VUE#usage">Blog App Usage</a></p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/57/800/300"/>
        </item>
        <item>
            <title><![CDATA[Blog Structure Update]]></title>
            <link>https://blog.aquariuslt.com/posts/2017/03/12/new-version-blog-migration</link>
            <guid>https://blog.aquariuslt.com/posts/2017/03/12/new-version-blog-migration</guid>
            <pubDate>Sun, 12 Mar 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[最近正在接触学习`Angular2`+`RxJS`相关知识.当`Angular`发布了`@angular/cli`之后, 内置的 webpack 工作流程提供了一个官方推荐的比较完整的编译,打包,配置]]></description>
            <content:encoded><![CDATA[<h1 id="blog-structure-update">Blog Structure Update</h1>
<h2 id="background">Background</h2>
<p>最近正在接触学习<code>Angular2</code>+<code>RxJS</code>相关知识.当<code>Angular</code>发布了<code>@angular/cli</code>之后, 内置的 webpack 工作流程提供了一个官方推荐的比较完整的编译,打包,配置切换的工作流程, 使得其在工程化方面显得有板有眼,愈发被我所接受.</p>
<p>于是使用<code>Angular2</code>+完成度极低<code>@angular/material</code>重写之前的 Blog 框架.</p>
<h2 id="features">Features</h2>
<p>基于<code>Angular2</code>所提供的解决方案,相对之前用<code>Angular1</code>版本,提供了如下新功能:(包括但不限于 Angular 本身)</p>
<ol>
<li>支持自己文章的一些新定义的 metadata. 比如有些文章属于特殊的 category,不会显示在首页上. 只有从 category 下面进去看到对应的文章.</li>
<li>新的边框主题色,通过在 HTML header 里面声明<code>theme-color</code>来实现.</li>
<li>支持渐进式网页应用 <a href="https://developers.google.com/web/progressive-web-apps/">Progressive Web Apps</a>. 通过现代的移动浏览器,已经可以添加一个离线的快捷方式查看.</li>
</ol>
<p>通过 Chrome 浏览的时候提示可以添加到桌面</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c5750dd1641.png" alt="通过Chrome浏览的时候提示可以添加到桌面"></p>
<p>桌面版本也可以可以添加快捷方式,像桌面版本的 Google Keep 一样</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c576a266e6f.png" alt="桌面版本快捷方式"></p>
<p>添加成功后桌面会有一个快捷方式</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c57510236a3.png" alt="添加成功后桌面会有一个快捷方式"></p>
<p>打开快捷方式会有一个自定义的启动动画</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c5750dc2499.png" alt="打开快捷方式会有一个默认的启动动画"></p>
<pre><code>颜色,图表可通过PWA提供的manifest.webapp来配置
</code></pre>
<p>此外,还有如下变化:</p>
<ol>
<li>通过<a href="https://www.cloudflare.com/">CloudFlare</a>提供的免费 SSL 证书 全站 https.</li>
<li>修改了构建出来的文章形式,返回的文章信息以过滤后的 token 形式,数据文件大小更小了.</li>
</ol>
<h2 id="todo">TODO</h2>
<ol>
<li>修改了解析后的文章段落的标题,添加一个 TOC 的实现</li>
<li>添加代码块的语法高亮</li>
<li>添加大量过场动画</li>
<li>添加 GFM,FlowChart 的支持</li>
</ol>
<h2 id="finally">Finally</h2>
<p>代码位于<a href="https://github.com/Aquariuslt/Site">https://github.com/Aquariuslt/Site</a> 的新默认分支<code>NG2</code>下.</p>
<p>之前版本的文章与内容,还是保留在<a href="https://aquariuslt.com">https://aquariuslt.com</a>中.</p>
<pre><code>文章的源文件内容和Schema并没有大的改动,只是在源代码里面加多了一些metadata的解析工作.
正在准备逐步迁移过来,并且删除掉那些经过自我检讨之后没有什么卵用的垃圾文章.
</code></pre>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/237/800/300"/>
        </item>
        <item>
            <title><![CDATA[Year in Review 2016]]></title>
            <link>https://blog.aquariuslt.com/posts/2017/01/01/review-2016</link>
            <guid>https://blog.aquariuslt.com/posts/2017/01/01/review-2016</guid>
            <pubDate>Sun, 01 Jan 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[今年只能算是不差的一年.下半年没怎么更新博客,因为一直打算在用`angular2`+`SpringBoot Series`来更新下一代系统.反复修改都赶不上最新的 Dev Guideline..后来`]]></description>
            <content:encoded><![CDATA[<h1 id="year-in-review-2016">Year in Review 2016</h1>
<h2 id="the-year-not-bad">The Year Not bad</h2>
<blockquote>
<p>今年只能算是不差的一年.</p>
</blockquote>
<p>下半年没怎么更新博客,因为一直打算在用<code>angular2</code>+<code>SpringBoot Series</code>来更新下一代系统.</p>
<p>反复修改都赶不上最新的 Dev Guideline..</p>
<p>后来<code>Material2</code> beta component 也越来越多了.</p>
<p>家里也有一些烦心的事情,几度接近崩溃.</p>
<p>(并不是因为 7.0 开了好吗)</p>
<h2 id="study-progress">Study Progress</h2>
<p>新年定下好几个目标, 加上公司制定的一些学习计划. 到现在只能说完成了一半,有一部分没有达到所谓的进阶的目的.(花的时间应该差不多了,但是效率奇低,没有质变的提升)</p>
<p>硬要从语言层次划分的话</p>
<ul>
<li>JS/TS ****</li>
<li>Java **</li>
</ul>
<p>接下来的半年计划,应该是以完成去年定下的学习目标为主</p>
<h2 id="new-pc">New PC</h2>
<p>一开始换了 4K 显示器的时候,老 PC 的 GTX460 估摸着不能输出 2K 以上分辨率的信号. 适逢老黄 1000 系列的卡横空出世,看到 GTX1060 以相同的功耗性能怒草上一代 GTX980 的评测,一下长草就下单了个 1060.</p>
<p>结果回来插在 H61 主板上面,把电源和主板炸了..</p>
<p>真是&quot;3000 预算进卡吧 四路泰坦带回家&quot;的节奏.立马把 1060 退了,老的 CPU 出了二手,准备下单新 PC.</p>
<p>结果就变成这样了...</p>
<p>老黄坑了一把,说好的新架构 Mac WebDriver 呢?</p>
<p>我一直在等待 WebDriver 的出现带动黑苹果</p>
<p><img src="https://wx2.sinaimg.cn/large/7755dd69gy1fceizh66juj215u16m79s.jpg" alt="6700K+32G+GTX1070"></p>
<h2 id="google-pixel">Google Pixel</h2>
<p>新一代亲儿子,贵的出汁.</p>
<p>除了三星 P 拍 AMOLED 屏 比 Nexus5 的 IPS 观感要差之外,其他完美.</p>
<h2 id="summary">Summary</h2>
<p>On the way go.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/1072/800/300"/>
        </item>
        <item>
            <title><![CDATA[蜗居]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/07/05/move-to-new-apartment</link>
            <guid>https://blog.aquariuslt.com/posts/2016/07/05/move-to-new-apartment</guid>
            <pubDate>Tue, 05 Jul 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[毕业差不多有一年了,毕业时候租的一年的房子也到期了.  
适逢有同事已经住到 15 年新建好的唐家人才公寓那边,那边房子环境不错,打听到详细情况后,发现最吸引我的还是里面两点:里面没有家具,需要自己购]]></description>
            <content:encoded><![CDATA[<h1 id="蜗居">蜗居</h1>
<h2 id="前言">前言</h2>
<p>毕业差不多有一年了,毕业时候租的一年的房子也到期了.<br>
适逢有同事已经住到 15 年新建好的唐家人才公寓那边,那边房子环境不错,打听到详细情况后,发现最吸引我的还是里面两点:</p>
<blockquote>
<ol>
<li>里面没有家具,需要自己购置</li>
<li>合同是跟华发物业签而非个人房东</li>
</ol>
</blockquote>
<p>这两点真的是太适合我了,一方面是租房合同可以随时终止,而且不用跟各种恶毒的个人房东打交道,二是新交的房子没有家具. 就不用担心租到不合适的房子看到家具风格不搭心里长草.</p>
<p>从提交申请,审核,到正式通知抽签选房,签合同入住大概经历了快三个月.<br>
三月初提交的申请,劳动节之后终于通知下来去抽签.</p>
<p>一层的户型图大概如下图: 从结构上分,个人申请只能申请一房一厅或者单身公寓了.<br>
<img src="https://ww3.sinaimg.cn/large/006tNbRwgw1f5nswirc5fj30zk0my42b.jpg" alt="IMG_0916.JPG"> 抽到了个 08 户型,一房一厅,实用面积才 30 多.</p>
<h2 id="布置">布置</h2>
<h3 id="空无一物的房间">空无一物的房间</h3>
<p>签完合同刚拿到房子的时候,房间里面除了空调和稍微有点像样的厨房灶台之后,其他空无一物,显得比较空洞.<br>
大概是这样子的:</p>
<h4 id="空洞的过道">空洞的过道</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5ntaislpcj31kw23u1i4.jpg" alt="空洞的过道"></p>
<h4 id="空洞的客厅">空洞的客厅</h4>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1f5ntaknst1j31kw23ue5u.jpg" alt="空洞的客厅"></p>
<h4 id="空洞的睡房">空洞的睡房</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5ntanbwkbj31kw23ue7y.jpg" alt="空洞的睡房"></p>
<h4 id="空洞的厨房">空洞的厨房</h4>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwgw1f5ntadsxnvj31kw23ux4c.jpg" alt="空洞的厨房"></p>
<h4 id="空洞的阳台">空洞的阳台</h4>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1f5ntaqatgsj31kw23ub29.jpg" alt="空洞的阳台"></p>
<h3 id="购置刚需家具">购置刚需家具</h3>
<p>距离之前租的房子大概还有半个月到期,购置刚需家具就成了午休时间的任务.<br>
由于我已经有一张黑胡桃色的电脑桌,所以整体的家具都选用棕色/黑胡桃色吧.<br>
根据刚需的优先级,大概列了一下:</p>
<blockquote>
<p>拐角电脑桌 &gt;= 床 &gt; 电脑椅 &gt;&gt; 书柜 &gt;&gt; 衣柜</p>
</blockquote>
<p>家电的话,大概就只有</p>
<blockquote>
<p>洗衣机 &gt;&gt; 电饭煲</p>
</blockquote>
<h3 id="安装与布置">安装与布置</h3>
<p>陆续请了几个半天年假去办妥水电网络等各种开通手续之后,床和拐角电脑桌也送到了. 花了一个下午才把他们装好. 接着爸妈给我送来了窗帘和碗碟,还有一些大大小小的厨具~</p>
<p>五月下旬住进去之后一直没有买书柜和室内的晾衣架,直到前几天才送到,感觉现在就差个舒适的床垫就完美了~</p>
<p>下面是上图时间:</p>
<h4 id="大门过道就加了一个垫子">大门过道就加了一个垫子</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5nze6dxhqj31kw23u7rf.jpg" alt="21:37:44.jpg"></p>
<h4 id="只有骨架的电脑桌">只有骨架的电脑桌</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5nzfqeev8j31kw2t4hdt.jpg" alt="21:39:14.jpg"></p>
<h4 id="上百螺丝还要反过来装">上百螺丝还要反过来装</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5nzstrui8j31kw23unoc.jpg" alt="21:51:48.jpg"></p>
<h4 id="安装完毕-配上西昊-m18-p2415q2414h-强-无敌">安装完毕 配上西昊 M18 P2415Q+2414H 强 无敌</h4>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgw1f5nzxwv747j31kw16ok78.jpg" alt="21:56:42.jpg"></p>
<h4 id="原来的电脑桌变成了饭桌">原来的电脑桌变成了饭桌</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5nzymbcpmj31kw16onej.jpg" alt="21:57:22.jpg"></p>
<h4 id="室内衣架和一个杂物柜">室内衣架和一个杂物柜</h4>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1f5nz6fvo2vj31kw23ue5w.jpg" alt="21:30:18.jpg"></p>
<h4 id="低到类似榻榻米的床与床头柜">低到类似榻榻米的床与床头柜</h4>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1f5nz4wdp7sj31kw16owvj.jpg" alt="21:28:49.jpg"></p>
<h4 id="楼再高一点就是海景啦">楼再高一点就是海景啦</h4>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgw1f5o02np97tj31kw23unp4.jpg" alt="22:01:15.jpg"></p>
<h2 id="憧憬">憧憬</h2>
<p>配置齐全 感觉每天晚上专注 <s>学习</s> 的时间变长了. <code>wakatime</code>的 report <img src="https://ww1.sinaimg.cn/large/006tNbRwgw1f5o0br69xbj31kw0kmtc0.jpg" alt="22:10:03.jpg"></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgw1f5o0lgzik4j30q209adgk.jpg" alt="22:19:24.jpg"></p>
<p>希望在如此好的环境中,学习和工作效率会变得越来越高~</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/192/800/300"/>
        </item>
        <item>
            <title><![CDATA[Angular.js常规性能优化阶段总结]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/04/30/angular-ui-performance-tuning-experience</link>
            <guid>https://blog.aquariuslt.com/posts/2016/04/30/angular-ui-performance-tuning-experience</guid>
            <pubDate>Sat, 30 Apr 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[最近在为项目进行性能优化的时候,有总结到一些经验.  
现在梳理一遍,方便以后排查问题.在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.  
其中非常推荐一些前端大牛的博客]]></description>
            <content:encoded><![CDATA[<h1 id="angularjs-常规性能优化阶段总结">Angular.js 常规性能优化阶段总结</h1>
<h2 id="background">Background</h2>
<p>最近在为项目进行性能优化的时候,有总结到一些经验.<br>
现在梳理一遍,方便以后排查问题.</p>
<h2 id="references">References</h2>
<p>在进行 Angular 页面的性能测试以及学习优化手段之前,查阅了挺多资料.<br>
其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.</p>
<p>下面是一些推荐阅读的博客,给我提供了很多帮助,加深了对 Angular 的认识.</p>
<ul>
<li><a href="https://github.com/xufei/blog/">xufei blog</a> ...准备贴下一个地址的时候,居然发现这个知乎的地址居然也是 xufei 大大的回答. 恩.应该提供最有价值帮助的就是他了.</li>
</ul>
<h2 id="solutions">Solutions</h2>
<h3 id="pluginsangularjs-batarang">Plugins:AngularJS Batarang</h3>
<p>利用 Angular 官方开发的 Chrome 插件<code>AngularJS Batarang</code>来监控页面性能.<br>
<a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk">Angular Batarang</a><br>
<img src="https://img.aquariuslt.com/posts/2016/04/performance.webp" alt="运行截图"></p>
<p>通过<code>Angular Batarang</code>,我们可以轻易的统计在页面的<code>watcher</code>数量,<code>$scope</code>中变量的数量. 还有平均一段时间内<code>angular</code>执行<code>$digest</code>的数量.</p>
<p>对于代码不熟悉的项目前端,查找分析性能瓶颈的时候,可以通过通过该插件进行二分对于,快速定位出瓶颈处. 当然,如果在对 angular 比较熟悉,在开发的过程中也遵循了常见的性能优化约定,该插件的监控作用就不大. 最后还是只能通过其他手段细化性能瓶颈定位粒度.</p>
<p>经过本人测试,对于大部分使用 Angular 的页面都支持良好.(可惜不支持 CommonJS 打包成的我的主站的分析)</p>
<h3 id="once-binding">Once Binding</h3>
<p>在常见的 CRUD 系统中,我们经常会遇到很多数据展示的区域,但是这些数据一旦渲染好,一般不需要强刷新. 比如页面标题,菜单选项等不需要实时更新的情况.所以这时候可以通过<code>Once Binding</code>,即一次绑定,渲染一次即可,不必监控该表达式.</p>
<p>之前遇到的情况是,我们的页面 header 会有一个通知栏,展开会通知那些已经显示的列表.<br>
单条通知样子类似于微博的这种:<br>
<img src="https://img.aquariuslt.com/posts/2016/04/notification.webp" alt="通知栏"> 在没优化之前,通知部分的伪代码如下:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"notification"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"notification in vm.displayNotifications"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"{{notification.targetUrl}}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{notifications.title}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{notifications.summary}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{notifications.time}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>经过一轮生产环境数据统计,某部分用户的未读通知范围会在 200 - 7W 条.<br>
哈哈看到就尿了,如果这么算的话,7W 条的那个用户页面将会有至少 7W*4 = 28W 的 watcher 在监听他们的变化.<br>
且不论数据为什么需要全部渲染出来,如果将代码修改成 Once Binding,则页面的长期 watcher 数量将会减少 28W 个.</p>
<p>特别是对于使用了<code>ng-repeat</code>的元素,一定要考虑将</p>
<p>使用一次绑定表达式之后如下</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"notification"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"notification in vm.displayNotifications"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"{{::notification.targetUrl}}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{::notifications.title}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{::notifications.summary}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{::notifications.time}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="use-variable-instead-function-expression">Use variable instead function expression</h3>
<p>之前遇到一个需求,在业务逻辑上需要显示一个模型,这个模型大概是下面这样的:</p>
<pre><code class="hljs json">{
  <span class="hljs-attr">"businessKeys"</span>: [
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"a"</span>,
      <span class="hljs-attr">"value"</span>: <span class="hljs-string">"aValue"</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"b"</span>,
      <span class="hljs-attr">"value"</span>: <span class="hljs-string">"bValue"</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"c"</span>,
      <span class="hljs-attr">"value"</span>: <span class="hljs-string">"cValue"</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"c"</span>,
      <span class="hljs-attr">"value"</span>: <span class="hljs-string">"cValue"</span>
    }
  ],
  <span class="hljs-attr">"otherInfo"</span>: <span class="hljs-string">"otherInfo..."</span>
}
</code></pre>
<p>在字段里面是有一个不定长的数组,数组里面实际上是一堆 key-value 形式的键值对. 之所以不定长是因为里面有时候有些 key 是没有对应的值的. 在 UI 上显示出来的时候,先前的做法就是绑定一个方法:</p>
<pre><code>{{vm.getValueByBusinessKeysType(object,keyName)}}
</code></pre>
<p>在页面上使用一个方法表达式而不是直接的变量表达式的时候,会导致方法执行多次. 由于这个<code>getValueByBusinessKeysType</code>的方法,需要通过数组查找而不是直接一个 map 所以就会导致性能问题.</p>
<p>目前的解决方案是:将数据在加载的时候经过扁平化处理,即将 key 直接以 property 的形式直接赋予 Object. 通过直接绑定 property 表达式来显示. 这样也有效提高了一些性能</p>
<h3 id="chain-filter">Chain Filter</h3>
<p>Angular 的 Filter 性能一直不够好. 在刚刚接触 Angular 的时候,阅读文档发现 Filter 的功能还挺好用的,特别是做一些关键字过滤表格数据,格式处理等方面的工作,<br>
实在是太方便了,于是我们在为我们的 table 的 header 上每个 column 都添加了一个关键字过滤框,使用 angular 的 filter 做分页的工作.</p>
<p>由于我们的表格需要显示的业务数据比较多,column 数大概在 15-25 左右. 在每一个 header 的 column 上添加独立的关键字过滤框,大概就添加了 20 个.</p>
<p>假设当前页面的总数据 会有有 30 条. 用户喜欢在几个过滤框上输入一些相关的关键字信息过滤.(filterA,filterB)</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterA</span>(<span class="hljs-params">dataArray, filterCriteria</span>) </span>{
  <span class="hljs-keyword">return</span> filteredDataArrayByFilterCriteriaA;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterB</span>(<span class="hljs-params">dataArray, filterCriteria</span>) </span>{
  <span class="hljs-keyword">return</span> filteredDataArrayByFilterCriteriaB;
}
</code></pre>
<p>当每一个过滤框都属于一个单独的 filter 去绑定的话,如果执行 AB filter,将会按照下面的顺序执行</p>
<blockquote>
<p><code>dataArray</code> length:30 <code>filteredDataArrayByFilterCriteriaA</code> (至少两次 filterA,此时 length 约 20)<br>
<code>filteredDataArrayByFilterCriteriaB</code> (至少两次 filterB,此时 length 约 5)</p>
</blockquote>
<p>如果我们在计算关键字过滤的时候使用的是遍历查询,以单次对单个元素对比的操作工作量为 1.<br>
那么在这两重 filter 的总计算工作量就会变成<code>30*2+20*2=100</code>次</p>
<p>回到实际业务,通过在 filter 中添加 log 来记录 filter 循环运算的次数,惊讶的发现实际上 filter 的运算次数在 25 个 column 的情况下,<br>
普遍一次过滤框的查询,会导致 3K 左右的运算次数,相当惊人.</p>
<p>目前的解决方案是通过降低工程代码的可读性,将多个 filter 的功能合并成一个总的 filter,在总的 filter 里面处理一连串的单个 filter 过滤过程.</p>
<p>之前的代码可能是这样:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"singleData in vm.dataArray | filterA | filterB | filterC ..... | filterZ"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterA</span>(<span class="hljs-params">dataArray</span>) </span>{
  <span class="hljs-comment">//implement filterA</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterB</span>(<span class="hljs-params">dataArray</span>) </span>{
  <span class="hljs-comment">//implement filterB</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterC</span>(<span class="hljs-params">dataArray</span>) </span>{
  <span class="hljs-comment">//implement filterC</span>
}
</code></pre>
<p>合并之后看起来是这样</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"singleData in vm.dataArray | combinedFilter"</span>
</span></code></pre>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combinedFilter</span>(<span class="hljs-params">dataArrat</span>) </span>{
  <span class="hljs-comment">//implement filterA</span>
  <span class="hljs-comment">//implement filterB</span>
  <span class="hljs-comment">//implement filterC</span>
}
</code></pre>
<h3 id="using-ng-model-option-delay-update">Using ng-model-option delay update</h3>
<p>因为使用了 angular 的 filter 功能做前端的关键词过滤,实际上所有的查询工作都是同步的. 因为是同步,所以在前端 javascript 进行相对较密集的查询运算的时候,卡顿就会相当明显. 如果对过滤输入框进行了<code>ng-model</code>的绑定,则当输入框的内容进行改变的时候,会立刻出发 filter 运算. 通常用户输入的时候大部分可能是连续的单词或者子字符串的输入,在一次主观上的输入还没有结束的时候,因为输入框中文字的改变,<br>
而频繁触发查询,实际上页面性能也会相当不好. 这里有一个小 tips 就是为一些实时查询性不是很高的输入区域添加 ng-model-options,增加 angular 检查数据 update 的时间间隔, 相当于可以等用户把想要的搜索关键词输入完毕之后,再执行 js 代码的查询工作.</p>
<h2 id="summary">Summary</h2>
<p>本次结合了一些实际工作中使用 angular 遇到的性能问题的解决方案,当然也有遇到一些与原生 js,socket.io 相关的性能问题. 由于 tag 不同,不混淆在一起说了.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/872/800/300"/>
        </item>
        <item>
            <title><![CDATA[Google CodeJam 2016 Qualification]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/04/10/google-codejam-2016-qualification-round</link>
            <guid>https://blog.aquariuslt.com/posts/2016/04/10/google-codejam-2016-qualification-round</guid>
            <pubDate>Sun, 10 Apr 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[今早结束的 Google CodeJam 2016 资格赛. 由于智商问题和加班了一天,所以只能水出前面两道水题. 但是还是稍微涨了点姿势. 记录下解题的过程和一些小彩蛋.将我的 A 和 B 的 So]]></description>
            <content:encoded><![CDATA[<h1 id="google-codejam-2016-qualification">Google CodeJam 2016 Qualification</h1>
<p>今早结束的 Google CodeJam 2016 资格赛. 由于智商问题和加班了一天,所以只能水出前面两道水题. 但是还是稍微涨了点姿势. 记录下解题的过程和一些小彩蛋.</p>
<p>将我的 A 和 B 的 Solution 放在<a href="https://github.com/Aquariuslt/CodeJam">Github</a>上了.</p>
<h2 id="a-counting-sheep">A: Counting Sheep</h2>
<h3 id="problem-description">Problem Description</h3>
<p>Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number N. Then she starts naming N, 2 × N, 3 × N, and so on. Whenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.</p>
<p>Bleatrix must start with N and must always name (i + 1) × N directly after i × N. For example, suppose that Bleatrix picks N = 1692. She would count as follows:</p>
<p>N = 1692. Now she has seen the digits 1, 2, 6, and 9. 2N = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9. 3N = 5076. Now she has seen all ten digits, and falls asleep. What is the last number that she will name before falling asleep? If she will count forever, print INSOMNIA instead.</p>
<p>Input</p>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line with a single integer N, the number Bleatrix has chosen.</p>
<p>Output</p>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the last number that Bleatrix will name before falling asleep, according to the rules described in the statement.</p>
<p>Limits</p>
<p>1 ≤ T ≤ 100. Small dataset</p>
<p>0 ≤ N ≤ 200. Large dataset</p>
<p>0 ≤ N ≤ 10^6. Sample</p>
<p>Input</p>
<pre><code>5
0
1
2
11
1692
</code></pre>
<p>Output</p>
<pre><code>Case #1: INSOMNIA
Case #2: 10
Case #3: 90
Case #4: 110
Case #5: 5076
</code></pre>
<p>In Case #1, since 2 × 0 = 0, 3 × 0 = 0, and so on, Bleatrix will never see any digit other than 0, and so she will count forever and never fall asleep. Poor sheep! In Case #2, Bleatrix will name 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. The 0 will be the last digit needed, and so she will fall asleep after 10. In Case #3, Bleatrix will name 2, 4, 6... and so on. She will not see the digit 9 in any number until 90, at which point she will fall asleep. By that point, she will have already seen the digits 0, 1, 2, 3, 4, 5, 6, 7, and 8, which will have appeared for the first time in the numbers 10, 10, 2, 30, 4, 50, 6, 70, and 8, respectively. In Case #4, Bleatrix will name 11, 22, 33, 44, 55, 66, 77, 88, 99, 110 and then fall asleep. Case #5 is the one described in the problem statement. Note that it would only show up in the Large dataset, and not in the Small dataset.</p>
<h3 id="translation">Translation</h3>
<p>这道题相当容易读懂,表面意思就是: 一个叫<code>Bleatrix</code>的家伙睡觉之前喜欢数羊咩,但是他要数到一定条件才睡得着. 他每次会从一个数字<code>N</code>开始数.第一下数<code>N</code>,第二下数<code>2*N</code>...第 M 下数<code>M*N</code>. 当从开始数到后面,一直到出现过的数字包含了<code>1234567890</code>所有数字的时候就会睡着了. 求的是数字<code>N</code>对应的让他能够睡着的那个数.</p>
<h3 id="solution">Solution</h3>
<p>做法是用一个从 N 开始枚举. 出现过的数字用<code>HashSet</code>来保存,每出现一个数字的时候,将该数字按照每一位拆分,打进这个<code>HashSet</code>里面. 当<code>HashSet</code>的长度大于等于 10 的时候跳出循环.</p>
<h3 id="source-code">Source Code</h3>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aquariuslt.codejam;

<span class="hljs-keyword">import</span> com.aquariuslt.codejam.utils.Reader;

<span class="hljs-keyword">import</span> org.junit.Test;

<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/** Created by Aquariuslt on 4/9/16.*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSheep</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numberOfCases;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> startSheepNumber[];
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> result[];


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span>{
        InputStream inputStream = ClassLoader.getSystemResourceAsStream(<span class="hljs-string">"A/A-large.in"</span>);
        Reader.init(inputStream);
        <span class="hljs-keyword">try</span>{
            numberOfCases = Reader.nextInt();
            startSheepNumber = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numberOfCases];
            result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numberOfCases];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numberOfCases;i++){
                startSheepNumber[i] = Reader.nextInt();
            }
        }
        <span class="hljs-keyword">catch</span> (Exception e){
            <span class="hljs-comment">//Do nothing</span>
        }

    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numberOfCases;i++){
            result[i] = solveSingleNumber(startSheepNumber[i]);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solveSingleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> singleNumber)</span></span>{
        Set&lt;Integer&gt; digitalSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">if</span>(singleNumber==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">int</span> currentNumber = singleNumber;
            <span class="hljs-keyword">while</span>(digitalSet.size()&lt;<span class="hljs-number">10</span>){
                digitalSet.addAll(convertIntToDigitalSet(currentNumber));
                currentNumber += singleNumber;
            }
            <span class="hljs-keyword">return</span> currentNumber;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">convertIntToDigitalSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>{
        <span class="hljs-keyword">int</span> currentNumber = number;
        Set&lt;Integer&gt; digitalSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">while</span>(currentNumber/<span class="hljs-number">10</span>&gt;<span class="hljs-number">0</span>){
            digitalSet.add(currentNumber % <span class="hljs-number">10</span>);
            currentNumber = currentNumber/<span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">return</span> digitalSet;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numberOfCases;i++){
            <span class="hljs-keyword">if</span>(result[i] == <span class="hljs-number">0</span>){
                System.out.printf(<span class="hljs-string">"Case #%d: INSOMNIA\n"</span>,(i+<span class="hljs-number">1</span>));
            }
            <span class="hljs-keyword">else</span>{
                System.out.printf(<span class="hljs-string">"Case #%d: %d\n"</span>,(i+<span class="hljs-number">1</span>),result[i]);
            }
        }
    }


    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCountingSheep</span><span class="hljs-params">()</span> </span>{
        input();
        solve();
        output();
    }
}

</code></pre>
<h2 id="b-revenge-of-the-pancakes">B: Revenge of the Pancakes</h2>
<h3 id="problem-description-2">Problem Description</h3>
<p>The Infinite House of Pancakes has just introduced a new kind of pancake! It has a happy face made of chocolate chips on one side (the &quot;happy side&quot;), and nothing on the other side (the &quot;blank side&quot;).</p>
<p>You are the head waiter on duty, and the kitchen has just given you a stack of pancakes to serve to a customer. Like any good pancake server, you have X-ray pancake vision, and you can see whether each pancake in the stack has the happy side up or the blank side up. You think the customer will be happiest if every pancake is happy side up when you serve them.</p>
<p>You know the following maneuver: carefully lift up some number of pancakes (possibly all of them) from the top of the stack, flip that entire group over, and then put the group back down on top of any pancakes that you did not lift up. When flipping a group of pancakes, you flip the entire group in one motion; you do not individually flip each pancake. Formally: if we number the pancakes 1, 2, ..., N from top to bottom, you choose the top i pancakes to flip. Then, after the flip, the stack is i, i-1, ..., 2, 1, i+1, i+2, ..., N. Pancakes 1, 2, ..., i now have the opposite side up, whereas pancakes i+1, i+2, ..., N have the same side up that they had up before.</p>
<p>For example, let's denote the happy side as + and the blank side as -. Suppose that the stack, starting from the top, is --+-. One valid way to execute the maneuver would be to pick up the top three, flip the entire group, and put them back down on the remaining fourth pancake (which would stay where it is and remain unchanged). The new state of the stack would then be -++-. The other valid ways would be to pick up and flip the top one, the top two, or all four. It would not be valid to choose and flip the middle two or the bottom one, for example; you can only take some number off the top.</p>
<p>You will not serve the customer until every pancake is happy side up, but you don't want the pancakes to get cold, so you have to act fast! What is the smallest number of times you will need to execute the maneuver to get all the pancakes happy side up, if you make optimal choices?</p>
<p>Input</p>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line with a string S, each character of which is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up). The string, when read left to right, represents the stack when viewed from top to bottom.</p>
<p>Output</p>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of times you will need to execute the maneuver to get all the pancakes happy side up.</p>
<p>Limits</p>
<p>1 ≤ T ≤ 100. Every character in S is either + or -.</p>
<p>Small dataset</p>
<p>1 ≤ length of S ≤ 10. Large dataset</p>
<p>1 ≤ length of S ≤ 100. Sample</p>
<p>Input</p>
<pre><code>5
-
-+
+-
+++
--+-
</code></pre>
<p>Output</p>
<pre><code>Case #1: 1
Case #2: 1
Case #3: 2
Case #4: 0
Case #5: 3
</code></pre>
<p>In Case #1, you only need to execute the maneuver once, flipping the first (and only) pancake. In Case #2, you only need to execute the maneuver once, flipping only the first pancake. In Case #3, you must execute the maneuver twice. One optimal solution is to flip only the first pancake, changing the stack to --, and then flip both pancakes, changing the stack to ++. Notice that you cannot just flip the bottom pancake individually to get a one-move solution; every time you execute the maneuver, you must select a stack starting from the top. In Case #4, all of the pancakes are already happy side up, so there is no need to do anything.(这里他们打错成<code>anthing</code>了.) In Case #5, one valid solution is to first flip the entire stack of pancakes to get +-++, then flip the top pancake to get --++, then finally flip the top two pancakes to get ++++.</p>
<h3 id="translation-2">Translation</h3>
<p>这道题原意是这样子的: 大概就是翻蛋糕.给出一个字符串,只包含<code>-</code>和<code>+</code>两个部分 分别代表正面和反面. 如果给出的字符串是<code>--+-</code> 那么在实际中,蛋糕的摆放会是这样子的:</p>
<p>反面朝上反面朝上正面朝上反面朝上 <em>---我是底盘---</em> <em>-我是伺应的手-</em></p>
<p>有一个铲子每次都能够在两层蛋糕之间插入,然后将这个铲上面的所有蛋糕一次铲起来! 接着将这些铲起来的蛋糕连着一起反过来,再放回盘子上.</p>
<p>目标是给出一个这样排列的蛋糕序列,求用铲子操作多少次能够将蛋糕全部变成向上的状态.</p>
<h3 id="solution-2">Solution</h3>
<p>有一种思路就是从右往左开始遍历,当遇到目前一个层次是反面的时候,就进行一次<code>翻面</code>操作. 为了记录当前一个蛋糕的面实际是向上还是向下,我设定了一个 flag 与最原先输入的当前蛋糕面状态进行异或操作,得到当前面的状态.</p>
<p>即</p>
<pre><code>private int solveSingleCase(int[] pancakeArray) {
    int revengeCount = 0;
    int revengeFlag = 0;
    for (int pancakeLength = pancakeArray.length, i = pancakeLength - 1; i &gt;= 0; i--) {
        if ((pancakeArray[i] ^ revengeFlag) == 0) { //通过异或得出当前的面实际朝向.
            revengeCount++;
            revengeFlag = 1 - revengeFlag;
        }
    }
    return revengeCount;
}
</code></pre>
<h3 id="source-code-2">Source Code</h3>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aquariuslt.codejam;

<span class="hljs-keyword">import</span> com.aquariuslt.codejam.utils.Reader;

<span class="hljs-keyword">import</span> org.junit.Test;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;

<span class="hljs-comment">/** Created by Aquariuslt on 4/9/16.*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RevengePancakes</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_STRING_LENGTH = <span class="hljs-number">101</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> caseCount;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] pancakeIntArray;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] result;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>{
        InputStream inputStream = ClassLoader.getSystemResourceAsStream(<span class="hljs-string">"B/B-large.in"</span>);
        Reader.init(inputStream);
        <span class="hljs-keyword">try</span> {
            caseCount = Reader.nextInt();
            result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[caseCount];
            pancakeIntArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[caseCount][MAX_STRING_LENGTH];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; caseCount; i++) {
                String currentPancakeString = Reader.next();
                pancakeIntArray[i] = convertStringToInt(currentPancakeString);
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-comment">//e.printStackTrace();</span>
        }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] convertStringToInt(String currentPancakeString) {
        <span class="hljs-keyword">int</span> currentPancakeStringLength = currentPancakeString.length();
        <span class="hljs-keyword">int</span>[] currentPancakeIntArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[currentPancakeStringLength];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, strLength = currentPancakeString.length(); i &lt; strLength; i++) {
            currentPancakeIntArray[i] = currentPancakeString.charAt(i) == <span class="hljs-string">'+'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> currentPancakeIntArray;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, length = result.length; i &lt; length; i++) {
            result[i] = solveSingleCase(pancakeIntArray[i]);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solveSingleCase</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pancakeArray)</span> </span>{
        <span class="hljs-keyword">int</span> revengeCount = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> revengeFlag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pancakeLength = pancakeArray.length, i = pancakeLength - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> ((pancakeArray[i] ^ revengeFlag) == <span class="hljs-number">0</span>) {
                revengeCount++;
                revengeFlag = <span class="hljs-number">1</span> - revengeFlag;
            }
        }
        <span class="hljs-keyword">return</span> revengeCount;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; caseCount; i++) {
            System.out.printf(<span class="hljs-string">"Case #%d: %d\n"</span>, (i + <span class="hljs-number">1</span>), result[i]);
        }
    }


    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRevengePancakes</span><span class="hljs-params">()</span> </span>{
        input();
        solve();
        output();
    }
}


<span class="hljs-comment">/**
 * if '-' means '0', '+' means '1' we can convert case to: Case 1: input : -            0 target: +
 * 1
 *
 * Case 2: input : -+           01 target: ++           11
 *
 * Case 3: input : +-           10 target: ++           11
 *
 * Case 4: input : +++          111 target: +++          111
 *
 * Case 5: input : --+-         0010 target: ++++         1111
 */</span>
</code></pre>
<h2 id="java-reader-in-acm">Java Reader in ACM</h2>
<p>本来一直在用<code>Java的Scanner做input</code>. 但是一直没想过如果正式比赛还真的有人用 Java 去提交,那么<code>Scanner</code>的性能到底如何呢. 很久之前看过一篇文章比较<code>cin</code>和<code>scanf</code>的性能. 然后看到了这篇文章,通过数据比较高呼<code>Java Scanner is Slooooow</code></p>
<p><a href="https://www.cpe.ku.ac.th/~jim/java-io.html">Faster Input for Java</a></p>
<p>通过比较 Java 的<code>Scanner</code>与<code>BufferedReader</code> + <code>StringTokenizer</code>来比较性能的话. 证明了<code>Scanner</code>读入输入流相对要慢 4 倍.</p>
<p>所以我在代码里面第一次使用了这种方式</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BufferedReader reader;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StringTokenizer tokenizer;

    <span class="hljs-comment">/** call this method to initialize reader for InputStream */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(InputStream input)</span> </span>{
        reader = <span class="hljs-keyword">new</span> BufferedReader(
                     <span class="hljs-keyword">new</span> InputStreamReader(input) );
        tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);
    }

    <span class="hljs-comment">/** get next word */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">while</span> ( ! tokenizer.hasMoreTokens() ) {
            tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(
                   reader.readLine() );
        }
        <span class="hljs-keyword">return</span> tokenizer.nextToken();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">return</span> Integer.parseInt( next() );
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">return</span> Double.parseDouble( next() );
    }
}
</code></pre>
<p>然后将输入文件放在 resource 里面,将输入流直接改成 resource 即可. Usage:</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSheep</span></span>{

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span>{
        InputStream inputStream = ClassLoader.getSystemResourceAsStream(<span class="hljs-string">"A/A-large.in"</span>);
        Reader.init(inputStream);
        <span class="hljs-keyword">try</span>{
            numberOfCases = Reader.nextInt();
            startSheepNumber = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numberOfCases];
            result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numberOfCases];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numberOfCases;i++){
                startSheepNumber[i] = Reader.nextInt();
            }
        }
        <span class="hljs-keyword">catch</span> (Exception e){
            <span class="hljs-comment">//Do nothing</span>
        }
    }
}
</code></pre>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/51/800/300"/>
        </item>
        <item>
            <title><![CDATA[Hadoop 2.7.2 单节点与集群安装部署]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/04/09/hadoop-2-7-2-single-node-and-cluster-mode-installation-guide</link>
            <guid>https://blog.aquariuslt.com/posts/2016/04/09/hadoop-2-7-2-single-node-and-cluster-mode-installation-guide</guid>
            <pubDate>Sat, 09 Apr 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[最近需要做一些大数据相关项目,至少需要搭建 Hadoop 的基本环境. 由于用到的是目前版本号最高的 Hadoop 2.7.2.跟文档比较多的 2.6 以下的版本相比,在部署集群的时候遇见了很多坑. ]]></description>
            <content:encoded><![CDATA[<h1 id="hadoop-272-单节点与集群安装部署">Hadoop 2.7.2 单节点与集群安装部署</h1>
<h2 id="background">Background</h2>
<p>最近需要做一些大数据相关项目,至少需要搭建 Hadoop 的基本环境. 由于用到的是目前版本号最高的 Hadoop 2.7.2.跟文档比较多的 2.6 以下的版本相比,在部署集群的时候遇见了很多坑. 所以写一份安装指南,记录一下跌坑的过程,以示警惕.</p>
<p>在环境搭建的过程中,参考了以下两篇文章: 其中 Apache 的官方 Wiki 文档写的真难读. 建议直接先看一遍 aws 的指南再动手.</p>
<p><a href="https://wiki.apache.org/hadoop/GettingStartedWithHadoop">https://wiki.apache.org/hadoop/GettingStartedWithHadoop</a> <a href="https://rstudio-pubs-static.s3.amazonaws.com/78508_abe89197267240dfb6f4facb361a20ed.html">https://rstudio-pubs-static.s3.amazonaws.com/</a></p>
<h2 id="table-of-content">Table Of Content</h2>
<p>暂不讨论 Hadoop 及基于其应用的场景描述,文本只讨论基本的环境搭建步骤和与之涉及的知识点. 按照顺序总结出本文的内容节点.</p>
<ol>
<li>
<p>宏观了解在集群上部署 Hadoop 的过程</p>
</li>
<li>
<p>虚拟机基本网络配置与机器配置</p>
</li>
<li>
<p>下载并解压 Hadoop</p>
</li>
<li>
<p>创建专为运行 Hadoop 的用户</p>
</li>
<li>
<p>环境变量的设定</p>
</li>
<li>
<p>修改 Hadoop 配置文件</p>
</li>
<li>
<p>启动 Hadoop 服务</p>
</li>
<li>
<p>防跌坑指南</p>
</li>
</ol>
<h2 id="environment-setup">Environment Setup</h2>
<h3 id="overview-how-developer-deploy-hadoop-in-cluster-mode">Overview: How Developer deploy Hadoop in cluster mode</h3>
<p>通常来说,一个运维工程师是如何部署一个 Hadoop 集群呢? 集群可以当成 1 台 Master 机器和多台 Slaves 机器. 在全新的 Linux 机器群中创建 Hadoop 集群,按我的理解可以分成以下几步.</p>
<ol>
<li>在 Master 上下载 Hadoop,并修改对应的 Hadoop 配置文件.</li>
<li>将修改好配置的 Hadoop 目录打包,分发到各个 Slave 中,解压到固定的执行目录.</li>
<li>修改所有机器的 hosts 文件,将局域网中的所有 ip-hostname 进行 mapping.</li>
<li>在所有机器上安装 ssh,Master 和 Slaves 之间将通过 ssh 进行运行时的通讯控制.</li>
<li>在 Master 上启动 Hadoop 服务.统一管理所有 Slave 节点.</li>
</ol>
<h3 id="network-and-information-about-virtual-machine">Network and Information about Virtual Machine</h3>
<p>因为只是实验集群的部署,所以没有用到真机. 实际上虚拟机内部的多台机器所组成的集群,其实总的 I/O 还是会被物理机器限制.</p>
<p>我将使用的是 1 台 Master 和两台 Slaves 三台机器都是<code>vmware</code>上的虚拟机,网络方式都是以 NAT 桥接具体的配置如下:</p>
<ul>
<li>
<p>Master: ip:192.168.239.142 hostname:elementary-os cpu:4 core ram:16G</p>
</li>
<li>
<p>Slaves: ip:192.168.239.144,192.168.239.145 hostname:hd-worker-a,hd-worker-b cpu:1 core ram:4G harddisk:20G</p>
</li>
</ul>
<p>P.S. Master 和 Slaves 都是基于 64 位的<code>Ubuntu14.04.3LTS</code>内核的 Linux. 可以视为都是通过直接安装<code>Ubuntu14.04.3.LTS</code>.</p>
<p>为了通过<code>/etc/hosts</code>文件通过机器名访问对应的 ip, 在每一个节点上面都修改对应的<code>/etc/hosts</code>文件,将集群中所有节点加到文件里面</p>
<pre><code class="hljs bash">$ sudo vi /etc/hosts
</code></pre>
<p>在文件底部添加以下几行(实际操作中,请将 hostname 替换成自己实际机器的 hostname 与 ip)</p>
<pre><code># Hadoop Cluster Setup
## Master
192.168.239.142   elementary-os

## Slaves
192.168.239.144   hd-worker-a
192.168.239.145   hd-worker-b
</code></pre>
<h3 id="download-hadoop">Download Hadoop</h3>
<p>下载地址:<a href="https://mirrors.noc.im/apache/hadoop/common/current/">https://mirrors.noc.im/apache/hadoop/common/current/</a></p>
<p>下载之后,会得到一个<code>Hadoop2.7.2</code>的解压包. 在下一步章节我们将会将其移动到其他目录.</p>
<h3 id="add-hadoop-group-and-user">Add Hadoop Group and User</h3>
<p>在所有节点上都创建一个名为<code>hduser</code>的 user,并将其加到 sudo 列表里面. 在接下来的所有 bash 命令,默认都通过该创建的<code>hduser</code>来执行.</p>
<pre><code>$ sudo addgroup hadoop
$ sudo adduser --ingroup hadoop hduser
$ sudo adduser hduser sudo
</code></pre>
<h3 id="installing-ssh-and-copy-public-key-to-remote-machine">Installing SSH and Copy Public Key to remote machine</h3>
<p>什么是 SSH SSH (“Secure SHell”) is a protocol for securely accessing one machine from another. Hadoop uses SSH for accessing another slaves nodes to start and manage all HDFS and MapReduce daemons. Hadoop 通过 ssh 之间来通讯和管理节点之间的通讯.</p>
<pre><code>$ sudo apt-get install openssh-server
</code></pre>
<p>TIPS: 通常来说,ssh 远程到另一台安装了 ssh 的机器上,通过<code>ssh {username}@{hostname}</code>,之后输入密码便可以进入. 对于一些自动化部署的脚本来说自动输入密码,还需要在脚本里面写下密码. 怎么可能如此的不科学?</p>
<p>所以需要通过 ssh key 公钥来进行认证,达到无密码传输的过程. 假设我们需要在机器上 A 通过 ssh 远程到机器 B 且不需要密码,步骤如下:</p>
<ol>
<li>在机器 A 上生成自己的 ssh 公钥与密钥</li>
</ol>
<pre><code class="hljs bash">$ ssh-keygen -t rsa
</code></pre>
<p>此举将会在 user 目录下的<code>~/.ssh</code>文件夹创建对应的 <code>id_rsa</code>和<code>id_rsa.pub</code>文件. 其中<code>id_rsa.pub</code>就是公钥文件</p>
<ol start="2">
<li>在机器 A 上将自己的公钥复制到远程主机上</li>
</ol>
<pre><code class="hljs bash">$ ssh-copy-id {username}@B
$ {username}@B password:
$ <span class="hljs-comment">#此时输入用户密码</span>
</code></pre>
<p>此举会在远程主机 B 的对应 user 的 home/.ssh 目录下创建<code>authorized_key</code>文件. 该公钥已经信任,拥有这个公钥的 A 主机用户可以直接通过<code>ssh {username}@B</code>不输入密码而直接远程到 B</p>
<p>OK.在了解到这一步之后,大概知道一台机器的主机需要如何配置 ssh 了. 因为在 Hadoop 集群中,Master 与每一台 Slaves 都需要进行 ssh 通讯, 所以需要在 Hadoop 中每一台机器都生成自己的 ssh 公钥,然后与 Master 互相进行公钥传输动作.</p>
<p>在我自己的集群中,进行了 4 次<code>ssh-copy-id</code>操作:</p>
<ol>
<li>elementary-os -&gt; hd-worker-a</li>
<li>hd-worker-a -&gt; elementary-os</li>
<li>elementary-os -&gt; hd-worker-b</li>
<li>hd-worker-b -&gt; elementary-os</li>
</ol>
<h3 id="basic-environment-setup">Basic Environment Setup</h3>
<p>在修改 Hadoop 的配置之前,需要进行配置的是所有节点的环境变量设置与必要的基础程序.</p>
<h4 id="jdk">JDK</h4>
<p>Hadoop 运行在 Java 环境中,所以每个节点都需要安装 JDK. 需要保证的是确保每一台节点上安装的 JDK 版本一致. P.S 我自己是 Master OpenJDK-8 + Slaves OpenJDK-7. 目前还是正常运行的 (顺便吐槽一下 <code>Ubuntu14.04</code>默认的 apt-get 源,相当傻逼.在不添加自己订阅的其他源的情况下连 OpenJDK8 的地址都没有,而且如果安装 Git 之类的工具,为求稳定居然用的是 1.7 以下的版本. 这也是为什么我日常开发用的是<code>elementary-os</code>,虽然也是基于 ubuntu14 的内核, 但是 elementary-os 修改了其默认的 apt 源,ui 看起来也更加顺眼)</p>
<pre><code class="hljs bash">$ sudo apt-get install openjdk-7-jdk
</code></pre>
<p>通过此举,安装的默认的 jdk 路径是<code>/usr/lib/jvm/java-7-openjdk-amd64</code>. OpenJDK8 同理. OracleJDK 也推荐复制到<code>/usr/lib/jvm</code>目录下.(守序善良 Linux 派优雅的约定之一)</p>
<p>记住这里咯.在下面我们会将这个 JDK 的目录,加到当前用户<code>hduser</code>的<code>.bashrc</code>中.</p>
<h3 id="configure-hadoop">Configure Hadoop</h3>
<p>终于到了这一步. 建议首先在 Master 上机器修改好 Hadoop 的配置.然后压缩该文件夹,复制到其他 Slave 节点上的同一目录.</p>
<h4 id="unpack-and-move-hadoop-folder">Unpack and move hadoop folder</h4>
<p>假设下载好的 hadoop-2.7.2.tar.gz 在 当前用户的<code>Downloads</code>文件夹中. 解压完毕之后,将其移动到<code>/usr/local</code>下,并更名为<code>hadoop</code></p>
<pre><code>$ mv hadoop-2.7.2 /usr/local/hadoop
</code></pre>
<h4 id="update-environment-file">Update Environment File</h4>
<p>在配置 Hadoop 的过程中,下列配置文件将会被修改.</p>
<blockquote>
<p>~/.bashrc /usr/local/hadoop/etc/hadoop/slaves /usr/local/hadoop/etc/hadoop/hadoop-env.sh /usr/local/hadoop/etc/hadoop/core-site.xml /usr/local/hadoop/etc/hadoop/yarn-site.xml /usr/local/hadoop/etc/hadoop/mapred-site.xml /usr/local/hadoop/etc/hadoop/hdfs-site.xml</p>
</blockquote>
<h5 id="~bashrc">~/.bashrc</h5>
<p>还记得之前提过的 JDK 路径吗,将其配置成<code>JAVA_HOME</code> 修改当前用户的 bash 配置文件,将其加到.bashrc 的底部</p>
<pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~
$ vi .bashrc
</code></pre>
<pre><code class="hljs sh"><span class="hljs-comment">#Hadoop variables</span>
<span class="hljs-built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/
<span class="hljs-built_in">export</span> HADOOP_INSTALL=/usr/<span class="hljs-built_in">local</span>/hadoop
<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_INSTALL</span>/bin
<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_INSTALL</span>/sbin
<span class="hljs-built_in">export</span> HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_INSTALL</span>
<span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=<span class="hljs-variable">$HADOOP_INSTALL</span>
<span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=<span class="hljs-variable">$HADOOP_INSTALL</span>
<span class="hljs-built_in">export</span> YARN_HOME=<span class="hljs-variable">$HADOOP_INSTALL</span>
</code></pre>
<h5 id="usrlocalhadoopetchadoophadoop-envsh">/usr/local/hadoop/etc/hadoop/hadoop-env.sh</h5>
<p>还是跟上面一样,需要将 JDK 的路径设置成<code>JAVA_HOME</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/
</code></pre>
<h5 id="usrlocalhadoopetchadoopcore-sitexml">/usr/local/hadoop/etc/hadoop/core-site.xml</h5>
<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间添加一个 fs.default.name,其值为 master 机器的 9000 端口. 譬如我的 master 机器是<code>elementary-os</code>,则 value 是<code>hdfs://elementary-os:9000</code> P.S.接下来的变量<code>{master-hostname}</code>请自行替换成自己的 master 的机器名.</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.default.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://{master-hostname}:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop_store/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
</code></pre>
<h4 id="usrlocalhadoopetchadoopyarn-sitexml">/usr/local/hadoop/etc/hadoop/yarn-site.xml</h4>
<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间添加:</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>{master-hostname}<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>

</code></pre>
<h5 id="usrlocalhadoopetchadoopmapred-sitexml">/usr/local/hadoop/etc/hadoop/mapred-site.xml</h5>
<p><code>mapred-site.xml</code>默认是不存在的. 但是有一份模板文件<code>mapred-site.xml.template</code>,我们将其复制并重命名成<code>mapred-site.xml</code></p>
<pre><code class="hljs bash">$ cp /usr/<span class="hljs-built_in">local</span>/hadoop/etc/hadoop/mapred-site.xml.template /usr/<span class="hljs-built_in">local</span>/hadoop/etc/hadoop/mapred-site.xml
</code></pre>
<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间添加:</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuartion</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapred.job.tracker<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>{master-hostname}:9001<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>{master-hostname}:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>{master-hostname}:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuartion</span>&gt;</span>
</code></pre>
<h5 id="usrlocalhadoopetchadoophdfs-sitexml">/usr/local/hadoop/etc/hadoop/hdfs-site.xml</h5>
<p>在修改<code>hdfs-site.xml</code>这个配置文件之前,我们需要知道更多的一件事. hdfs 的块状文件,储存在一个指定的目录中. 按照官方文档的推荐,和网上一些文件夹的路径的约定,我们将这个 hdfs 的文件储存目录叫做<code>hadoop_store</code>.绝对路径为<code>/usr/local/hadoop_store</code></p>
<p>于是 hadoop 的相关文件夹就变成了两个:</p>
<blockquote>
<p>/usr/local/hadoop /usr/local/hadoop_store</p>
</blockquote>
<p>由于读写权限问题,我们需要将<code>hadoop_store</code>的权限改成任意可读可写</p>
<pre><code class="hljs bash">$ sudo mkdir -p /usr/<span class="hljs-built_in">local</span>/hadoop_store
$ sudo chmod -R 777 /usr/<span class="hljs-built_in">local</span>/hadoop_store
</code></pre>
<p>然后再在配置文件里面加入</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuartion</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>{master-hostname}:50090<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop_store/hdfs/namenode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop_store/hdfs/datanode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuartion</span>&gt;</span>
</code></pre>
<h5 id="slaves">slaves</h5>
<p><code>slaves</code>文件里面存储的是作为 slave 的节点的机器名. 以行为单位,一行一个. 默认只有一行 localhost. 从一般的集群角度来说,Master 不应该担当 Worker 的角色(老湿布置作业给小学僧,自己是不会一起做作业的) 所以 slaves 文件一般只写 slave 节点的名字,即 slave 节点作为 datanode,master 节点仅仅作为 namenode.</p>
<p>但是由于我是一名好老湿,所以在本机配置中 master 也充当了 worker 的角色,所以本机是这样改的:</p>
<pre><code>elementary-os
hd-worker-a
hd-worker-b
</code></pre>
<p>致此,所有的配置文件已经修改完毕. 可以将 master 上的 hadoop 文件夹压缩并且分发到各个 slave 节点上.</p>
<h4 id="last-configure-format-namenode">Last Configure : Format Namenode</h4>
<p>最后一步配置,初始格式化 hdfs</p>
<pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoop/
$ hdfs namenode -format
</code></pre>
<h3 id="start-all-hadoop-deamons">Start all Hadoop deamons</h3>
<p>启动 Hadoop 服务.</p>
<pre><code class="hljs bash">$ su hduser
$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoop/
$ sbin/start-dfs.sh
$ sbin/start-yarn.sh
</code></pre>
<p>如果启动成功,在 master 节点上通过 jps 命令查看,应该包含如下 hadoop 进程</p>
<pre><code>hduser@elementary-os:~$ jps
51288 Jps
22914 ResourceManager
22361 NameNode
23229 NodeManager
22719 SecondaryNameNode
</code></pre>
<p>在 slave 节点上通过 jps 命令查看,应该包含如下 hadoop 进程</p>
<pre><code>hduser@hd-worker-a:~$ jps
6284 NodeManager
6150 DateNode
6409 Jps
</code></pre>
<p>或者可以通过浏览器访问<a href="https://master:8088">https://master:8088</a> 或者<a href="https://master:50070">https://master:50070</a> 查看 Hadoop 服务状态.</p>
<p><img src="https://img.aquariuslt.com/2016/04/nodes-of-the-cluster.png" alt="Nodes of the cluster"> <img src="https://img.alicdn.com/tfscom/TB16f8YMpXXXXbJXVXXXXXXXXXX.png" alt="Namenode information"></p>
<p>P.S.关于<code>jps</code>命令. jps 位于 jdk 的 bin 目录下,其作用是显示当前系统的 java 进程情况,及其 id 号. jps 相当于 linux 进程工具 ps,但是不支持管道命令 grep jps 并不使用应用程序名来查找 JVM 实例.</p>
<h2 id="trouble-shooting">Trouble Shooting</h2>
<p>防跌坑指南. 记录了在 Hadoop 环境搭建过程中所遇到的坑</p>
<h3 id="number-of-live-datanode0">Number of Live DataNode:0</h3>
<p>通过<code>start-dfs.sh</code>启动了 hadoop 多个节点的 datanode, 且通过<code>jps</code>命令能够看到正常的 datanode 和 resourcemanager 进程, 为什么 live datanode 数目为 0,或者只有 master 的那个 datanode?</p>
<p>可通过以下方法排除:</p>
<ol>
<li>关闭所有节点的防火墙(ubuntu): 先查看防火墙状态</li>
</ol>
<pre><code class="hljs bash">$ sudo ufw status
</code></pre>
<p>如果不是 disabled,则禁用</p>
<pre><code class="hljs bash">$ sudo ufw <span class="hljs-built_in">disable</span>
</code></pre>
<ol start="2">
<li>在 hadoop 服务运行的时候,关闭 namenode 的安全模式</li>
</ol>
<pre><code class="hljs bash">$ hadoop dfsadmin -safemode leave
</code></pre>
<ol start="3">
<li>在关闭 hadoop 服务的情况下,删除所有的日志文件,存储文件并重新 format 确保<code>hadoop_store</code>文件夹下的所有文件夹权限都是 777</li>
</ol>
<pre><code>$sudo rm -r /usr/local/hadoop/logs
$sudo rm -r /usr/local/hadoop_store/tmp
$sudo rm -r /usr/local/hadoop_store/hdfs
$sidp hdfs namenode -format
</code></pre>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/278/800/300"/>
        </item>
        <item>
            <title><![CDATA[Site 项目结构介绍]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/03/06/site-code-structure</link>
            <guid>https://blog.aquariuslt.com/posts/2016/03/06/site-code-structure</guid>
            <pubDate>Sun, 06 Mar 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.项目本身的结构是从[JShelf](https://github.com/Da]]></description>
            <content:encoded><![CDATA[<h1 id="site-项目结构介绍">Site 项目结构介绍</h1>
<h2 id="background">Background</h2>
<p>应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.</p>
<p>项目本身的结构是从<a href="https://github.com/Dantemo/JShelf">JShelf</a>开始. 是由于公司内部组织了一次 MEAN 的一些入门分享. 分成了几个小组,我们小组根据对 MEAN 的认识魔改了这样一个基本的项目基础结构. 在其原本的结构上.做了做了一些蛋疼的修改大概是根据<code>npm install</code>的提示,更换 lib 的名字或者升级 lib 的版本到最新版. 然后删除了一些没必要的模块.</p>
<p>目前已经在我的 VPS 上运行,<a href="https://aquariuslt.com">主站</a>是目前的效果.</p>
<h2 id="agenda">Agenda</h2>
<p>整个项目的结构从以下几个部分开始介绍,但是在过程中会交错穿插一点互相引用的地方.</p>
<ul>
<li>运作思路</li>
<li>代码结构</li>
<li>构建过程</li>
<li>运行准备</li>
</ul>
<h2 id="thought">Thought</h2>
<p>从 Coding 的角度出发,<code>Node.js</code>作为服务器端语言的优势之一就是不需要编译,直接重启 node 进程即可. 而前端代码呢,在开发的时候,我们希望能够达到所见即所得的方式,即 html+样式的修改能够直接呈现在页面上. 在生产环境的时候,为了加快访问速度,对前端代码进行必要的打包,压缩,混淆等操作.</p>
<p>作为单页应用的一部分,希望能够进行自动引入所需的 js 文件,不需要手动维护首页 html 里面的</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"after-respondent.md"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>按照这个想法,理想中的前端开发顺序希望是这样:</p>
<ul>
<li>
<p>开发环境</p>
<blockquote>
<ol>
<li>以符合<code>RequireJS规范</code>编写前端代码</li>
<li>前端的 html,css,js 代码一旦有改动,且通过了 IDE 的 jshint 与 html 格式化检查,立刻热替换到所展示的页面中</li>
</ol>
</blockquote>
</li>
<li>
<p>生产环境</p>
<blockquote>
<ol>
<li>将写好的前端代码打包</li>
<li>服务器将前端的首页,以及打包后的 js,css 文件,释放出一个可访问的 url 作为前端资源文件的全部</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="code-structure">Code Structure</h2>
<h3 id="folder-treeview">Folder TreeView</h3>
<p>首先我们来看一下项目的目录结构:</p>
<blockquote>
<p>这是一个遍历到子文件夹 5 层的项目结构目录. 已经去除 <code>node_modules</code>文件夹和 IDE 的文件夹</p>
</blockquote>
<pre><code>├── dist
│   ├── build
│   │   ├── bundle.css
│   │   ├── bundle.js
│   │   ├── fonts
│   │   │   ├── glyphicons-halflings-regular.eot
│   │   │   ├── glyphicons-halflings-regular.svg
│   │   │   ├── glyphicons-halflings-regular.ttf
│   │   │   ├── glyphicons-halflings-regular.woff
│   │   │   └── glyphicons-halflings-regular.woff2
│   │   └── index.html
│   └── tmp
│       └── templates.js
├── gulp
│   ├── client
│   │   ├── assets.js
│   │   ├── browserify.js
│   │   ├── clean.js
│   │   ├── default.js
│   │   ├── fonts.js
│   │   ├── images.js
│   │   ├── core.store.js
│   │   ├── minify.js
│   │   ├── serve.js
│   │   ├── styles.js
│   │   ├── templates.js
│   │   ├── watch.js
│   │   ├── watchify.js
│   │   ├── webpack-watch.js
│   │   └── webpack.js
│   ├── config.js
│   ├── core.store.js
│   └── server
│       ├── core.store.js
│       └── server.js
├── gulpfile.js
├── node_modules
├── package.json
├── readme.md
├── server.js
├── src
│   ├── client
│   │   ├── home
│   │   │   ├── controllers
│   │   │   │   ├── activities.controller.js
│   │   │   │   ├── header.controller.js
│   │   │   │   ├── home.controller.js
│   │   │   │   └── picture.slide.controller.js
│   │   │   ├── filters
│   │   │   │   ├── activity.array.filter.js
│   │   │   │   └── activity.publish.filter.js
│   │   │   ├── core.store.js
│   │   │   ├── routes
│   │   │   │   └── home.routes.js
│   │   │   ├── styles
│   │   │   │   ├── about.css
│   │   │   │   ├── angular-ui-bootstrap.css
│   │   │   │   ├── bootstrap-theme.css
│   │   │   │   ├── bootstrap.css
│   │   │   │   ├── common.css
│   │   │   │   └── home.css
│   │   │   └── views
│   │   │       ├── home.about.html
│   │   │       ├── home.footer.html
│   │   │       ├── home.header.html
│   │   │       └── home.index.html
│   │   ├── index.html
│   │   └── core.store.js
│   └── server
│       └── home
│           ├── config
│           │   └── activities.config.js
│           ├── controllers
│           │   └── activities.controller.js
│           └── routes
│               └── home.routes.js
└── tree.txt

2381 directories, 10428 files

</code></pre>
<h3 id="review-with-java-web-project">Review with Java-Web Project</h3>
<p>回想一下使用 maven 进行依赖管理的简单 Java Web 项目. 大致是以下一种目录:</p>
<pre><code>├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com
│   │   │       └── aquariuslt
│   │   └── webapp
│   │       ├── WEB-INF
│   │       │   ├── mvc-dispatcher-servlet.xml
│   │       │   └── web.xml
│   │       ├── booking-create.html
│   │       └── js
│   │           ├── booking
│   │           └── extjs
│   └── test
│       └── java
│           └── com
│               ├── aquariuslt
│               └── springapp
└── target
    ├── ITA-BookingUI
    │   ├── META-INF
    │   │   └── MANIFEST.MF
    │   ├── WEB-INF
    │   │   ├── classes
    │   │   │   └── com
    │   │   ├── lib
    │   │   │   ├── aopalliance-1.0.jar
    │   │   │   ├── commons-logging-1.2.jar
    │   │   │   ├── freemarker-2.3.23.jar
    │   │   │   ├── jackson-core-asl-1.9.13.jar
    │   │   │   ├── jackson-mapper-asl-1.9.13.jar
    │   │   │   ├── servlet-api-2.5.jar
    │   │   │   ├── spring-aop-4.2.0.RELEASE.jar
    │   │   │   ├── spring-beans-4.2.0.RELEASE.jar
    │   │   │   ├── spring-context-4.2.0.RELEASE.jar
    │   │   │   ├── spring-context-support-4.2.0.RELEASE.jar
    │   │   │   ├── spring-core-4.2.0.RELEASE.jar
    │   │   │   ├── spring-expression-4.2.0.RELEASE.jar
    │   │   │   ├── spring-web-4.2.0.RELEASE.jar
    │   │   │   ├── spring-webmvc-4.2.0.RELEASE.jar
    │   │   │   └── tomcat-servlet-api-7.0.63.jar
    │   │   ├── mvc-dispatcher-servlet.xml
    │   │   └── web.xml
    │   ├── booking-create.html
    │   └── js
    │       ├── booking
    │       │   ├── BookingCreateApp.js
    │       │   ├── controller
    │       │   └── view
    │       └── extjs
    │           ├── ext-all-debug.js
    │           ├── ext-theme-neptune
    │           └── resources
    ├── ITA-BookingUI.war
    ├── classes
    │   └── com
    │       └── aquariuslt
    │           └── ita
    ├── generated-sources
    │   └── annotations
    ├── generated-test-sources
    │   └── test-annotations
    └── test-classes
        └── com
            └── aquariuslt
                └── ita

41 directories, 28 files
</code></pre>
<blockquote>
<p><code>src</code>文件夹作为源代码目录 <code>src-&gt;main-&gt;java</code>下的代码作为后台的代码 <code>src-&gt;main-&gt;webapp</code>作为运行时 web 应用容器的配置,包含了前端的资源文件 <code>pom.xml</code>作为项目的依赖管理,命名选项配置文件 <code>target</code>文件夹则是通过 maven 构建命令编译构建出来的 输出目录</p>
</blockquote>
<h3 id="files-folders">Files &amp; Folders</h3>
<h4 id="packagejson">package.json</h4>
<p>功能等同<code>pom.xml</code></p>
<h4 id="src">src</h4>
<p>源代码文件夹. 其中往下分可以分成前端模块和后端模块两个大部分为了方便分类,将它分成了<code>client</code>,<code>server</code> 源代码的子层级命名方式为<code>module</code>-<code>mvc feature</code>-<code>submodule</code></p>
<h4 id="gulp">gulp</h4>
<p>存放<code>GulpTask</code>的文件夹. 子文件夹又分成<code>client</code>和<code>server</code>的 tasks. 至于使用 Gulp 来进行什么样的构建,在下一部分会说明</p>
<h4 id="dist">dist</h4>
<p>构建出来的前端输出文件夹.类似于 JavaWeb 里面的 target. 但是仅限前端. 这里存放的是经过打包后的前端资源. 在整个应用启动的时候,将会扫描该文件夹,将其全部作为静态资源暴露出 url.</p>
<h2 id="gulptask">GulpTask</h2>
<h3 id="gulp-2">Gulp</h3>
<h4 id="what-is-gulp">What is Gulp</h4>
<p><a href="https://gulpjs.com/">Gulp 官方网站</a> Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。</p>
<h4 id="how-to-use">How to Use</h4>
<p>我使用 gulp 来干什么呢? 单从前端运行的过程来说.我使用 Gulp 的 Task 进行下面一个流程. <img src="https://img.alicdn.com/tfscom/TB1DX9QLVXXXXXNaXXXXXXXXXXX.png" alt=""></p>
<h3 id="build-flow">Build Flow</h3>
<p>为了达到最终的目的:单页应用输出最终的一个页面.</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">ng-app</span>=<span class="hljs-string">"home"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Aquariuslt Home<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"bundle.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>
      <span class="hljs-attr">ng-include</span>=<span class="hljs-string">"'home/views/home.header.html'"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-default navbar-fixed-top navbar-inner"</span>
    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"page-header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ui-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"bundle.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">ng-include</span>=<span class="hljs-string">"'home/views/home.footer.html'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>我们需要怎么构建出这样一个页面呢? 按照我的 gulp tasks 代码上是这样:</p>
<pre><code class="hljs js"><span class="hljs-comment">//按照以下顺序运行task</span>
<span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'release'</span>) {
  runSequence(
    <span class="hljs-string">'clean'</span>,
    [<span class="hljs-string">'index'</span>, <span class="hljs-string">'styles'</span>, <span class="hljs-string">'images'</span>, <span class="hljs-string">'fonts'</span>, <span class="hljs-string">'assets'</span>, <span class="hljs-string">'templates'</span>],
    <span class="hljs-comment">//'browserify',</span>
    <span class="hljs-string">'webpack'</span>,
    <span class="hljs-string">'minify'</span>,
    <span class="hljs-string">'server'</span>
  );
}
</code></pre>
<p>前面第一个 clean 只是清除 dist 文件夹的任务而已而已.</p>
<p>一开始,<code>index.html</code>只是这样:</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">ng-app</span>=<span class="hljs-string">"home"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Aquariuslt Home<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-comment">&lt;!--styles--&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>
      <span class="hljs-attr">ng-include</span>=<span class="hljs-string">"'home/views/home.header.html'"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-default navbar-fixed-top navbar-inner"</span>
    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"page-header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ui-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!--scripts--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">ng-include</span>=<span class="hljs-string">"'home/views/home.footer.html'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 id="index">index</h4>
<p><code>index</code>这个 task,主要功能是读取构建的一个配置文件<code>config.js</code>获取<code>index.html</code>的路径. 紧接着比较傻逼的将 html 中的</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-comment">&lt;!--styles--&gt;</span>
</span></code></pre>
<p>替换成</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"bundle.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>
</span></code></pre>
<p>将</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-comment">&lt;!--scripts--&gt;</span>
</span></code></pre>
<p>替换成</p>
<pre><code class="hljs htmlbars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"bundle.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</span></code></pre>
<p>虽然 css,js 还没有经过打包.但是先替换,存放在 dist 文件夹下.</p>
<h4 id="styles">styles</h4>
<p>在配置文件<code>config.js</code>里面,需要维护一个 css 文件夹的正则路径.匹配到多个路径下的 css 位置供扫描. css 文件的路径大概是这样子的:</p>
<pre><code>styles: [config.folder.src + '/client/**/styles/*.css'],
</code></pre>
<p>即 src 文件夹下,匹配到 client 下的隔层文件夹里的所有叫<code>styles</code>的子文件夹下的所有 css 文件 <code>styles</code>主要是将扫描出来的所有 css 文件打包在一起,融合成 刚刚替换成的<code>bundle.min.js</code></p>
<h3 id="imagesfontsassets">images,fonts,assets</h3>
<p>这三个 tasks 功能类似.即也是读取配置文件所维护的一个匹配所有静态资源文件将其放到 dist 下对应的文件夹内.</p>
<h3 id="templates">templates</h3>
<p>在配置文件<code>config.js</code>,控制将一个负责控制所有视图(views)的路径</p>
<pre><code>templates: config.folder.src + '/client/**/*.html',
</code></pre>
<p><code>templates</code>这个 tasks 主要是扫描所有<code>.html</code>的视图文件,用于生成一些 <code>ngTempalte</code>供 angular 调用 html 模板其实最后这些生成的模板将会合并进 js 中. 大概会变成下面这样:</p>
<pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = angular.module(<span class="hljs-string">'templates'</span>, []).run([
  <span class="hljs-string">'$templateCache'</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$templateCache</span>) </span>{
    $templateCache.put(
      <span class="hljs-string">'index.html'</span>,
      <span class="hljs-string">'&lt;!DOCTYPE html&gt;\n&lt;html ng-app="home"&gt;\n  &lt;head&gt;\n    &lt;meta charset="utf-8"&gt;\n    ...'</span>
    );
    $templateCache.put(
      <span class="hljs-string">'home/views/home.about.html'</span>,
      <span class="hljs-string">'&lt;div role="main" class="container"&gt;\n  &lt;div class="row"&gt;\n    &lt;...'</span>
    );
    $templateCache.put(
      <span class="hljs-string">'home/views/home.footer.html'</span>,
      <span class="hljs-string">'&lt;div class="container"&gt;\n  &lt;div class="center-block"&gt;\n    &lt;h5&gt;B...'</span>
    );
    $templateCache.put(
      <span class="hljs-string">'home/views/home.header.html'</span>,
      <span class="hljs-string">'&lt;div class="container" ng-controller="headerController"&gt;\n  &lt;div...'</span>
    );
    $templateCache.put(
      <span class="hljs-string">'home/views/home.index.html'</span>,
      <span class="hljs-string">'&lt;div class="container"&gt;\n  &lt;div class="jumbotron"&gt;\n    &lt;div clas...'</span>
    );
  }
]);
</code></pre>
<h3 id="webpackbrowserify">webpack/browserify</h3>
<p>这两个是现在主流的 js 打包工具.配合自身的一些插件.主要做到能够将以<code>requirejs</code>方式编的方式的代码. 为了方便开发和调试, <code>webpack</code>和<code>browserify</code>都有一个热打包插件:过程都是监听所有 js 源代码的路径.当文件更新的时候,自动在打包一次.部署到运行的服务器上.</p>
<h3 id="minify">minify</h3>
<p>这个以前叫做 uglify,就是压缩 js 代码,变量名混淆.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/38/800/300"/>
        </item>
        <item>
            <title><![CDATA[Node.js oracledb "ORA-21561 - OID generation failed" 解决方案]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/01/12/nodejs-oracledb-ora-21561-solution</link>
            <guid>https://blog.aquariuslt.com/posts/2016/01/12/nodejs-oracledb-ora-21561-solution</guid>
            <pubDate>Tue, 12 Jan 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[千辛万苦在虚拟机的`CentOS 6`下编译好`oracledb`,运行时报错 "ORA-21561 - OID generation failed"原因是虚拟机下的`CentOS`连接到 oracl]]></description>
            <content:encoded><![CDATA[<h1 id="nodejs-oracledb-ora-21561-oid-generation-failed-解决方案">Node.js oracledb &quot;ORA-21561 - OID generation failed&quot; 解决方案</h1>
<h2 id="background">Background</h2>
<p>千辛万苦在虚拟机的<code>CentOS 6</code>下编译好<code>oracledb</code>,运行时报错 &quot;ORA-21561 - OID generation failed&quot;</p>
<h2 id="solution">Solution</h2>
<p>原因是虚拟机下的<code>CentOS</code>连接到 oracle 服务器的时候,本地没有有效的连接名称(机器名)</p>
<p>需要在<code>hosts</code>列表中添加本地的机器名. 假设我 local 机器名为<code>centos-vm</code></p>
<pre><code class="hljs sh">sudo gedit /etc/hosts   (vi也行)
</code></pre>
<p>查找<code>127.0.0.1</code> 在对应的 hostname 后面添加<code>centos-vm</code>,即本机器名</p>
<p><img src="https://img.aquariuslt.com/posts/2016/01/update-centos-hosts.png" alt="修改CentOS hosts文件"></p>
<p>重启即可.</p>
<p><a href="https://chaos667.tumblr.com/post/20006357466/ora-21561-and-oracle-instant-client-112">Origin Post</a></p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/501/800/300"/>
        </item>
        <item>
            <title><![CDATA[RHEL(CentOS)6环境下安装node-oracledb]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/01/11/nodejs-oracledb-install-on-rhel-6</link>
            <guid>https://blog.aquariuslt.com/posts/2016/01/11/nodejs-oracledb-install-on-rhel-6</guid>
            <pubDate>Mon, 11 Jan 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[最近准备升级一下 PROD 服务器上的`node-oracledb`版本. 但是遇到一个很奇怪的现象,就是我本地无法构建出服务器上可用的`oracledb`. (因为部署方式是打包部署而不是从`git]]></description>
            <content:encoded><![CDATA[<h1 id="rhelcentos6-环境下安装-node-oracledb">RHEL(CentOS)6 环境下安装 node-oracledb</h1>
<h2 id="background">Background</h2>
<p>最近准备升级一下 PROD 服务器上的<code>node-oracledb</code>版本. 但是遇到一个很奇怪的现象,就是我本地无法构建出服务器上可用的<code>oracledb</code>. (因为部署方式是打包部署而不是从<code>git</code>拉代码部署)</p>
<p>一开始以为是<code>C++运行库</code>的原因. 因为又仔细读了一遍<code>node-oracledb</code>的官方安装文档,发现<code>oracledb</code>在编译的时候,只支持支持<code>C++11</code>的编译器.</p>
<p>立马查看本地环境的<code>gcc</code>版本与运行库版本<code>glibc</code></p>
<pre><code>gcc -v
ldd --version
</code></pre>
<p>发现本地<code>CentOS 6.6</code>版本自带的<code>gcc</code>版本是 4.4,<code>glibc</code>版本是 2.12 但是支持编译和运行 C++11 新特性的<code>gcc</code>版本是 4.7+,<code>glibc</code>版本是 2.14+ 这.版本都不一样怎么玩.</p>
<h2 id="rootcause">RootCause</h2>
<p>马上比较了一下 本地构建<code>oracledb</code>与服务器的各种版本发现相关的版本信息如下:</p>
<blockquote>
<p>服务器 OS:RedHat Enterprise Linux 6.6 gcc Version:4.4 (Red Hat) glibc Version:2.12 node Version:v0.10.38 npm Version:1.4.28(npm 版本应该不会影响构建,预防万一还是提及一下) node-gyp Version:不明.因为没权限调用该命令. oracle instantclient Version:11.2</p>
</blockquote>
<blockquote>
<p>本地环境 OS:CentOS 6.7 x64 gcc Version:4.4 (Red Hat) glibc Version:2.12 node Version:v4.2.4 npm Version:2.14.8 node-gyp Version:3.2.1 oracle instantclient Version:11.2</p>
</blockquote>
<h2 id="solution">Solution</h2>
<p>思前想后,想想也不知道<code>node.js</code>本身版本到底会对<code>oracledb</code>的构建有什么影响. 毕竟<code>oracledb</code>官方对构建时的<code>C++11</code>编译支持的要求先入为主了</p>
<p>最后还是决定先切换一下<code>node.js</code>版本,结果问题顺利解决</p>
<pre><code class="hljs sh"><span class="hljs-variable">$npm</span> install n
<span class="hljs-variable">$n</span> v0.10.38
<span class="hljs-variable">$npm</span> install oracledb
</code></pre>
<p>构建成功.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/306/800/300"/>
        </item>
        <item>
            <title><![CDATA[Year in Review 2015]]></title>
            <link>https://blog.aquariuslt.com/posts/2016/01/01/review-2015</link>
            <guid>https://blog.aquariuslt.com/posts/2016/01/01/review-2015</guid>
            <pubDate>Fri, 01 Jan 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[2016 新年伊始,回顾 2015 年时间线.我是在苹果推出`Retina`屏幕之后才开始关注`Macbook`系列的. 源于在大学中对字体的纠结.从`Windows`令人诟病的字体渲染方案,到使用`]]></description>
            <content:encoded><![CDATA[<h1 id="year-in-review-2015">Year in Review 2015</h1>
<blockquote>
<p>2016 新年伊始,回顾 2015 年时间线.</p>
</blockquote>
<h2 id="入手第一台-macbook">入手第一台 Macbook</h2>
<p>我是在苹果推出<code>Retina</code>屏幕之后才开始关注<code>Macbook</code>系列的. 源于在大学中对字体的纠结.从<code>Windows</code>令人诟病的字体渲染方案,到使用<code>mactype</code>魔改本机的字体配置, 到最后还是觉得屏幕中展示的效果不够美观.几乎失去了打开 IDE 的想法. 再衍生到与<code>Linux</code>的羁绊,几乎把所有发行吧<code>Linux</code>都装了个遍,原生 UI 都丑哭了,虽然自由度大,环境好可是比<code>Windows</code>还丑. 那就更不能玩了..</p>
<p>最后还是在大四,省吃俭用终于入手了第一台<code>Retina Macbook Pro 13'inch 2015</code>. 再也没有借口不去写代码了..</p>
<p>入手 RMBP 之后的那段时间,好像正是 AFK 的那段时间. 真的就没主动打开过 WOW 了.</p>
<p>正是由于有动力打开 IDE,在下班的时候把陆续毕业设计做完,顺利完成真.毕业设计. <img src="https://img.alicdn.com/tfscom/TB1ahn5LXXXXXa5XpXXXXXXXXXX.jpg" alt="开箱"> <img src="https://img.alicdn.com/tfscom/TB1DQz_LXXXXXcQXXXXXXXXXXXX.jpg" alt="RMBP"></p>
<blockquote>
<p>从此每天都背着电脑上班. 就算没机会拿出来,也感觉是编程灵感的来源. 讲真,我的编程能力有了质的飞跃</p>
</blockquote>
<h2 id="毕业">毕业</h2>
<blockquote>
<p>1999-2015. 不算上幼稚园和学前班 16 年的学校生涯终于结束了. (其实好想不劳而获能读研究生,哈哈) 想到自己失去了学生的身份,伤感. 但是我想,在技术的层面上,更加能够专注的从实际应用中学习了. 毕竟不会再被学校中一些无聊,过时的课程影响正常的学习计划.</p>
</blockquote>
<h3 id="毕业设计">毕业设计</h3>
<p>毕业设计题目是<code>基于XMPP协议的多平台消息推送的研究与实现</code>,这个选题其实有点坎坷. 我毕业论文的导师,我一直敬仰他,因为他是确实能够将实际技术运用起来,并且确实能够在遇到困难时很快提供有效的关键字,帮助学生解决问题.</p>
<p>所以在预选毕业论文的时候,我立马就联系了他,想选他当导师. 然而一个老师只有十几个名额,跟老师做过项目的童鞋已经内定了名额,实际上只剩下两个名额于是十来名同学最后约战办公室,都希望能争夺这两个名额.</p>
<p>聚集一堂的时候,老师也厅看得起我.立马就填了我的名字. 岂料祸从口出&quot;蟹蟹老师,那我先回去上班了啊&quot;,&quot;你在实习啊,那不行,没时间把项目搞完,这个毕业论文很紧的&quot;.</p>
<p>囧.这样我又失去了机会. 后来还是老师联系到我,说如果我可以自己提一个选题, 他也许能够在选题的基础上给我提一些意见,把握好大致方向. 最后我提了我的想法,结果就被改成了现在的这个题目.</p>
<p>紧接着联系到了整个本科四年用到的知识连贯起来才能写完用到了软狗的<code>WindowsPhone</code>,<code>JavaWeb</code>,<code>Android</code>.还有一些开源协议上的应用. 特别是在 Linux 下的部署</p>
<p>最后论文修改了八次去重了一次,终于把论文修改好了. 我的毕业设计虽然名字高大上,内容平庸.但是从头到尾纯手打,倒过来也是自己写的.</p>
<p>加上学校比较弱鸡,大部分的毕业论文都比较辣鸡,就评了个优秀.</p>
<h3 id="毕业照">毕业照</h3>
<p>那么快就到了 6 月 27.传说中拍毕业照的日子.</p>
<p>还是初中的死党过来帮我拍照. <img src="https://img.alicdn.com/tfscom/TB1zIzOLXXXXXcoXVXXXXXXXXXX.jpg" alt="大合照"> <img src="https://img.alicdn.com/tfscom/TB1mjPMLXXXXXcVXVXXXXXXXXXX.jpg" alt="...不敢放了"></p>
<h3 id="找房子">找房子</h3>
<p>公司附近其实是有便宜的城中村的,但是没物管也没保安,财产得不到保证. 于是就找了中大那边的教师公寓,复式,够大,恰好家具也很不 low. <img src="https://img.alicdn.com/tfscom/TB1J827LXXXXXaTXpXXXXXXXXXX.png" alt=""> <img src="https://img.alicdn.com/tfscom/TB1OMYHLXXXXXaUaXXXXXXXXXXX.jpg" alt=""> <img src="https://img.alicdn.com/tfscom/TB1Glb2LXXXXXXgXFXXXXXXXXXX.jpg" alt=""> <img src="https://img.alicdn.com/tfscom/TB1d_YSLXXXXXaeXVXXXXXXXXXX.jpg" alt=""> <img src="https://img.alicdn.com/tfscom/TB11NzJLXXXXXcLXVXXXXXXXXXX.jpg" alt=""></p>
<p>环境什么都好,就是上网慢还不给拉光纤. 一台 99 块的路由器要供 10+台终端上网,还只有 8M 的总带宽,自然不稳定.</p>
<h3 id="ita">ITA</h3>
<p>毕业之后耍了几天. 进入公司之后,是一段时间的入职培训. 他们把这个阶段叫做 ITA(IT Academy)</p>
<p>正是这段日子,趁机把<code>Clean Code</code>,<code>Head First-Desgin Pattern</code>看完,把实习的时候不明不白的地方,逐条击破. 顺便阅读了下 Spring 的一些源码.</p>
<p>不得不说<code>Clean Code</code>真的是一本看起来很爽的书. 看的过程中得到了与作者的很多共鸣,也给了科学的代码命名,结构编排方式.一发解决困扰依旧多年的变量,方法命名习惯. 再结合补完设计模式一书之后,以前很多程序结构上的问题也释然了. 能够独当一面 Hold 住项目的程度也大大提升了</p>
<p>然后在 ITA 也遇到了很多新的小伙伴.来自武大,吉珠,北理珠和中国政法大学的研究生转行的大大. <img src="https://img.alicdn.com/tfscom/TB1yzvKLXXXXXXQaXXXXXXXXXXX.jpg" alt="ITA Team3 小分队"></p>
<h2 id="入手-idea-license">入手 IDEA License</h2>
<p>自从使用了 Idea 之后,再也没法打开 Eclipse 了. 可是想起在实习的时候,遇到了问题,需要请教大大来帮忙 DEBUG,大大不会用 Eclipse,那我就只好再用 Eclipse 打开一次项目,太麻烦了.</p>
<h3 id="研究-idea">研究 IDEA</h3>
<p>为了造福身边热爱 Coding 的小伙伴,为了不再打开 Eclipse.我决定深入研究 Idea 各种配置与使用方式,同时提升自己的技术水平,不被那种等级的问题所困扰. 于是在官网爬了官方文档个月有余,全方位了解了 Idea 各种使用方式.</p>
<h3 id="推广-idea">推广 IDEA</h3>
<p>算上毕业之前接触的<code>Android Studio</code>部分,大概有一年半多的 Idea 使用经验,已经能够成为公司内部的 Idea 普法大使. 在我的安利下,目测已经有 16 位同事使用 Idea(包含了 4 位后来又反水回归 Eclipse 的)做 Java/MEAN 开发.</p>
<p>毕业之前用的是注册机生成的 Idea 序列号. 毕业之后,适逢 Idea 15 版本更新,并且自己也已经有正式收入了. 决定正式购买 Idea License.</p>
<p>为了加大推广 Idea 的力度,故申请了个微信公众号,定期推送 Idea 相关文章. <img src="https://img.alicdn.com/tfscom/TB1R9DOLXXXXXX5XVXXXXXXXXXX.jpg" alt="IDE Skill微信公众号:codingskills"></p>
<h2 id="新的圈子">新的圈子</h2>
<h3 id="新同事">新同事</h3>
<p>正式进入到工作岗位之后(卧槽这语气怎么感觉这么官腔,好像我不是一个 Programmer 一样),结识到了同部门的新同事和领导. 可能大都是年轻人,所以平时交流起来氛围都比较轻松领导貌似也厅看得起我,有几个 Item 都是关于现有项目的性能优化而不是 CRUD, 最近接手 HK 的 MEAN 相关项目也挺有挑战的,感觉恰好是以前学到的知识底蕴都有的发挥了.能够学以致用,再边做边学,全面提升技术栈强度.</p>
<h2 id="展望">展望</h2>
<p>在 2015 年逐渐清晰了人生的方向, 更明确了自己的价值观, 能力也有了客观的提升, 同时也摆脱了很多羁绊.</p>
<p>虽然失去了一些重要的东西, 新的一年, 变得更强.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/500/800/300"/>
        </item>
        <item>
            <title><![CDATA[网站重构升级计划]]></title>
            <link>https://blog.aquariuslt.com/posts/2015/12/27/site-upgrade-plan</link>
            <guid>https://blog.aquariuslt.com/posts/2015/12/27/site-upgrade-plan</guid>
            <pubDate>Sun, 27 Dec 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[大三的时候,终于接触了第一个能够证实上线的网站项目.
虽然那个项目最后的完成度不咋地,但是从头到尾从需求分析,代码编写,
最后部署到正式服务器上一条龙的经验还是被我全吃掉了.有了掌控Web项目的部署运]]></description>
            <content:encoded><![CDATA[<h1 id="网站重构升级计划">网站重构升级计划</h1>
<h2 id="background">Background</h2>
<p>大三的时候,终于接触了第一个能够证实上线的网站项目.
虽然那个项目最后的完成度不咋地,但是从头到尾从需求分析,代码编写,
最后部署到正式服务器上一条龙的经验还是被我全吃掉了.</p>
<p>有了掌控Web项目的部署运维的初级能力,所以我还是希望能够有一个自己的网站,自己亲手去维护.
由于自己设计UI又太low,然后对CMS的能力还是掌控不够.
所以,在购买了自己的VPS和域名之后,
就一直使用<code>WordPress</code>作为博客应用.</p>
<p>作为兴趣使然的Loser,收入不高.所以VPS一直都是购买的最低配.
(单核,512M内存,20GSSD)</p>
<p>本身这个配置去跑<code>WordPress</code>也是足够了.无奈将WP部署在阿里云的时候被攻击了好几次,导致经常瘫痪.
后来迁移到DO上情况还好,但是还是经常出现了MySQL进程死掉,守护进程也没用的情况.
一直觉得代码与资源都不在自己的掌握中比较苦难哦.
数据迁移与备份还需要导出WP的配置与MySQL的数据,操作起来比较繁琐.</p>
<blockquote>
<p>更可能是因为我不懂高级的运维技巧)</p>
</blockquote>
<p>后来,<code>Github Pages</code>静态博客的方式作为流行的一种打包型的博客托管方式进入我的视野,
也就是现在技术博客方面正在使用的方式.</p>
<p>毕业工作之后,开始接触到一些<code>MEAN</code>的技术栈,打算用这方面的知识,去构建新的主站方式.</p>
<h2 id="plan">Plan</h2>
<p>从目前的域名的管理情况来看,应该是打算 这样</p>
<blockquote>
<p>A域名<code>aquariuslt.com</code>作为导航主站,纯手工MEAN.
CNAME<code>blog.aquariuslt.com</code>作为主要的博客站,放Post
CNAME<code>debug.aquariuslt.com</code>作为主要的跌坑笔记手册
-- CNAME<code>game.aquariuslt.com</code>作为我的(粗口)游戏哲学理论 --</p>
</blockquote>
<p><a href="https://aquariuslt.com">主站</a>正在重建ing,已经可以访问
目前使用的是<code>iptables</code>命令进行端口转发
当然日后也可能考虑<code>httpd</code>转发or<code>nginx</code>.</p>
<h2 id="source">Source</h2>
<p>所有代码都放在Github上.</p>
<p>Home:<a href="https://github.com/Aquariuslt/Site-SourceCode">https://github.com/Aquariuslt/Site-SourceCode</a>
Blog<a href="https://github.com/Aquariuslt/Blog-SourceCode/">https://github.com/Aquariuslt/Blog-SourceCode/</a>
Debug<a href="https://github.com/Aquariuslt/Debug-SourceCode">https://github.com/Aquariuslt/Debug-SourceCode</a></p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/953/800/300"/>
        </item>
        <item>
            <title><![CDATA[Linux "libclntsh.so.11.1 cannot open shared object file no such file or directory"解决方案]]></title>
            <link>https://blog.aquariuslt.com/posts/2015/12/14/nodejs-libclntsh-so-11-1-cannot-open-shared-object-file</link>
            <guid>https://blog.aquariuslt.com/posts/2015/12/14/nodejs-libclntsh-so-11-1-cannot-open-shared-object-file</guid>
            <pubDate>Mon, 14 Dec 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[`Ubuntu 14.04`
`node v4.2.3`
`oracledb v1.4.0`
在正常安装好`Node.js`和`oracledb`,之后,用到oracledb的那一步就开始提示这个错误]]></description>
            <content:encoded><![CDATA[<h1 id="linux-libclntshso111-cannot-open-shared-object-file-no-such-file-or-directory解决方案">Linux &quot;libclntsh.so.11.1 cannot open shared object file no such file or directory&quot;解决方案</h1>
<h2 id="description">Description</h2>
<p><code>Ubuntu 14.04</code>
<code>node v4.2.3</code>
<code>oracledb v1.4.0</code>
在正常安装好<code>Node.js</code>和<code>oracledb</code>,之后,用到oracledb的那一步就开始提示这个错误;
重新跑<code>npm install</code>不能解决问题</p>
<h2 id="rootcause">RootCause</h2>
<p><code>LD_LIBRARY_PATH</code>没有设置好.
我将OracleInstantClient的安装目录的路径,释放在当前用户的环境变量中.
即将<code>export LD_LIBRARY_PATH=XXXX</code>写在当前user的<code>.bashrc</code>中
导致terminal中启动的时候,读不到LB_LIBRARY_PATH变量.
如果运行如下命令,没有设置环境变量的话,可以通过该解决方案解决.</p>
<pre><code>locate libclntsh.so.11.1
</code></pre>
<h2 id="solutions">Solutions</h2>
<p>将环境变量设置在<code>/etc/profile</code>中,问题解决.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/76/800/300"/>
        </item>
        <item>
            <title><![CDATA[Linux Mean 开发环境搭建]]></title>
            <link>https://blog.aquariuslt.com/posts/2015/12/13/ubuntu-mean-development-environment-setup</link>
            <guid>https://blog.aquariuslt.com/posts/2015/12/13/ubuntu-mean-development-environment-setup</guid>
            <pubDate>Sun, 13 Dec 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[最近一个项目中需要用到`Redis`和Node.js操作OracleDB,而Windows下开发就是屁事多.
恰好用到的这两个东西,都写明了官方不支持Windows,`Redis`在Widnows下的]]></description>
            <content:encoded><![CDATA[<h1 id="linux-mean-开发环境搭建">Linux Mean 开发环境搭建</h1>
<h2 id="background">Background</h2>
<p>最近一个项目中需要用到<code>Redis</code>和Node.js操作OracleDB,而Windows下开发就是屁事多.
恰好用到的这两个东西,都写明了官方不支持Windows,<code>Redis</code>在Widnows下的版本是由微软的工程师们在维护.
在Windows下搭建好了环境之后,发现<code>Redis</code>在Windows下会有一些常见的崩溃情况,上网搜了下估计是Windows才会有的情况.
本篇主要介绍在Linux(Ubuntu)下搭建MEAN Stack的相关内容,包括:</p>
<ul>
<li>Linux下<code>Redis</code>的安装与配置</li>
<li>Ubuntu下<code>Node.js</code>与<code>MongoDB</code>安装与配置</li>
<li>Linux下<code>oracledb</code>的安装与配置</li>
<li>Ubuntu下<code>IntelliJ IDEA</code>的配置</li>
</ul>
<blockquote>
<p>可能看起来有点奇怪,为什么我会<code>Linux</code>,<code>Ubuntu</code>这样穿插这顺序反过来写
这是因为由于<code>Ubuntu</code>安装<code>Node.js</code>这方面我使用的是 <code>apt-get</code>来管理安装包
而<code>oracledb</code>又是<code>Node.js</code>的一个类库</p>
</blockquote>
<h2 id="linux下redis的安装与配置">Linux下Redis的安装与配置</h2>
<h3 id="下载">下载</h3>
<p>从官方地址
<a href="https://github.com/antirez/redis/archive/2.8.23.tar.gz">https://github.com/antirez/redis/archive/2.8.23.tar.gz</a>
下载.
由于项目用到的Redis版本是2.8,所以下的是2.8版本.</p>
<h3 id="安装">安装</h3>
<p>将 redis2.8.23.tar.gz 解压到任意文件夹.</p>
<blockquote>
<p>目前按照个人习惯还是放在home下面一个叫server的目录
但是unix系统的路径与程序摆放位置应该是大有讲究的,近期将会加强研究之后更新结论
先凑合着放</p>
</blockquote>
<p>此时文件列表应该如下:</p>
<pre><code>Macbook:redis-2.8.23 Aquariuslt$ tree -L 1
.
├── 00-RELEASENOTES
├── BUGS
├── CONTRIBUTING
├── COPYING
├── INSTALL
├── MANIFESTO
├── Makefile
├── README
├── deps
├── redis.conf
├── runtest
├── runtest-sentinel
├── sentinel.conf
├── src
├── tests
└── utils

4 directories, 12 files

</code></pre>
<p>看到有<code>makefile</code>就知道需要自己编译一边,其实这里按照官网的Installation就可以.
直接输入<code>make</code>编译</p>
<pre><code>$ wget https://download.redis.io/releases/redis-3.0.5.tar.gz
$ tar xzf redis-3.0.5.tar.gz
$ cd redis-3.0.5
$ make
</code></pre>
<h3 id="以服务运行">以服务运行</h3>
<p>在<code>Redis</code>安装目录下有一些脚本,执行之后,帮助以Service运行</p>
<pre><code>
In order to install Redis binaries into /usr/local/bin just use:

    % make install

You can use &quot;make PREFIX=/some/other/directory install&quot; if you wish to use a
different destination.

Make install will just install binaries in your system, but will not configure
init scripts and configuration files in the appropriate place. This is not
needed if you want just to play a bit with Redis, but if you are installing
it the proper way for a production system, we have a script doing this
for Ubuntu and Debian systems:

    % cd utils
    % ./install_server.sh

The script will ask you a few questions and will setup everything you need
to run Redis properly as a background daemon that will start again on
system reboots.

You'll be able to stop and start Redis using the script named
/etc/init.d/redis_&lt;portnumber&gt;, for instance /etc/init.d/redis_6379.
</code></pre>
<p>如果执行<code>make install</code>命令,则自动ln到<code>/usr/local/bin</code>
如果执行<code>utils</code>路径下的<code>install_server.sh</code>则会添加启动项,开机自动运行.</p>
<h2 id="ubuntu下nodejs与mongodb的安装与配置">Ubuntu下Node.js与MongoDB的安装与配置</h2>
<blockquote>
<p>在Linux下<code>Node.js</code>的安装并不像<code>Windows</code>,<code>OS X</code>有.msi,.pkg 安装包走UI安装.
但是在各个发行版的Linux下都有自己对应的包管理器.
<code>Ubuntu</code>就有自己的包管理器<code>apt-get</code>(但是会有坑)</p>
</blockquote>
<p>Ubuntu 安装<code>Node.js</code>可以分成如下步骤</p>
<ol>
<li>更新包管理器的版本,使之能够获取最新版本的应用程序包</li>
<li>通过包管理器,安装<code>Node.js</code></li>
<li>通过<code>npm</code>再更新一次<code>Node.js</code></li>
</ol>
<h3 id="更新ubuntu的包管理器">更新Ubuntu的包管理器</h3>
<pre><code>$apt-get update
</code></pre>
<h3 id="通过包管理器安装nodejs">通过包管理器安装Node.js</h3>
<pre><code>$apt-get install nodejs-legacy
</code></pre>
<p>通过此命令安装的是一个比较老版本的Node.js
输入查看版本命令大概是 node v0.10 和 npm v1.14</p>
<blockquote>
<p>我也不知道为什么Ubuntu的package list 更新了之后 Node.js包版本还是那么低..
下面更新的Node.js版本以2015-12-13官网的稳定版本为准</p>
</blockquote>
<pre><code>node -v &amp;&amp; npm -v
</code></pre>
<p>这时候,首先先升级 <code>npm</code> 到 <code>npm3</code></p>
<pre><code>$npm install -g npm
</code></pre>
<blockquote>
<p>此时npm的版本应该更新到v3.5.1+</p>
</blockquote>
<p>然后通过<code>npm</code>安装一个用<code>node</code>去切换<code>node</code>版本的库,叫做<code>n</code></p>
<pre><code>$npm install -g n
</code></pre>
<p>接着用<code>n</code>去安装所需版本的<code>node.js</code></p>
<pre><code>$n v4.2.3
</code></pre>
<p>重启电脑
之后在查看<code>node</code>和<code>npm</code>版本,应该如下图
<img src="https://img.aquariuslt.com/posts/2015/12/update-nodejs.webp" alt="更新Node.js"></p>
<h2 id="linux下node-oracledb的配置">Linux下Node-OracleDB的配置</h2>
<p>Linux 下搭建好node-oracledb 也是相当操蛋.
大概需要做下面几个工作:</p>
<ul>
<li>下载 version &gt;= 11.2 的OracleInstantClient(basic&amp;sdk)</li>
<li>设置环境变量,供构建npm install oracledb 构建使用</li>
</ul>
<h3 id="下载-oracleinstantclient-for-linux">下载 OracleInstantClient for Linux</h3>
<p>官网还要登陆下载,太过傻逼.所以放出了个某度的链接
<a href="https://pan.baidu.com/s/1boxV2iV">https://pan.baidu.com/s/1boxV2iV</a></p>
<h3 id="设置环境变量">设置环境变量</h3>
<p>先将下载的两个zip包解压到<code>/opt/oracle/instantclient</code>下.</p>
<blockquote>
<p>官方推荐,可自行替换路径</p>
</blockquote>
<p>然后修改全局的环境变量.</p>
<blockquote>
<p><strong>注意</strong> 这里说的是 <strong>全局变量</strong>,这里曾经被坑过一次.
通过命令行的 <code>export PATH=XXX:PATH</code>之类的命令.只能作为临时变量,重启之后就会失效
而Linux的环境变量,跟Windows类似,也分成全局的环境变量和当前用户的环境变量.
在系统启动之后,先读取全局变量,用户登陆之后,再继承全局环境变量的前提下,读取当前用户的环境变量</p>
</blockquote>
<pre><code>$sudo gedit /etc/profile
</code></pre>
<p>在底部添加如下内容</p>
<pre><code># Export Oracle Client Varirable
export OCI_LIB_DIR=/opt/oracle/instantclient
export OCI_INC_DIR=/OPT/oracle/instantclient
export ORACLE_HOME=$OCI_LIB_DIR
export LD_LIBRARY_PATH=/opt/oracle/instantclient:$LD_LIBRARY_PATH
</code></pre>
<p><img src="https://img.aquariuslt.com/posts/2015/12/add-oracle-cli-global-env-var.webp" alt="添加Oracle Client 相关全局环境变量"></p>
<p>此时执行命令安装 <code>oracledb</code> 大概应该不会出问题了</p>
<blockquote>
<p>其实还有个小问题,<code>oracledb</code>得必须是1.3.0 以上的版本..不然爆的错我也无法入手解决</p>
</blockquote>
<pre><code>$npm install oracledb
</code></pre>
<h2 id="ubuntu下intellij-idea的配置">Ubuntu下IntelliJ IDEA的配置</h2>
<p>终于到重头戏了.其实我就是想说这个
在GNOME下安装Idea遵循下面几步</p>
<ol>
<li>安装JDK,设置JDK相关环境变量</li>
<li>配置Idea在Ubuntu的启动图标</li>
<li>一些关于Idea在Linux下与Widnows/Mac不同的特殊配置</li>
</ol>
<h3 id="安装jdk">安装JDK</h3>
<p>从Oracle 官网下载Linux版本jdk,解压到<code>/usr/lib/jvm/jdk8</code>下.</p>
<blockquote>
<p>该路径也是个人喜好,官网推荐这么做就照做了
因为Idea启动的时候需要检查 Java的安装.且是按照<code>IDEA_JDK</code>,
<code>JDK_HOME</code>,<code>JAVA_HOME</code>的顺序来进行查找,只要其中之一存在且对应了JDK的路径即可</p>
</blockquote>
<p>所以,在系统中添加全局环境变量
如下图</p>
<pre><code>$sudo gedit /etc/profile
</code></pre>
<p>在底部添加</p>
<pre><code># Set JAVA_HOME fOR Maven/Idea Settings
export JAVA_HOME=/usr/lib/jvm/jdk8
export JDK_HOME=$JAVA_HOME
export IDEA_JDK=$JAVA_HOME
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>
<p>保存后,查看java版本</p>
<pre><code>$java -version
</code></pre>
<p><img src="https://img.aquariuslt.com/posts/2015/12/config-jdk-path.webp" alt="配置JDK路径"></p>
<h3 id="配置idea在ubuntu中的启动图标">配置Idea在Ubuntu中的启动图标</h3>
<p>默认情况下,通过Idea目录下的<code>/bin/idea.sh</code>即可启动IdeaUI
但是为了能够显示Ubuntu的docker里面(左边那条任务栏,不知道叫什么东西,叫docker吧)</p>
<p>需要在<code>/usr/share/applications</code>下新建一个<code>intellij-idea.desktop</code>
加个配置文件</p>
<blockquote>
<p>我本地的Idea解压后的目录在<code>/home/dev/Applications/IntellijIdea15</code></p>
</blockquote>
<pre><code>[Desktop Entry]
Type=Application
Name=IntelliJ IDEA
Comment=The best Java and MEAN IDE
Icon=/home/dev/Applications/IntellijIdea15/bin/idea.png
Exec=/home/dev/Applications/IntellijIdea15/bin/idea.sh
Terminal=false
Categories=Development;IDE;Java;
</code></pre>
<p><img src="https://img.aquariuslt.com/posts/2015/12/add-app-launch-icon.webp" alt="添加Ubuntu Applications启动图标"></p>
<h3 id="idea在ubuntu下一些特殊的配置">Idea在Ubuntu下一些特殊的配置</h3>
<blockquote>
<p>虽然都是类Unix系统,Idea跟Mac在一些读取环境变量时候的做法不大一样.
本质上其实还是我对他认识不够深,还找不到原因..以后找到会更新
Liux下在<code>run configuration</code>里面添加新的<code>Node.js</code>脚本或者<code>shell</code>脚本的时候,有一些不一样的地方就是
通过Ubuntu桌面启动Idea,会读不到用户级别的环境变量.
所以有一在配置一些的脚本的时候,需要确保运行时的环境变量,查看方法</p>
</blockquote>
<p>在<code>Run Configurations</code>-&gt;<code>Environment Variables</code>-&gt;<code>Include Parents Variables</code>-&gt;<code>Show</code> 查看所有环境变量.
如果没有,烦请自己加上,为求能达到与Terminal运行同样的结果.</p>
<p><img src="https://img.aquariuslt.com/posts/2015/12/check-run-configuration.webp" alt="查看Run Configurations全局变量"></p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/873/800/300"/>
        </item>
        <item>
            <title><![CDATA[记一次神奇的优化过程:Java反射 VS Apache BeanUtils VS Spring BeanUtils]]></title>
            <link>https://blog.aquariuslt.com/posts/2015/11/10/beanutils-vs-reflection</link>
            <guid>https://blog.aquariuslt.com/posts/2015/11/10/beanutils-vs-reflection</guid>
            <pubDate>Tue, 10 Nov 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[最近老大分配了个性能优化的任务,因为主要页面在Production上打开的时间太长,(大概7s?卧槽 第一次听到的时候还以为我听错了).
居然这么慢..
其实是有主程序大大带着我做,所以在扫了一遍前端]]></description>
            <content:encoded><![CDATA[<h1 id="记一次神奇的优化过程java反射-vs-apache-beanutils-vs-spring-beanutils">记一次神奇的优化过程:Java反射 VS Apache BeanUtils VS Spring BeanUtils</h1>
<h2 id="background">Background</h2>
<p>最近老大分配了个性能优化的任务,因为主要页面在Production上打开的时间太长,(大概7s?卧槽 第一次听到的时候还以为我听错了).
居然这么慢..
其实是有主程序大大带着我做,所以在扫了一遍前端ExtJS的结构之后,发现错综复杂四年以来不同技术层次的人都在同一个页面上添油加醋,
了解以前的需求之后完全重构基本是不可能的,所以前端的性能优化就交给主程序大大,我跑去扫一下服务器端有什么性能瓶颈.</p>
<h3 id="使用-jprofiler-分析-代码性能">使用 JProfiler 分析 代码性能</h3>
<blockquote>
<p>通过网上找来的资料,比较了一份周围的资料
IBM的 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-profiling/">常用 Java Profiling 工具的分析与比较</a>
最后决定使用JProfiler进行性能分析</p>
</blockquote>
<h4 id="intellij-idea集成-jprofiler-监控-weblogic-实例">IntelliJ IDEA集成 JProfiler 监控 Weblogic 实例</h4>
<p>idea 集成了 (应该是JProfiler本身就带了idea的插件安装) 安装之后就会 在启动服务器运行的 按钮多出一个 使用JProfiler 运行.</p>
<blockquote>
<p>由于JProfiler 本身也是通过javaagent的方法更改一些类加载运行时策略,所以会跟Jrebel冲突.
所以在使用JProfiler监控性能的时候,如果之前在weblogic服务器运行配置的过程中添加了jrebel.jar 作为javaagent的参数,务必删掉
其余配置 与之前的<a href="https://blog.aquariuslt.com/posts/2015/10/08/jrebel-configuration-with-weblogic-in-idea/">Jrebel插件结合weblogic</a>一样</p>
</blockquote>
<h4 id="通过jprofiler-分析方法执行时间">通过JProfiler 分析方法执行时间</h4>
<p>通过JProfiler插件启动weblogic服务器实例之后,JProfiler的GUI界面将会启动,并成功监听到对应的实例进程.
实例成功启动之后,下面会有一个CPU Time的标签页,选中并点击<code>record</code>.
触发任意次目标方法,即可看到所有方法的执行时间</p>
<p><img src="https://img.aquariuslt.com/posts/2015/11/method-executing-time.webp" alt="方法执行时间"></p>
<h3 id="正文性能优化部分">正文:性能优化部分</h3>
<p>言归正传,在看到性能分析记录的时候,一个叫做
<code>ReflectionUtil.convertObjectWithSameFields()</code>
的方法,方法体如下</p>
<pre><code class="hljs Java"><span class="hljs-comment">/**
* Convert between two Object with the same field, setter and getter
*
* <span class="hljs-doctag">@param</span> target
*            the object wants to be convert to
* <span class="hljs-doctag">@param</span> source
*            the object as source of converter
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertObjectToObjectWithSameFields</span><span class="hljs-params">(Object target, Object source)</span> </span>{
    List&lt;Field&gt; detailFields = <span class="hljs-keyword">new</span> ArrayList&lt;Field&gt;();
    List&lt;Field&gt; oFields = <span class="hljs-keyword">new</span> ArrayList&lt;Field&gt;();
    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clas = target.getClass(); clas != Object.class; clas = clas.getSuperclass()) {
        detailFields.addAll(Arrays.asList(clas.getDeclaredFields()));
    }
    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clas = source.getClass(); clas != Object.class; clas = clas.getSuperclass()) {
        oFields.addAll(Arrays.asList(clas.getDeclaredFields()));
    }
    <span class="hljs-keyword">for</span> (Field dField : detailFields) {
        <span class="hljs-keyword">for</span> (Field oField : oFields) {
            String targetField = dField.getName();
            String sourceField = oField.getName();
            <span class="hljs-keyword">if</span> (targetField.equals(sourceField)) {
                <span class="hljs-keyword">try</span> {
                    Object object = getAttributeValue(oField.getName(), source, <span class="hljs-keyword">true</span>);
                    <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>)
                        setAttributeValue(dField.getName(), object, target, object.getClass());
                } <span class="hljs-keyword">catch</span> (Exception e) {
                }
            }
        }
    }
}
</code></pre>
<p>原来是使用了JDK的反射API,遍历两个Bean的属性去进行对应的<code>getter</code>,<code>setter</code>方法.时间复杂度为O(n*m),(可是到后面发现好像并不是这个时间复杂度的问题,囧).
由于JDK原生的Reflection比较辣鸡,效率比较慢,所以造成了本次性能瓶颈的原因之一.</p>
<p>一开始先是想到了Apache CommonUtils类库里面的BeanUtils 和 PropertyUtils来替换同事造的效率很低的轮子
通过看源码,大概发现BeanUtils是这样实现属性复制的</p>
<p>首先他会将 需要进行属性复制的两个Bean抽取出来,然后一个Map储存其类型和名字相同的属性.
接着这个Map会根据里面的几种属性分成对应的属性(大概是基本类型,List类型,Map类型以及自定义类型)</p>
<p>在进行属性复制的时候,会根据该动态Bean里面的属性,来找到目标Bean是否含有对应的setProperites方法,然后调用 源Bean的getProperties方法.</p>
<p>但是这个BeanUtils 有个缺点,就是遇到很操蛋的属性(恰好遇到这个情况)的时候,不能对一些属性进行ignore操作.</p>
<blockquote>
<p>原因是需要转换的两个JavaBean其实并不是规范的JavaBean
其中一个JavaBean 有一个getter方法,叫做getXX() 但是返回的却是 一个List集合的第一个元素.
这时候操蛋的另一个JavaBean 也有一个 setter方法,叫做setXX() 但是这个JavaBean却是规范的JavaBean.</p>
</blockquote>
<p>最后是使用Spring-Bean的BeanUtils解决问题的.因为它能够传第一个ingore的属性名集合进去,不读这部分.</p>
<p>优化结果是,将原来的轮子替换成Spring的BeanUtils.
结果比在本地测试快了700ms,希望在Production上也有300+ms的优化表现.</p>
<h2 id="summary">Summary</h2>
<p>实现不同的JavaBean(常见场景是Entity,DTO,VO)之间相同属性名的转化过程,可以利用BeanUtils.copyProperties来实现.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/221/800/300"/>
        </item>
        <item>
            <title><![CDATA[Spring 整合 Apache Shiro 实现各等级的权限管理]]></title>
            <link>https://blog.aquariuslt.com/posts/2015/10/25/apache-shiro-spring-integration</link>
            <guid>https://blog.aquariuslt.com/posts/2015/10/25/apache-shiro-spring-integration</guid>
            <pubDate>Sun, 25 Oct 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[前几个月在做一个常规的权限隔离功能的时候,恰好使用过Apache Shiro.
Apache Shiro 是一款Java的安全框架,通常用作Web应用的权限校验,身份验证.Apache Shiro i]]></description>
            <content:encoded><![CDATA[<h1 id="spring-整合-apache-shiro-实现各等级的权限管理">Spring 整合 Apache Shiro 实现各等级的权限管理</h1>
<h2 id="background">Background</h2>
<p>前几个月在做一个常规的权限隔离功能的时候,恰好使用过Apache Shiro.
Apache Shiro 是一款Java的安全框架,通常用作Web应用的权限校验,身份验证.</p>
<blockquote>
<p>Apache Shiro is a powerful and easy-to-use Java security framework that performs authentication,
authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you
can quickly and easily secure any application – from the smallest mobile applications to the
largest web and enterprise applications.</p>
</blockquote>
<p>在参考过 IBM 开发社区关于Shiro的博客 一篇文章 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-shiro/">在Web项目中应用Apache Shiro</a>
与开涛博客的一个跟我学Shiro系列文章 <a href="https://jinnianshilongnian.iteye.com/blog/2024723">开涛博客-跟我学Shiro</a></p>
<blockquote>
<p>不得不说的是IBM Developer社区的文章一向属于生动易懂.
但是上面的这篇讲得并没有之前推荐的讲Spring-DataJPA的那篇文章那样浅显,
于是才有了现在这份笔记</p>
</blockquote>
<h2 id="权限控制">权限控制</h2>
<p>我所接触到的权限控制大概可以分成两个级别 URL和方法级别.</p>
<p>以常见的论坛用户来举例.论坛用户简要的分成两种 管理员<code>Admin</code>,普通用户<code>Normal</code>.
其中管理员能够进入用户管理,帖子管理的页面进行CRUD操作.
普通用户则只能进行自己帖子的CRU操作,以及顶贴什么的.</p>
<p>如果只进行URL级别的拦截,只需要在每一个URL的访问时 获取用户的角色是<code>Admin</code>还是<code>Normal</code>即可.</p>
<p>如果是进行方法级别的拦截,则可能根据功能的设计衍生出很多设计方案(一眼就能想到的大概是树状,平行等).
但是由于跟数据库的设计密切相关,所以这个级别不细讲.
言归正传(不知道是不是看light大大博客看多了,语气有点奇怪),下面结合上面的论坛用户的一个场景进行逻辑与代码的讲解</p>
<h3 id="url级别的权限控制">URL级别的权限控制</h3>
<h4 id="业务场景假设">业务场景假设</h4>
<p>首先,我们假设有以下几种种URL</p>
<pre><code>/user/create        //用户创建,Admin专属
/post/create        //发帖 Admin,Normal共有
/login              //登陆
/logout             //注销
</code></pre>
<h4 id="shiro基本配置">Shiro基本配置</h4>
<h5 id="maven">Maven</h5>
<p><code>$&lt;shiro.version&gt;</code>请自行替换成当前的最新版本</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${shiro.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${shiro.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${shiro.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${shiro.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h5 id="webxml">web.xml</h5>
<p>为了实现与Spring同一个级别的URL拦截,需要将Shiro的Filter配置在Spring MVC的Dispatcher Servlet同一个级别</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>
</code></pre>
<h5 id="spring-applicationcontextxml">Spring ApplicationContext.xml</h5>
<p>在与Spring进行整合的时候,为了方便拼切配置,在Spring 里面导入另一份专用于Shiro的xml配置</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"config/security/applicationContext-shiro-captcha.xml"</span>/&gt;</span>
</code></pre>
<h5 id="spring-applicationcontext-shiro-captchaxml">Spring applicationContext-shiro-captcha.xml</h5>
<p>先将整个 shiro的xml配置贴出来,接下来在逐一解说其内容</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"https://www.springframework.org/schema/beans"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"https://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.1.xsd"</span>
       <span class="hljs-attr">default-lazy-init</span>=<span class="hljs-string">"true"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Shiro安全配置<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Shiro's main business-tier object for web-enabled applications --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"realm"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroRealm"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroEhcacheManager"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 項目自定义的Realm --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroRealm"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.quariuslt.service.security.BookingShiroRealm"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginSessionService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"loginSessionService"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroEhcacheManager"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 用户授权信息Cache, 采用EhCache --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroEhcacheManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManagerConfigFile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:config/security/ehcache-shiro.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lifecycleBeanPostProcessor"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span>


    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"captchaFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.quariuslt.service.security.CaptchaFormAuthenticationFilter"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"adminPermissionFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.quariuslt.service.security.AdminPermissionFilter"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"normalPermissionFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.quariuslt.service.security.NormalPermissionFilter"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- Shiro Filter --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/booking/search"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filters"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"authc"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"captchaFilter"</span>/&gt;</span>
                <span class="hljs-comment">&lt;!--&lt;entry key="roles[admin]" value-ref="captchaFilter"/&gt;--&gt;</span>
                <span class="hljs-comment">&lt;!--&lt;entry key="roles[normal]" value-ref="captchaFilter"/&gt;--&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>
                /=authc
                /register = anon
                /forgot =anon
                /login = anon
                /login/action* = anon
                /logout = logout
                /js/** = anon
                /rest/**=anon
                /image/**=anon
                /jawr_loader.js=anon
                /user/create=roles[admin]
                /post/create/**=roles[normal|admin]
                /** =authc
            <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<h4 id="配置详解">配置详解</h4>
<p>首先要理解一件事情,就是Shiro的权限控制 源自于Web.xml的Filter,在Filter中获取目标URL的请求,解析以达到根据请求是否到达下一集Filter的作用.
再要理解一件约定大于配置的问题,了解Shiro的一些默认配置解说.</p>
<p>在贴出来的<code>shiro-captcha.xml</code>配置代码中:</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Shiro Filter --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/booking/search"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filters"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"authc"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"captchaFilter"</span>/&gt;</span>
            <span class="hljs-comment">&lt;!--&lt;entry key="roles[admin]" value-ref="captchaFilter"/&gt;--&gt;</span>
            <span class="hljs-comment">&lt;!--&lt;entry key="roles[normal]" value-ref="captchaFilter"/&gt;--&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>
            /=authc
            /register = anon
            /forgot =anon
            /login = anon
            /login/action* = anon
            /logout = logout
            /js/** = anon
            /rest/**=anon
            /image/**=anon
            /jawr_loader.js=anon
            /user/create=roles[admin]
            /post/create/**=roles[normal|admin]
            /** =authc
        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>先来看<code>&lt;property name=&quot;filterChainDefinitions&quot;&gt;</code>中的属性.
&lt;values&gt;的内容,其实是url对应权限的一些mapping.表示对应的url mapping 需要对应的权限.
其中<code>authc</code>,<code>anon</code>,<code>logout</code>样例中提及的这三个,是Shiro自己的默认配置</p>
<blockquote>
<p><code>authc</code>表示,这这个mapping代表的url需要登陆之后才能查看
<code>anon</code>表示,这个mapping代表的url全部放行,所以可以看到所有js文件与image文件都被放行了
<code>logout</code> 表示这个mapping代表的url将进行一次注销操作,在浏览器客户端进行的是session的注销,在服务器端则是进行缓存的删除</p>
</blockquote>
<p>其中 <code>roles[admin],roles[normal|admin]</code> 则是自己定义的过滤规则.
表示<code>/user/create</code>只有角色包含<code>admin</code>的有权限访问
且<code>/post/create</code>则是角色是<code>admin</code>或<code>normal</code>的有权限访问</p>
<h5 id="登录与注销">登录与注销</h5>
<h6 id="登录">登录</h6>
<p>对于所有需要登录的URL可以通过 <code>authc</code>一个拦截器来拦截
在未登录的状态下,所有所有需要登录的URL都是自动跳转到上面XML所配置的<code>loginUrl</code>之中.
当然这里返回的是 一个对 <code>/login</code>路径的get请求</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span>
</code></pre>
<h6 id="注销">注销</h6>
<p>注销也很简单,只要任意url能够跳转到<code>/logout</code>,便会自动注销.</p>
<h5 id="同步登录与异步登陆">同步登录与异步登陆</h5>
<p>其实在Shiro的配置中,通过阅读源码可以看出,其实<code>loginUrl</code>一个属性,代表的是
当Method=Get的请求到达其值对应的url(/login)时,返回登录的页面.
当Method=Post的请求到达其值对应的url(/login)时,进入到的就是Shiro本身的登陆操作
该操作,通过读取<code>securityManager</code>的配置,</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span>
</code></pre>
<p>通过自定义的realm <code>BookingShiroRealm</code></p>
<blockquote>
<p>此处<code>BookingShiroRealm</code>是自己定义的名称,只是为了符合但是的业务需要起的名字</p>
</blockquote>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Shiro's main business-tier object for web-enabled applications --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"realm"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroRealm"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroEhcacheManager"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 項目自定义的Realm --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroRealm"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.quariuslt.service.security.BookingShiroRealm"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginSessionService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"loginSessionService"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"shiroEhcacheManager"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>接下来解说一下
<code>BookingShiroRealm.java</code>
的内容</p>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookingShiroRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOGIN_SESSION_NAME=<span class="hljs-string">"loginSession"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SIMPLE_AUTHORIZATION_INFO=<span class="hljs-string">"simpleAuthorizationInfo"</span>;

    <span class="hljs-keyword">private</span> LoginSessionService loginSessionService;

    <span class="hljs-keyword">private</span> UserService userService;


    <span class="hljs-function"><span class="hljs-keyword">public</span> LoginSessionService <span class="hljs-title">getLoginSessionService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> loginSessionService;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoginSessionService</span><span class="hljs-params">(LoginSessionService loginSessionService)</span> </span>{
        <span class="hljs-keyword">this</span>.loginSessionService = loginSessionService;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">getUserService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> userService;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserService</span><span class="hljs-params">(UserService userService)</span> </span>{
        <span class="hljs-keyword">this</span>.userService = userService;
    }

    <span class="hljs-comment">/*授权信息*/</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>{
        LoginSession loginSession = (LoginSession) principals.fromRealm(getName()).iterator().next();
        <span class="hljs-keyword">if</span>(SecurityUtils.getSubject().getSession().getAttribute(LOGIN_SESSION_NAME)==<span class="hljs-keyword">null</span>){
            SecurityUtils.getSubject().getSession().setAttribute(LOGIN_SESSION_NAME, loginSession);
        }
        <span class="hljs-keyword">if</span>(SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO)==<span class="hljs-keyword">null</span>){

            UserDto userDto=userService.findUserById(loginSession.getUserId());
            <span class="hljs-keyword">if</span> (userDto != <span class="hljs-keyword">null</span>) {
                SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();
                Set&lt;RoleDto&gt; roleDtoSet=userService.getUserRolesByUserId(userDto.getId());
                <span class="hljs-keyword">for</span>(RoleDto roleDto:roleDtoSet){
                    info.addRole(roleDto.getName().toLowerCase());
                }

                SecurityUtils.getSubject().getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO, info);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            }
        }
        <span class="hljs-keyword">return</span> (AuthorizationInfo)SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO);
    }

    <span class="hljs-comment">/*认证信息*/</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>{
        System.out.println(<span class="hljs-string">"Come to BookingShiroRealm"</span>);
        UsernamePasswordToken token=(UsernamePasswordToken)authenticationToken;
        String userId=token.getUsername();
        String cryptedPassword= String.valueOf(token.getPassword());
        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(userId)){
            UserDto targetUser=userService.getByUserId(userId);
            System.out.println(<span class="hljs-string">"TargetUser:"</span>+userId+<span class="hljs-string">" InputPassWord:"</span>+cryptedPassword+<span class="hljs-string">" DB PassWord:"</span>+targetUser.getCryptedPassword());
            <span class="hljs-keyword">if</span>(cryptedPassword.equals(targetUser.getCryptedPassword())){
                System.out.println(<span class="hljs-string">"BookingShiroRealm:Login Success"</span>);
                LoginSession loginSession=<span class="hljs-keyword">new</span> LoginSession(targetUser.getId(), targetUser.getUserId(),targetUser.getEmail(),SecurityUtils.getSubject().getSession().getHost());
                loginSessionService.clearSessionByUserId(userId);
                loginSessionService.save(loginSession);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(loginSession,targetUser.getCryptedPassword().toCharArray(),getName());
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}

</code></pre>
<p><code>AuthorizingRealm</code>是Shiro负责身份认证的抽象类.
需要实现其<code>doGetAuthenticationInfo</code>方法,实现 对提交过来的用户名/密码 等账号信息,跟数据库进行交互判定登陆是否成功的过程.
和实现其<code>doGetAuthorizationInfo</code>方法,实现对需要登陆之后 对权限的认证.</p>
<p>在说到登陆的校验之前,可以看到在<code>doGetAuthenticationInfo</code>方法里面 有一个authenticationToken.里面包含了登陆传递过来的用户名和密码信息.这里又是怎么来的呢.
此时返回来回到Spring配置Shiro的xml <code>applicationContext-shiro-captcha.xml</code>
会发现</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filters"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"authc"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"captchaFilter"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"roles[admin]"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"captchaFilter"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"roles[normal]"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"captchaFilter"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
</code></pre>
<p>里面会有一个<code>captchaFilter</code>,
指向其注入的类 <code>CaptchaFormAuthenticationFilter.java</code></p>
<p>附上<code>CaptchaFormAuthenticationFilter</code>代码</p>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptchaFormAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FormAuthenticationFilter</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CAPTCHA_PARAM = <span class="hljs-string">"captcha"</span>;

    <span class="hljs-keyword">private</span> String captchaParam = DEFAULT_CAPTCHA_PARAM;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCaptchaParam</span><span class="hljs-params">()</span> </span>{

        <span class="hljs-keyword">return</span> captchaParam;

    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getCaptcha</span><span class="hljs-params">(ServletRequest request)</span> </span>{

        <span class="hljs-keyword">return</span> WebUtils.getCleanParam(request, getCaptchaParam());

    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLoginFailure</span><span class="hljs-params">(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response)</span> </span>{
        setFailureAttribute(request, e);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFailureAttribute</span><span class="hljs-params">(ServletRequest request, AuthenticationException ae)</span> </span>{
        String className = ae.getClass().getName();
        request.setAttribute(getFailureKeyAttribute(), className);
    }

    <span class="hljs-comment">//这里进行密码的加密</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> CaptchaUsernamePasswordToken <span class="hljs-title">createToken</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> </span>{
        System.out.println(<span class="hljs-string">"Come to CreateToken"</span>);
        String username = getUsername(request);
        String password = getPassword(request);
        String captcha = getCaptcha(request);
        <span class="hljs-keyword">boolean</span> rememberMe = isRememberMe(request);
        String host = getHost(request);

        System.out.println(<span class="hljs-string">"Captcha UserName(UserId):"</span> + username);
        System.out.println(<span class="hljs-string">"Captcha Password:"</span> + password);
        System.out.println(<span class="hljs-string">"Captcha RememberMe:"</span> + rememberMe);


        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaptchaUsernamePasswordToken(username,
                password.toCharArray(), rememberMe, host, captcha);

    }


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">executeLogin</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        CaptchaUsernamePasswordToken token = createToken(request, response);

        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-string">"Execute Login~"</span>);
            Subject subject = getSubject(request, response);
            subject.login(token);

            <span class="hljs-keyword">return</span> onLoginSuccess(token,subject, request, response);
        } <span class="hljs-keyword">catch</span> (AuthenticationException e) {
            <span class="hljs-keyword">return</span> onLoginFailure(token,e, request, response);
        }
    }
}
</code></pre>
<p>继承<code>FormAuthenticationFilter</code>的<code>CaptchaFormAuthenticationFilter</code>并重写其<code>CaptchaUsernamePasswordToken</code>方法.
用于通过<code>/login</code>的POST方式提交过来的时候,便会先经过此filter的<code>createToken</code>方法进行token的生成</p>
<p>假设有一个登陆页面的<code>/login</code>使用同步提交方式,即通过页面的form表单,<code>action=&quot;/login&quot;</code>,<code>method=&quot;POST&quot;</code>提交到后台,触发流程是</p>
<blockquote>
<ol>
<li>到达 <code>FormAuthenticationFilter</code> 根据表单 生成Token.</li>
<li>调用 Shiro专门处理认证的 <code>subject</code>其<code>login</code>方法进行登陆</li>
<li><code>login</code>方法 通过调用 自定义的<code>BookingShiroRealm</code>方法所实现的顶级接口 来实现对数据库的信息的读取</li>
<li>判定登陆用户名与密码 匹配之后,可以通过Shiro自己配置的缓存保存认证信息.</li>
</ol>
</blockquote>
<p>但是在这个时代,还通过同步登陆 实在是太TM捞了,其实异步登陆提交,只需要 手动调用subject.login方法即可
将第一步到达<code>FormAuthenticationFilter</code>的token手动生成</p>
<p>异步登陆的实现代码 大概如下(以Controller为例)</p>
<pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/action"</span>, method = RequestMethod.POST,produces = MediaType.APPLICATION_JSON_VALUE)
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> LoginMessage <span class="hljs-title">loginAction</span><span class="hljs-params">(
        @RequestParam(value = <span class="hljs-string">"username"</span>)</span> String username,
        @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value = <span class="hljs-string">"password"</span>)</span> String password,
        @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value = <span class="hljs-string">"rememberMe"</span>, required = <span class="hljs-keyword">false</span>, defaultValue = <span class="hljs-string">"false"</span>)</span> <span class="hljs-keyword">boolean</span> rememberMe,
        ServletRequest request) </span>{
    LoginMessage loginMessage = <span class="hljs-keyword">new</span> LoginMessage(BKGConstants.ActionStatus.FAILURE.getDescription());
    Subject subject = SecurityUtils.getSubject();


    <span class="hljs-comment">//尝试获取 跳转到Login前的那个页面的url</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != WebUtils.getSavedRequest(request)) {
        String requestURI= WebUtils.getSavedRequest(request).getRequestURI();
        loginMessage.setRedirect(requestURI);
    }

    <span class="hljs-keyword">try</span> {
        String salt=userService.getByUserId(username).getSalt();
        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username, EncryptUtil.encrypt(password,salt));
        subject.login(token);
        loginMessage.setStatus(BKGConstants.ActionStatus.SUCCESS.getDescription());

        <span class="hljs-comment">//尝试判断 用户是不是第一次登陆</span>
        UserDto currentUser=userService.getByUserId(username);
        <span class="hljs-keyword">if</span> (currentUser.getActive().equals(BKGConstants.UserAccountStatus.FIRST_LOGIN.getIndex())){
            String redirectPath=request.getServletContext().getContextPath()+<span class="hljs-string">"/user/password/reset"</span>;
            loginMessage.setRedirect(redirectPath);
        }


    } <span class="hljs-keyword">catch</span> (UnknownAccountException e) {
        loginMessage.setMessage(BKGConstants.LoginFailureMessage.PASSWORD_WRONG.getDescription());
    } <span class="hljs-keyword">catch</span> (IncorrectCredentialsException |NullPointerException e) {
        loginMessage.setMessage(BKGConstants.LoginFailureMessage.USER_NOT_EXIST.getDescription());
    } <span class="hljs-keyword">catch</span> (AuthenticationException e) {
        loginMessage.setMessage(BKGConstants.LoginFailureMessage.ACCOUNT_LOCK.getDescription());
    }
    <span class="hljs-keyword">return</span> loginMessage;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginMessage</span> </span>{
    <span class="hljs-keyword">private</span> String status;
    <span class="hljs-keyword">private</span> String message;
    <span class="hljs-keyword">private</span> String redirect;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginMessage</span><span class="hljs-params">(String status)</span> </span>{
        <span class="hljs-keyword">this</span>.status = status;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> status;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>{
        <span class="hljs-keyword">this</span>.status = status;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span> </span>{
        <span class="hljs-keyword">this</span>.message = message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRedirect</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> redirect;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRedirect</span><span class="hljs-params">(String redirect)</span> </span>{
        <span class="hljs-keyword">this</span>.redirect = redirect;
    }
}
</code></pre>
<h5 id="角色校验">角色校验</h5>
<p>登陆的时候,其实只是实现了 <code>登陆认证</code>,<code>缓存登录信息</code>的过程.
并没有实现,<code>权限赋予</code>的过程.只有第一次遇到 需要登陆且特定权限的url的时候,才会请求后台是否有进入对应url的权限.</p>
<p>在讲权限之前,概括一下数据库的设计</p>
<pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USERS</span>
(
    <span class="hljs-keyword">ID</span> <span class="hljs-built_in">BIGINT</span> PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,
    ACTIVE <span class="hljs-built_in">BIT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    ADDRESS <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">300</span>),
    CITY <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>),
    COMPANY <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),
    COUNTRY <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>),
    CRYPTED_PASSWORD <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>),
    DEPARTMENT <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),
    DISPLAY_NAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>),
    EMAIL <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">60</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    FAX <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>),
    FIRST_NAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>),
    GENDER <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">6</span>),
    JOBTITLE <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>),
    LAST_NAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>),
    LOCATION <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>),
    MIDDLE_NAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>),
    OFFICE <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),
    OFFICECODE <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">22</span>),
    PHONE <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>),
    <span class="hljs-keyword">SALT</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    STAFFID <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),
    STAFFROLE <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">15</span>),
    TERRITORY <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>),
    USERID <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);


<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">ROLES</span>
(
    <span class="hljs-keyword">ID</span> <span class="hljs-built_in">BIGINT</span> PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,
    DESCRIPTION <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>),
    <span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> UK_OFX66KERUAPI6VYQPV6F2OR37 <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ROLES</span> (<span class="hljs-keyword">NAME</span>);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ROLE_USER
(
    ROLE_ID <span class="hljs-built_in">BIGINT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    USER_ID <span class="hljs-built_in">BIGINT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    PRIMARY <span class="hljs-keyword">KEY</span> (ROLE_ID, USER_ID),
    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (ROLE_ID) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">ROLES</span> (<span class="hljs-keyword">ID</span>),
    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (USER_ID) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">USERS</span> (<span class="hljs-keyword">ID</span>)
);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> FK_NJAJEL6A2Q8TR36EMB9L8VW7N <span class="hljs-keyword">ON</span> ROLE_USER (USER_ID);

</code></pre>
<p>数据库有三个表 <code>USERS</code>,<code>ROLES</code>,<code>USER_ROLE</code>
其实在设计上<code>User</code>表跟<code>ROLE</code>表是多对多的关系,即User里面有一个Set&lt;Role&gt;,Role里面也有一个Set&lt;User&gt;
通过中间表<code>USER_ROLE</code>来实现多对多关联.</p>
<p>下面来看 身份认证的具体实现
<code>BookingShiroRealm.java</code></p>
<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>{
    LoginSession loginSession = (LoginSession) principals.fromRealm(getName()).iterator().next();
    <span class="hljs-keyword">if</span>(SecurityUtils.getSubject().getSession().getAttribute(LOGIN_SESSION_NAME)==<span class="hljs-keyword">null</span>){
        SecurityUtils.getSubject().getSession().setAttribute(LOGIN_SESSION_NAME, loginSession);
    }
    <span class="hljs-keyword">if</span>(SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO)==<span class="hljs-keyword">null</span>){

        UserDto userDto=userService.findUserById(loginSession.getUserId());
        <span class="hljs-keyword">if</span> (userDto != <span class="hljs-keyword">null</span>) {
            SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();
            Set&lt;RoleDto&gt; roleDtoSet=userService.getUserRolesByUserId(userDto.getId());
            <span class="hljs-keyword">for</span>(RoleDto roleDto:roleDtoSet){
                info.addRole(roleDto.getName().toLowerCase());
            }

            SecurityUtils.getSubject().getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO, info);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
    }
    <span class="hljs-keyword">return</span> (AuthorizationInfo)SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO);
}
</code></pre>
<p>通过</p>
<pre><code class="hljs Java">Subject.getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO,info)
</code></pre>
<p>来实现一个 根据通过已经登陆的用户,获取其在数据库中所具有的角色的名字的集合 生成字符串,然后存在Session里面.
当需要对应的权限,且发现已经有<code>SIMPLE_AUTHORIZATION_INFO</code>这个属性,则根据属性中是否含有对应字符串的来判定是否有对应权限.</p>
<p>当然 对应权限的获取,也是通过shiro 配置里面的captchaFilter的具体实现类,实现其<code>isAccessAllowed</code>方法来判定.</p>
<h2 id="summary">Summary</h2>
<p>本次主要分享了Share 如何在Spring中整合Apache Shiro的过程.
但是整体配置依然是通过XML统一配置,其实Shiro在近期的版本已经有了Annotation级别的方法能够方便的对URL的Mapping进行注解.
具体的应用过程,就像Spring 2.X 升级到 3.X 的过程一样,但是由于没有实战,不便多说.</p>
]]></content:encoded>
            <enclosure url="https://picsum.photos/id/927/800/300"/>
        </item>
    </channel>
</rss>